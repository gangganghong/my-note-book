---
description: 先弄清楚怎么用AST生成某种代码，再用AST生成中间代码，避免一开始就去确定使用哪种格式的中间代码。
---

# 用AST生成新代码

## 思路

这个问题困扰了我很久，我看了几次cbc代码，仍不清楚怎么用ast生成新代码。

旧代码的所有元素已知，按理说，很容易生成新代码。我的疑惑是，人脑知道所有元素，一下子就组装成新代码了。可编程将元素组装成新代码，我却觉得不知道怎么做。遍历AST的时候，只能知道一个结点是不是函数结点，函数的所有其他元素还需要继续遍历该结点的子结点。如何在不知道所有子结点的情况下组成新代码？

按照AST顺序，是从下往上还是从上往下组装？

我想不明白，只能写代码试试了。

以下面的代码为例子：

```c
int main(int ab, int df){
    if(true){
        char you;
        char ok;
    }
}
```

设置这段代码的AST的根节点是root。root的子节点有：返回数据类型、函数名、函数参数、函数体。

返回数据类型、函数名，能不需要访问它们的子节点就获得值，能直接打印或放入新代码中。

函数参数，需要访问子节点，并且，不知道需要访问到第几层才能获得它们的值，该如何处理？

函数体更复杂，又该如何处理？

遍历二叉树、逆波兰、栈，哪个能用到这里？

不能用栈，因为，丢失了信息。两个参数节点存储到栈，我怎么知道这是两个参数而不是两个变量。

不知道能不能用逆波兰，不是很熟，应该不能用吧。因为，没有存储括号等。

AST是一颗树，遍历AST就是遍历树？用哪种遍历方法？

先序遍历：根左右

中序遍历：左根右

后序遍历：左右根

root的子节点按顺序排列是：返回数据类型、函数名、函数参数、函数体。遍历时要保持这个顺序，应使用先序遍历。

处理函数参数，根据nodeType识别出是函数参数列表节点后，遍历存储参数的单链表，获取每个节点的数据，组装成目标代码的函数参数字符串，作为返回结果。

假设处理if结构的函数是B，从if节点中获取con、then、elseBody。

con比较好办，con->l->stringValue。

then，包含多个表达式expr（简化为ab=5;）。elseBody，也一样。多个表达式存储在多表达式单链表中。

处理expr，left->value + nodeType + right->value。

这就是递归！我知道递归是什么，已经用过很多次递归了。为什么不知道怎么在这里套用递归呢？

这里的递归，包含很多特殊条件，上面只是简化版本。

递归的终止条件是：递归函数的参数是 IDENTIFIER 或 NUMBER。

递归函数的返回值是char *。

不管内部如何，只需认为递归函数返回的是需要的字符串。假设递归函数是generateCode(node)，那么，上面的函数表示为：

char *funcStr = generateCode(返回数据类型) + generateCode(函数名) + generateCode(函数参数) + generateCode(函数体)

又遇到问题。在ast中，返回数据类型、函数名、函数参数、函数体 不全是相同的数据类型，一个函数要求同一个参数的数据类型一致。

怎么办？

1. 将所有在bison规则中出现的节点包装成node类型，例如，函数参数列表包装成node类型，该node有一个成员变量是单链表，在generateCode中识别出是单链表后，然后处理单链表。
   1. 不打算用这种方式，感觉很杂乱。
2. generateCode作为总函数，不用递归，对不同的子节点，使用不同的递归函数。
   1. node类型节点：使用递归函数A。
   2. 单链表：遍历单链表，对它的每个节点按类型处理，在函数B中实现
      1. node类型，使用A。
      2. 非node类型，使用它的处理函数。我暂时未想到是什么。
      3. 单链表类型，使用B。

我只愿想到这里了。遍历AST问题解决了，生成目标代码字符串，简单。

<!--不需要完全想清楚了再写出来，这是开发笔记，在我没有思路的时候，就用写来帮助思考，不易分心-->

写代码



## 时间消耗

1. 7分。

   1. 用web版gitbook新建文件，避免我在本地创建文件，能不必手工把汉字转拼音，不用写文章目录。
   2. 使用web版做这个事很耗费时间，以后可以自己写个小工具，自动化这个事情。

2. 1小时10分。

   1. 构思如何遍历AST生成目标代码。

3. 实现。

   1. 33分。将nodeType改成使用enum。跑demo，复制粘贴代码。

   2. 10分。使用“继承”struct引发的错误，暂时改不好了，还原了，仍使用冗余成员。

   3. 23分。多次改动“继承”struct，仍不能消除错误。

      1. 到目前为止，受阻于C语言语法问题，还未到业务逻辑这一步。
      2. 错误快照分支：v1-extends-struct，文件：/Users/cg/data/code/study-compiler-java/study/flex-and-bison/flex/golang/fb1-5funcs.c
      3. 在这个语法上，浪费这么多时间，错误原因未知。我无清晰思路，靠直觉调试，下次不可如此。

   4. 换用union试试。

      1. 14分。复制粘贴代码。

      2. 21分。写完遍历node节点函数traverseNode。复制粘贴，繁琐，雷同，稍有不慎，会遗漏或多加点什么。

      3. 遍历单链表funcStmtNode

         1. 10分。写了一点逻辑，然后受阻于C语言连接字符串，没有PHP、JS、C++那么方便。

         2. 24分。C语言连接字符串。常见用法，不了解。

            1. 两个已知字符串连接。

            2. 一个循环里，不确定多少个字符串连接，如下：

            3. ```c
               char *codeStr = "";
               while (cur != NULL) {
                 char *temp = traverseNode(cur->linkedListNode);
                 cur = cur->next;
               }
               ```

            4. ```c
               // 正确性未知
               char *codeStr = "";
                       while (cur != NULL) {
                           char *temp = traverseNode(cur->linkedListNode);
                           // todo 这句，能否将一个字符串赋值给另外一个？
                           char *oldCodeStr = codeStr;
                           codeStr = (char *)malloc(sizeof(char) * strlen(temp) + strlen(oldCodeStr));
                           strcpy(codeStr, oldCodeStr);
                           strcpy(codeStr, temp);
                           cur = cur->next;
                       }
               ```

      4. 7分。遍历单链表funcStmtNode、exprNode、paramNode、funcVariableNode。复制粘贴。

      5. 43分。初步测试。遇到函数返回字符串问题。字符串是内部变量，不能像PHP那样由函数返回。我改成了由函数传入指针参数来获取返回数据。由于大量重复代码，需要修改很多地方。

      6. 28分。测试。无结果，断点调试，啥也看不出来。重看代码，发现有很多nodeType没有修改过来，漏掉了一些重要节点的遍历。