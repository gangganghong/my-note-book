# 写操作系统的笔记

## 写loader

loader要完成的工作：准备好GDT、进入保护模式、读取内核文件到内存、将内核重新放置到内存中。

实模式下，能使用的最大内存是1M。地址总线是20位，能接收并寻址的最大内存地址是2的20次方-1，内存地址的初始地址是0，所以，能使用的最大内存是1M。

能不能在“准备好GDT、进入保护模式”前完成下面两项工作？

1. 读取内核文件到内存。
2. 将内核重新放置到内存中。

在测试阶段，可以，把内核写得很小就行。实际中，不行。内核所需要的空间必定会大于1M。

于上神在实模式下读取内核文件到内存中。为啥不在进入保护模式后再做这件事情？

没有找到答案，先在进入保护模式前把内核文件读取到内存吧。

怎么把内核文件读取到内存？我可以直接去看“读取loader到内存”的代码。写过的代码，也会忘记。我想先回忆，怎么把内核文件读取到内存。

读取到哪块内存？要确定存储内核文件的内存的初始位置。

用什么方法读取？用bios的系统调用（已经忘记）读取。

### 从软盘中读取数据

从哪里读取？从软盘中读取。（已经忘记了怎么从软盘中读取）。

1. 在FAT12的根目录区通过对比文件名找到目标文件对应的根目录项。
2. 从根目录项中获取目标文件在FAT中的第一个FAT项的编号（初始编号是2）。
3. 目标文件的第一个FAT项的编号的值是第二个FAT项的编号，第二个FAT项的编号是第三个FAT项的编号，剩余的FAT项的编号按照相同的方法查找。FAT项的编号，既是下一个FAT项的编号，又是目标文件在数据区的扇区号。这实质是一个单链表。
   1. FAT项的值，有的表示当前FAT项是最后一个FAT项，有的表示当前FAT项对应的簇是坏簇。具体数值，我忘记了。
4. 每个FAT项占用12位，所以，一个FAT项可能跨越扇区。为了完整获取每个FAT项，需要读取两个扇区。3个字节刚好存储2个FAT项。又忘记了那个计算公式。
5. 两个公式：
   1. 根据扇区在软盘中的扇区号，计算出扇区在软盘中的柱面号、磁头号、在X柱面X磁头的扇区号。
   2. 根据FAT项编号，计算出这个FAT项在软盘中的扇区号。
      1. 一个FAT项占用8个bit，即1.5个字节。FAT项的编号从0开始，若FAT项的编号是X，那么，这个FAT项的偏移量是X个FAT项（0~~~X-1），一共是多少个字节？X * 1.5个字节。在汇编中，X * 1.5 的等价运算是，X * 3，然后，X / 2。
      2. 结果若无余数，刚好占用整数个字节N。结果若有余数，占用整数个字节N + 0.5个字节。
      3. 无论结果是哪种，偏移量都是N个字节，因为，内存寻址的最小单位是字节，而不是其他的（比如BIT）。
      4. 无余数，偏移量就是N个字节。目标FAT项是12个bit，8 bit + 4 bit，从N-1开始，读取1个字节，再读取4个bit。
      5. 有余数，偏移量是N个字节。目标FAT项是12个bit，8 bit + 4 bit。
      6. 在4、5两个步骤想了很久，心算画图都没能解决问题。看代码后，理解了。从N字节（包括）开始，读取2个字节。
         1. 无余数，取两个字节16个bit的低12位。
         2. 有余数，取两个字节16个bit的高12位。因为，低四位属于前一个FAT项。

把数据写入内存，使用的仍然是系统调用（bios还是DOS？），能指定内存位置。

把内核文件写入内存后，再从内存中，把程序头（是这个术语吗）复制到另外的内存位置P，然后将cs:ip指向P，就能将控制权交给内核。

在控制权交给内核前，需要先初始化好GDT、进入保护模式吗？

在内核中，会使用1M之外的内存，因此，需要进入保护模式。在保护模式下，内存寻址需要GDT，因此，需要初始化GDT。

但是，也可以不在内核中使用1M之外的内存吧？

### 重新放置内核到内存

一个星期前，写过这个知识点的文章，此刻，又忘记了。

内核文件，是ELF文件。读取内核到内存，就是把ELF文件的所有程序段读取到指定的内存位置。

ELF文件的构成要素：ELF头，sections(节)，节头表，程序头表。

唉！忘记了，全忘记了！

学习很艰难，或者说，记忆很艰难。我十天前一个字一个字写出的文章，再看，很陌生，好像看不懂了。

使用函数 `memcpy(程序段在内存中的虚拟地址，程序段在内存中的地址，程序段的长度)` 实现功能。复制操作会重复进行，重复次数由程序段的个数决定。

从elf头中能获取由多少个程序段。从程序头中能获取`memcpy`的三个参数。

有几个疑问：

1. 为什么重新放置内核的目标地址是虚拟内存地址？
   1. 不清楚。搁置。后面再看。
2. 虚拟内存地址是什么？
   1. 逻辑地址。段地址：偏移量。
   2. 线性地址。实模式下，段地址*16+偏移量。保护模式下，选择子-->全局描述符-->段基址+偏移量。
   3. 物理地址。没有开启页机制，线性地址就是物理地址。
   4. 虚拟地址。是上面的哪个地址？不是任何一个。涉及到MMU等，在目前的书和代码中，没有提到这个东西，先搁置吧。

#### 实现memcpy

```assembly
; Mempcy(程序段的虚拟内存地址，程序段在内存中的地址，程序段的长度)
; 逐字节复制
; [es:di]--->[ds:si]
Memcpy:
	push ax
	push cx
	push bp
	mov bp, sp
	; 三个参数
	mov cx, [bp+16]
	mov di, [bp+12]
	mov si, [bp+8]
	
.1:
	cmp cx, 0
	jmp .2
	mov al, [ds:si]
	mov [es:di], al
	inc di
	inc si
	dec cx
	jmp .1
	
.2
	mov ax, [bp+8]
	
	pop bp
	pop cx
	pop ax
	
	
	ret
```



很不熟练。大概需要20分钟才能写得出来这个函数。

疑问。函数堆栈中的第一个元素、第二个元素，分别是什么？

![image-20210218173229879](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210218173229879.png)

call的作用是把eip入栈。



![image-20210218173248737](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210218173248737.png)



ret的作用是把参数和eip出栈。



![image-20210218173326540](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210218173326540.png)



长调用，call把cs、eip入栈。

长调用是不同段间的调用。

我不愿先开启保护模式再重新放置内核，是因为我不想写GDT那块代码，更具体地说，我不想写特权级那块的代码。

特权级，我还没有弄明白是咋回事。RPL、CPL、DPL，很烦。

进入保护模式之后，才重新放置内核到内存中。为何如此？因为，在内核中，需要使用1M之上的内存。

#### 开启保护模式

很简单，套路。打开A20，设置cr0。一个跳转。

#### 初始化GDT

这很难。最难的是，设置全局描述符的属性。

需要几个段？至少三个。

第一个：代码段。

第二个：数据段。

第三个：视频段。

上面是我的设想。看看于上神怎么做的。

### v1-loader

第一版v1。实现一个功能：把内核文件读取到内存中。模仿于上神的方法，复制一个新文件夹。

大部分内容与boot一样，从软盘中读取名为“kernel.bin"的文件，并且放置到内存位置为A的那片内存。

我打算直接复制boot.asm的代码。重新写一次，很耗费时间，调试更加耗费时间。这个知识，并不常用。

但是，可以复述一下读取数据到内存的过程。

使用bios的系统调用读取数据。这个系统调用需要一些参数，柱面号、磁头号、偏移扇区号，读取到哪里。

#### 用扇区号计算bios系统调用的参数

根据扇区号，能计算出所需要的参数。扇区号又能从软盘的头信息中获取。

扇区号除以每磁道包含的扇区数，商是磁道数，余数是在X柱面X磁头的扇区偏移量，扇区号是余数+1。

磁道数除以每个柱面包含的磁道的数量，商是柱面号，余数没有作用。

磁道数 & 1，结果是磁头号。（这个公式，理解起来，仍然有点费劲）

这个计算方法的前提是，每个柱面包含2个磁道，有两个磁头。

#### 用FAT编号计算扇区号

1. 使用FAT编号计算出字节偏移量O、整数字节偏移量ON。
   1. O是整数，O等于ON，字节O、字节O+1两个字节的低12位是当前FAT项。
   2. O不是整数，字节ON、字节ON+1两个字节的高12位是当前FAT项。因为低4位上一个FAT项的高4位。
2. 判断FAT编号为N的FAT项的字节偏移量是不是整数字节的方法：
   1. N * 3 / 2
   2. 检查上一步的余数是不是0
      1. 是0，整数。
      2. 不是0，非整数。
   3. 原理：一个FAT项占用1.5个字节，编号为N的FAT项的字节偏移量是N * 1.5。上面的计算公式是N * 1.5的等价运算。

怎么写loader？完全没有思路。只能参考于神的代码。

没有section，开头必须是`org 0x100`。

#### debug1

读取内核文件的时候，获取到的第一个FAT项的编号是0。这是不正确的。

我试图验证，是读取kernel文件时出错了吗？

已知di，如何查看某个段内的数据？用bochs。

````shell
xp /1wx 0x800:0x100

xp /1wx 0x800:0x120
xp /1wx 0x800:0x140
xp /1wx 0x800:0x160
xp /1wx 0x800:0x180

xp /1wx 0x800:0x19a

<bochs:16> r
CPU0:
rax: 00000000_0000004c
rbx: 00000000_00000b90
rcx: 00000000_0009000b
rdx: 00000000_00000000
rsp: 00000000_0000ffd4
rbp: 00000000_00000000
rsi: 00000000_000e7d07
rdi: 00000000_00000100
r8 : 00000000_00000000
r9 : 00000000_00000000
r10: 00000000_00000000
r11: 00000000_00000000
r12: 00000000_00000000
r13: 00000000_00000000
r14: 00000000_00000000
r15: 00000000_00000000
rip: 00000000_00007c78


xp /1wx 0x800:0x17a

xp /1bx 0x0:0xe7d06


# si 的值虽然是 00000000_000e7d07，但是，lodsb 的等价运算 lodsb al, byte ptr ds:[si] 中的 si 的值应该是 0x7d06 而不是 0xe7d06。原因未知，这是运行代码得到的结果。

xp /1bx 0x0:0x7d06

xp /1bx 0x9000:0xe7d06


xxd -u -a -g 1 -c 16 -s +9728 -l 1024 a.img
````

### v2-loader

#### 重新放置内核

在实模式下，`0x80000`是能够被使用的内存地址。`0x80000`是32KB，在1MB之内。

elf格式的内核文件的开头是elf头。从elf头中，能获取：

1. 程序头的个数。
2. 程序头表在内核文件中的偏移量。

内核文件的物理位置，加上程序头表在内核文件中的偏移量，等于程序头表的位置。在第一个程序头中，能获取这个程序头对应的程序段的虚拟内存地址、目标程序段在文件中的偏移量、目标程序段的长度。

怎么从elf头和程序头中获取数据呢？根据元素的数据类型。假如，在elf头中，程序头的个数是第三个元素，前两个元素的数据类型都占用4个字节，那么，程序头的个数从第8个字节开始。具体数字，我忘记了。

#### Memcpy

按字节复制，第三个参数是多少，就循环多少次。每次循环，把数据从第二个参数内存位置复制到第一个参数内存位置。

使用什么完成的复制？用al做中间变量。在[es:di]和[ds:si]之间复制。es和ds的值，需要注意。

这个函数有返回值。返回值是第一个参数内存位置，把它放在ax中返回。

循环，仍然不使用loop，而是使用cx手工完成。

调用函数时，`call Memcpy`，需要对`sp`进行操作吗？是增还是减？数量呢？

`sub sp, 4`。使用减。是必须的。原因是，不能影响与函数调用无关的栈。

~~例如，函数参数入栈前，sp的位置是16，`sub sp,4`后，sp的位置是12，入栈一个参数后，sp的位置是10。位置10到位置0的数据不会覆盖位置16。这段解说是错误的。~~

只需要在调用结束后，对sp进行加操作，释放参数占用的栈空间。

可以用 `/home/cg/yuyuan-os/osfs09/f` 中的文件分析elf、FAT12系统。

#### 分析elf

```shell
[root@localhost v2]# xxd -u -a -g 1 -c 16  kernel.bin
00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010: 02 00 03 00 01 00 00 00 00 04 03 00 34 00 00 00  ............4...
00000020: 18 04 00 00 00 00 00 00 34 00 20 00 01 00 28 00  ........4. ...(.
00000030: 03 00 02 00 01 00 00 00 00 00 00 00 00 00 03 00  ................
00000040: 00 00 03 00 06 04 00 00 06 04 00 00 05 00 00 00  ................
00000050: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
*
00000400: EB FE EB FE EB FE 00 2E 73 68 73 74 72 74 61 62  ........shstrtab
00000410: 00 2E 74 65 78 74 00 00 00 00 00 00 00 00 00 00  ..text..........
00000420: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000430: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000440: 0B 00 00 00 01 00 00 00 06 00 00 00 00 04 03 00  ................
00000450: 00 04 00 00 06 00 00 00 00 00 00 00 00 00 00 00  ................
00000460: 10 00 00 00 00 00 00 00 01 00 00 00 03 00 00 00  ................
00000470: 00 00 00 00 00 00 00 00 06 04 00 00 11 00 00 00  ................
00000480: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00  ................
```



```shell
00000040: 00 00 03 00 06 04 00 00 06 04 00 00 05 00 00 00  ................
```



```shell
00000400: EB FE EB FE EB FE 00 2E 73 68 73 74 72 74 61 62  ........shstrtab
```



`EB FE EB FE EB FE`是下面代码的机器码，总计6个字节，与`00000040: 00 00 03 00 06 04 00 00 06 04 00 00 05 00 00 00  ................`中的`06`吻合。

```assembly
[section .text]

global _start

_start:
;       mov ax, 0xB800
        jmp $
        jmp $
        jmp $
;       mov gs, ax
;       mov ah, 0Fh
;       mov al, 'C'
;       mov [gs:(80 * 20 + 40) * 2], ax
;       jmp $
```



仅存的疑问：

```assembly
; InitKernel ---------------------------------------------------------------------------------
; 将 KERNEL.BIN 的内容经过整理对齐后放到新的位置
; 遍历每一个 Program Header，根据 Program Header 中的信息来确定把什么放进内存，放到什么位置，以及放多少。
; --------------------------------------------------------------------------------------------
InitKernel:
        xor   esi, esi
        mov   cx, word [BaseOfKernelFilePhyAddr+2Ch];`. ecx <- pELFHdr->e_phnum
        movzx ecx, cx                               ;/
        mov   esi, [BaseOfKernelFilePhyAddr + 1Ch]  ; esi <- pELFHdr->e_phoff
        add   esi, BaseOfKernelFilePhyAddr;esi<-OffsetOfKernel+pELFHdr->e_phoff
.Begin:
        mov   eax, [esi + 0]
        cmp   eax, 0                      ; PT_NULL
        jz    .NoAction
        push  dword [esi + 010h]    ;size ;`.
        mov   eax, [esi + 04h]            ; |
        add   eax, BaseOfKernelFilePhyAddr; | memcpy((void*)(pPHdr->p_vaddr),
        push  eax		    ;src  ; |      uchCode + pPHdr->p_offset,
        push  dword [esi + 08h]     ;dst  ; |      pPHdr->p_filesz;
        call  MemCpy                      ; |
        add   esp, 12                     ;/
.NoAction:
        add   esi, 020h                   ; esi += pELFHdr->e_phentsize
        dec   ecx
        jnz   .Begin

        ret
```



```assembly
mov   eax, [esi + 04h]            ; |
add   eax, BaseOfKernelFilePhyAddr; | memcpy((void*)(pPHdr->p_vaddr),
```



`BaseOfKernelFilePhyAddr`是文件开头，内容是：`00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............`。

可是，我猜想，重新放置内核，需要复制的内容是：`00000400: EB FE EB FE EB FE 00 2E 73 68 73 74 72 74 61 62  ........shstrtab`。没有找到能达到这个目的的代码。

#### 小结

今天，又耗费了一天，没有完成“重新放置内存”。

1. 直接读取elf文件到内存中，就像处理DOS文件一样，跳转到elf文件，就能执行。那么，就没有必要使用elf了。
2. 理解不了于上神重新放置内存的代码，具体说，源代码的位置，理解不了。
3. 直接操作显存，显存数值的列与行坐标，都不能超过最大值，否则，数据不会在屏幕上显示。
4. 解析elf文件、fat12系统，一定要分析一个实例，并且把分析过程准确记录下来。若心算太慢，就用笔算。
5. 不能读取全部指令，那么，这些指令一条也不会被执行。



为啥进展这么慢？时间跨度长达一天，我不记得准确细节了。遇到棘手的问题，立刻用写作来辅助思路，不要心算。

#### debug

```shell
prefetch: EIP [00010000] > CS.limit [0000ffff]
```

.COM文件的大小为什么不能超过64KB？

在实模式下跳转

```shell
loader.asm:192: warning: word data exceeds bounds [-w+number-overflow]
loader.asm:192: warning: word data exceeds bounds [-w+number-overflow]
```



```shell
<bochs:2> sreg
es:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
cs:0xf000, dh=0xff0093ff, dl=0x0000ffff, valid=7
	Data segment, base=0xffff0000, limit=0x0000ffff, Read/Write, Accessed
ss:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
ds:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
fs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1
tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1
gdtr:base=0x0000000000000000, limit=0xffff
idtr:base=0x0000000000000000, limit=0xffff
```



#### 实例分析elf文件一

```assembly
[section .text]
STR:    db      "Hello"
LEN     equ     $-STR

global _start

_start:
        jmp $
        mov eax, 4

        mov ebx, 1
        mov ecx, STR
        mov edx, LEN
        int 0x80
        mov eax, 1
        mov ebx, 0
        int 0x80
```



用下面的命令编译这个文件

```shell
[root@localhost v2]# nasm -f elf -o kernel.o kernel.asm
# 在 64 位 centos 上编译32位汇编代码，需要使用 -m elf_i386
[root@localhost v2]# ld -s -o kernel kernel.o -m elf_i386
```

查看编译出来的文件kernel的二进制数据

```shell
[root@localhost v2]# xxd -u -a -g 1 -c 16 kernel
00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010: 02 00 03 00 01 00 00 00 65 80 04 08 34 00 00 00  ........e...4...
00000020: 98 00 00 00 00 00 00 00 34 00 20 00 01 00 28 00  ........4. ...(.
00000030: 03 00 02 00 01 00 00 00 00 00 00 00 00 80 04 08  ................
00000040: 00 80 04 08 87 00 00 00 87 00 00 00 05 00 00 00  ................
00000050: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 48 65 6C 6C 6F B8 04 00 00 00 BB 01 00 00 00 B9  Hello...........
00000070: 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00 00 00  `...............
00000080: BB 00 00 00 00 CD 80 00 2E 73 68 73 74 72 74 61  .........shstrta
00000090: 62 00 2E 74 65 78 74 00 00 00 00 00 00 00 00 00  b..text.........
000000a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000c0: 0B 00 00 00 01 00 00 00 06 00 00 00 60 80 04 08  ............`...
000000d0: 60 00 00 00 27 00 00 00 00 00 00 00 00 00 00 00  `...'...........
000000e0: 10 00 00 00 00 00 00 00 01 00 00 00 03 00 00 00  ................
000000f0: 00 00 00 00 00 00 00 00 87 00 00 00 11 00 00 00  ................
00000100: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00  ................
```



第一个程序头

![image-20210221140113344](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210221140113344.png)

第一个程序段在文件中的偏移量

![image-20210221140214796](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210221140214796.png)

第一个程序段的虚拟内存地址`08048000`。

![image-20210221140427497](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210221140427497.png)

第一个程序段的长度：0087H

![image-20210221140533376](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210221140533376.png)

第一个程序段的内容：

![image-20210221140658787](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210221140658787.png)

程序的入口：`08048065`。

![image-20210221143530667](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210221143530667.png)

第一个程序段被复制到的虚拟内存地址是`08048000h`，程序的入口也是一个虚拟内存地址：`08048065h`。可见，前面的`65h`个字节不是指令，换句话说，从第`66h`个字节开始，才是指令数据。这段数据有多长呢？第一个程序段的长度是`0087H`，所以，第一个程序段的数据是：

```shell
[root@localhost v2]# xxd -u -a -g 1 -c 16 kernel
00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010: 02 00 03 00 01 00 00 00 65 80 04 08 34 00 00 00  ........e...4...
00000020: 9C 00 00 00 00 00 00 00 34 00 20 00 01 00 28 00  ........4. ...(.
00000030: 03 00 02 00 01 00 00 00 00 00 00 00 00 80 04 08  ................
00000040: 00 80 04 08 89 00 00 00 89 00 00 00 05 00 00 00  ................
00000050: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 48 65 6C 6C 6F EB FE B8 04 00 00 00 BB 01 00 00  Hello...........
00000070: 00 B9 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00  ..`.............
00000080: 00 00 BB 00 00 00 00
```

第一个程序段的指令数据的开始位置是距离文件偏移量为`65h`个字节的位置，即

```shell
00000060: 48 65 6C 6C 6F EB FE B8 04 00 00 00 BB 01 00 00  Hello...........
00000070: 00 B9 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00  ..`.............
00000080: 00 00 BB 00 00 00 00
```

把指令数据单独截取出来，是

```shell
# ----------------- 表示非指令数据
00000060: ----------------- EB FE B8 04 00 00 00 BB 01 00 00  Hello...........
00000070: 00 B9 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00  ..`.............
00000080: 00 00 BB 00 00 00 00
```

`jmp $`的二进制代码是`EB FE`，吻合。再验证一次。

将源代码修改为：

```assembly
[section .text]
STR:    db      "Hello"
LEN     equ     $-STR

global _start

_start:
        jmp $
        mov eax, 4

        mov ebx, 1
        mov ecx, STR
        mov edx, LEN
        int 0x80
        mov eax, 1
        mov ebx, 0
        int 0x80
        jmp $
```



```shell
[root@localhost v2]# xxd -u -a -g 1 -c 16 kernel
00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010: 02 00 03 00 01 00 00 00 65 80 04 08 34 00 00 00  ........e...4...
00000020: 9C 00 00 00 00 00 00 00 34 00 20 00 01 00 28 00  ........4. ...(.
00000030: 03 00 02 00 01 00 00 00 00 00 00 00 00 80 04 08  ................
00000040: 00 80 04 08 8B 00 00 00 8B 00 00 00 05 00 00 00  ................
00000050: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 48 65 6C 6C 6F EB FE B8 04 00 00 00 BB 01 00 00  Hello...........
00000070: 00 B9 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00  ..`.............
00000080: 00 00 BB 00 00 00 00 CD 80 EB FE 00 2E 73 68 73  .............shs
00000090: 74 72 74 61 62 00 2E 74 65 78 74 00 00 00 00 00  trtab..text.....
000000a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000c0: 00 00 00 00 0B 00 00 00 01 00 00 00 06 00 00 00  ................
000000d0: 60 80 04 08 60 00 00 00 2B 00 00 00 00 00 00 00  `...`...+.......
000000e0: 00 00 00 00 10 00 00 00 00 00 00 00 01 00 00 00  ................
000000f0: 03 00 00 00 00 00 00 00 00 00 00 00 8B 00 00 00  ................
00000100: 11 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00  ................
00000110: 00 00 00 00
```



程序入口虚拟内存地址：`65 80 04 08`，`08048065h`。它在文件中的偏移量是24个字节。

第一个程序段的长度是：`8B 00 00 00`，`8Bh`。它在程序头中的偏移量是`10h`个字节。二进制数据如下：

```shell
00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010: 02 00 03 00 01 00 00 00 65 80 04 08 34 00 00 00  ........e...4...
00000020: 9C 00 00 00 00 00 00 00 34 00 20 00 01 00 28 00  ........4. ...(.
00000030: 03 00 02 00 01 00 00 00 00 00 00 00 00 80 04 08  ................
00000040: 00 80 04 08 8B 00 00 00 8B 00 00 00 05 00 00 00  ................
00000050: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 48 65 6C 6C 6F EB FE B8 04 00 00 00 BB 01 00 00  Hello...........
00000070: 00 B9 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00  ..`.............
00000080: 00 00 BB 00 00 00 00 CD 80 EB FE
```

第一个程序段的虚拟内存地址是：`00 80 04 08`，`08048000h`。它在程序头中的偏移量是`08h`个字节。

上面二进制数据中的行号如`00000010`是十六进制数，是数据在文件中的位置编号（内存地址是内存中的位置编号）。把这些数据复制到内存中后，如果能查看内存中的数据，这些数据的内存地址的编号的相对位置（偏移量）和它们在文件中的相对位置相同。如果把这个程序段复制到内存地址为`08048000h`初始位置的一段内存，那么，在内存中，二进制数据如下：

```shell
08048000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
08048010: 02 00 03 00 01 00 00 00 65 80 04 08 34 00 00 00  ........e...4...
08048020: 9C 00 00 00 00 00 00 00 34 00 20 00 01 00 28 00  ........4. ...(.
08048030: 03 00 02 00 01 00 00 00 00 00 00 00 00 80 04 08  ................
08048040: 00 80 04 08 8B 00 00 00 8B 00 00 00 05 00 00 00  ................
08048050: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
08048060: 48 65 6C 6C 6F EB FE B8 04 00 00 00 BB 01 00 00  Hello...........
08048070: 00 B9 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00  ..`.............
08048080: 00 00 BB 00 00 00 00 CD 80 EB FE
```

二进制数据的入口地址是`08048065h`，很容易得到下面的结论。

指令二进制数据如下：

```shell
00000060: ----------- EB FE B8 04 00 00 00 BB 01 00 00  Hello...........
00000070: 00 B9 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00  ..`.............
00000080: 00 00 BB 00 00 00 00 CD 80 EB FE
```

开头和结尾都是`EB FE`，源代码的开头和结尾也都是`jmp $`，吻合。

#### 疑难杂症

1. .COM文件的大小为啥不能超过64KB？
2. 在loader中跳转到kernel，跳转目标是随意设定的，但仍然能执行kernel中的指令，这是为什么？kernel是elf文件、DOS文件都是如此。
3. 内核有必要编译成ELF文件吗？
4. 由于可随意指定跳转的目标地址，所以，无法验证重新放置内核是否正确。怎么验证重新放置内核是否正确？



昨天就被这个问题阻碍了，一直没有明确问题，而是在分析ELF文件等。没有详细记录，总之，时间被不明不白地消耗掉了。



```shell
prefetch: EIP [00010000] > CS.limit [0000ffff]
```

哪条语句导致这个问题？

没有`jmp $`会导致这句。	

一个重要的猜想：cpu执行机器指令时，若当前指令是合法指令，就执行；若是不能识别的指令，就跳过继续执行下一条指令。

基于这个猜想，上面的第2个问题，就能解释清楚了。无论kernel是ELF文件还是DOS文件或其他文件，将IP指向这个文件，遇到了文件中的合法指令，就会执行。因此，我能看到执行效果。

既然如此，似乎没有必要在内存中重新放置ELF文件啊，把它们全部复制到内存中，然后逐条执行不也可以吗？的确是可以，我能想到的弊端除了“耗费内存、耗费CPU”外，再也想不到其他需要ELF的必要性了。

我已经验证了上面的猜想。验证方法是：

1. 用两条`jmp $`作为kernel的结尾。第2条kernel的偏移量是`73h`。那么，跳过所有指令的地址相对于第一个段的开头的偏移量是`75h`。

2. 将跳转目标设置为：`jmp BaseOfKernel:75h`。执行结果，没有打印字符，重复出现`prefetch: EIP [00010000] > CS.limit [0000ffff]`。

3. 将跳转目标设置为：`jmp BaseOfKernel:73h`。没有打印字符，也没有重复出现`prefetch: EIP [00010000] > CS.limit [0000ffff]`。这是执行了`jmp $`的原因。

4. 将跳转目标设置为：`jmp BaseOfKernel:61h`。执行结果，打印出了字符。

   1. ip应该指向程序的入口地址，据此，跳转目标应该如此设置：`jmp BaseOfKernel:60h`。可是执行结果却有多远的闪烁字符。

      1. ```shell
         ext at t=14396751
         (0) [0x000000080060] 8000:0060 (unk. ctxt): mov eax, 0xe88eb800       ; 66b800b88ee8
         ```

      2. ```
         <bochs:3> s
         Next at t=14396751
         (0) [0x000000080061] 8000:0061 (unk. ctxt): mov ax, 0xb800            ; b800b8
         ; 66 b800 b8 8ee8
         ; 	 b800 b8
         ```

      3. ```shell
         00000060: 66 B8 00 B8 8E E8 B4 0F B0 43 65 66 A3 D0 0C 00  f........Cef....
         ```

      4. 跳转目标的偏移量应该是`60h`。可执行结果为何异常？

下面是用来验证的源代码：

```assembly
;[section .text]

;global _start

;_start:
        ;mov ax, 2
        ;jmp $
        mov ax, 0xB800
       ;jmp $
       ;jmp $
       ;jmp $
        mov gs, ax
        mov ah, 0Fh
        mov al, 'C'
        mov [gs:(80 * 20 + 40) * 2], ax
        jmp $
        jmp $
```



编译上面的代码后，用xxd查看二进制数据：

```assembly
[root@localhost v2]# xxd -u -a -g 1 -c 16 kernel.bin
00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010: 02 00 03 00 01 00 00 00 60 80 04 08 34 00 00 00  ........`...4...
00000020: 88 00 00 00 00 00 00 00 34 00 20 00 01 00 28 00  ........4. ...(.
00000030: 03 00 02 00 01 00 00 00 00 00 00 00 00 80 04 08  ................
00000040: 00 80 04 08 75 00 00 00 75 00 00 00 05 00 00 00  ....u...u.......
00000050: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 66 B8 00 B8 8E E8 B4 0F B0 43 65 66 A3 D0 0C 00  f........Cef....
00000070: 00 EB FE EB FE 00 2E 73 68 73 74 72 74 61 62 00  .......shstrtab.
00000080: 2E 74 65 78 74 00 00 00 00 00 00 00 00 00 00 00  .text...........
00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000b0: 0B 00 00 00 01 00 00 00 06 00 00 00 60 80 04 08  ............`...
000000c0: 60 00 00 00 15 00 00 00 00 00 00 00 00 00 00 00  `...............
000000d0: 10 00 00 00 00 00 00 00 01 00 00 00 03 00 00 00  ................
000000e0: 00 00 00 00 00 00 00 00 75 00 00 00 11 00 00 00  ........u.......
000000f0: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00  ................
```



从上面的二进制数据中提取关键数据：

1. 第一个程序段的长度：

   1. ```shell
      00000030: ----------- 01 00 00 00 00 00 00 00 00 80 04 08  ................
      00000040: 00 80 04 08 75 00 00 00 75 00 00 00 05 00 00 00  ....u...u.......
      00000050: 00 10 00 00 -----------------------------------   ................
      ```

   2. ```
      00000030: ----------- ** ** ** ** ** ** ** ** ** ** ** **  ................
      00000040: ** ** ** ** 75 00 00 00 ** ** ** ** ** ** ** **  ....u...u.......
      00000050: ** ** ** ** -----------------------------------   ................
      ```

   3. 经过上面的分析，结果是`75 00 00 00`，`75h`。

2. 第一个程序段在文件中的偏移量：`00 80 04 08`

3. 程序的入口地址（即ip应该指向哪个地址)：

   1. ```shell
      00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
      00000010: 02 00 03 00 01 00 00 00 60 80 04 08 34 00 00 00  ........`...4...
      ```

   2. 偏移量是：`60 80 04 08`，它在文件中的偏移量是`24h`。

##### 验证重新放置后的内核

下面的代码都运行在实模式下。

通过bochs断点调试验证。

```assembly
; Memcpy(p_vaddr, p_off, p_size)
Memcpy:
        push bp
        ; 在新元素入栈前获取sp，方便获取函数的参数。
        mov bp, sp
        push ax
        push cx
        push si
        push di
        ;mov bp, sp
        ;mov di, [bp + 4]        ; p_vaddr，即 dst
        ;mov si, [bp + 8]        ; p_off，即 src
        ;mov cx, [bp + 12]      ; 程序头的个数，即p_size

        ;mov di, [bp + 8]        ; p_vaddr，即 dst
        ;mov si, [bp + 12]        ; p_off，即 src
        ;mov cx, [bp + 16]       ; 程序头的个数，即p_size
				
				; 增幅为何是2？因为，这是在实模式下的汇编代码，每个参数的长度是16位，即2个字节。
				; 注意，[bp+4]中的4的单位是字节，8个bit。
				; 为什么第一个参数是[bp+4]？因为开头push bp，[bp+2]是原始bp。
				; 那么，[bp+0]是什么？[bp+0]是call Func入栈的ip。
        mov di, [bp + 4]        ; p_vaddr，即 dst。函数的第一个参数。
        mov si, [bp + 6]        ; p_off，即 src。函数的第二个参数。
        mov cx, [bp + 8]       ; 程序头的个数，即p_size。函数的第三个参数。
        ; 因为，这个函数的功能是，把数据从0x8000开始的内存复制到从0x6000开始的内存，所以，要修改es。
        ; 因为下面复制数据是在[es:di]和[ds:si]之间复制。
        push es
        mov es, di
        mov di, 0

.1:
        mov byte al, [ds:si]
        mov [es:di], al
        inc si
        inc di
        dec cx

        cmp cx, 0
        jz .2
        jmp .1

.2:
        pop es
        mov ax, [bp + 4]

        pop di
        pop si
        pop cx
        pop ax
        pop bp

        ret
```



```assembly
; 重新放置内核
InitKernel:
       push ax
       push cx
       push si
       ; commont start
       ; mov cx, [BaseOfKernel3 + 2CH] 的实质是 mov cx, word ptr ds:0x802c这种语句，所以，需要修改ds和BaseOfKernel3。
       mov ax, 0x8000
       push ds
       mov ds, ax
       ; commont end
        xchg bx, bx
       ;程序段的个数
        ;mov cx, word ptr ds:0x802c
       ; mov cx, [BaseOfKernel3 + 2CH] 等价于 mov cx, word ptr ds:BaseOfKernel3 + 2CH。
       ; 这是断点调试看到的，原因未知。
       ; 另外，mov cx, word ptr 0x0:0x802c 结果与 mov cx, word ptr 0x8000:0x2c 不同。
       mov cx, [BaseOfKernel3 + 2CH]
       ; mov ax, [BaseOfKernel + 2CH]
       ;程序头表的内存地址
       xor si, si
       mov si, [BaseOfKernel3 + 1CH]
       add si, BaseOfKernel3
        xchg bx, bx

.Begin2:
      mov ax, [si + 10H]
      ;push word [si + 10H]
      push word ax

       mov ax, BaseOfKernel3
       add ax, [si + 4H]
       push word ax
        mov ax, [si + 8H]
        push ax
        ;push word [si + 8H]
        xchg bx, bx
        call Memcpy
        xchg bx, bx
        ; 三个参数，占用3个字,6个字节
        add sp, 6
        dec cx
        cmp cx, 0
        jz .NoAction
        add si, 20H
        jmp .Begin2
;
.NoAction:
        pop ds
        pop si
        pop cx
        pop ax

        ret
        
BaseOfKernel    equ     0x8000
BaseOfKernel2   equ     0x6000
BaseOfKernel3   equ     0x0
OffSetOfLoader  equ     0x0
BaseOfFATEntry  equ     0x1000
```



耗费了两天左右（可能是三天），才写完了实模式下的“重新放置内核”功能。大概在昨天这个时候取得突破。

遇到的问题分别有：

1. Loader.asm中的代码不执行。boot.asm只能读取一个扇区的数据。偶然想到的，之前遇到过。
2. Kernel.asm执行不正常（没有打印应该打印的字符）。设置显存坐标超过最大值了，例如，把行坐标设置为28。
3. kernel是不是elf文件都能执行。我的猜测，cpu遇到可执行指令就执行，遇到不可执行指令要么什么也不做要么报错。只要设置的起点在可执行指令的前面，总会执行到可执行指令。因此，无论是否elf文件都能执行。
4. 不重新放置内核都能正常执行。原因同3。
5. 栈
   1. 实模式下栈的增幅是2个字节（16个bit），我把增幅写成了4个字节（32个bit）。
   2. 在函数调用中，先将原始bp入栈，再通过bp从栈中获取参数。
6. 验证“重新放置内核“是否成功。例如，将内核重新放置到了0x6000:0x400，那么，通过bochs断点调试来查看二进制代码与xxd在查看kernel.bin到的二进制代码是否一致就能验证”重新放置内核“是否成功。
   1. 这个验证，只能证明只有一个程序段的内核被重新放置。



解决这个问题为什么很慢？没有明确问题是什么，仅仅只是觉得不正确，然后就一次次地没有明确目的地调试。突破出现在我明确界定问题之后。

`kernel.asm`内容如下：

```assembly
[section .text]

global _start

_start:
        ;mov ax, 2
        ;jmp $
        xchg bx, bx
        mov ax, 0xB800
       ;jmp $
       ;jmp $
       ;jmp $
        mov gs, ax
        mov ah, 0Fh
        mov al, 'C'
        mov [gs:(80 * 20 + 40) * 2], ax
        mov [gs:(80 * 21 + 40) * 2], ax
        mov [gs:(80 * 22 + 80) * 2], ax
        jmp $
        jmp $
```

上面的源代码中是否包含“global _start _start:"等语句不影响这份源代码能不能编译成elf文件。只要在编译时指定了`-f elf`就能把它编译成elf文件。我的猜想，`section`等没有对应的二进制代码，只是给人类看的，在二进制文件中不包含`section`这类指令。

#### bochs xp

x /nuf [addr] 显示线性地址的内容

xp /nuf [addr] 显示物理地址的内容

n 显示的单元数

u 每个显示单元的大小，u可以是下列之一：

b BYTE

h WORD

w DWORD

g DWORD64

注意: 这种命名法是按照GDB习惯的，而并不是按照inter的规范。

### v3-loader

这个版本，完成下面的功能：

1. 准备好GDT。
2. 开启保护模式。
3. 进入保护模式。
4. 重新放置内核。



最大的难点是，准备好GDT，更具体地说，是特权级(CPL、DPL、RPL)。

完全不知道怎么写。想到什么写什么吧。

重新放置内核是在实模式下还是在保护模式下？在保护模式下。因为，内核的入口地址是`0x30400`。在下面的代码中，

```assembly
READ_FILE_OVER:
        xchg bx, bx
        mov al, 'O'
        mov ah, 0Dh
        mov [gs:(80 * 23 + 33) * 2], ax
        ; 在内存中重新放置内核
        call InitKernel

        xchg bx, bx
        ;jmp BaseOfKernel:73h
        ;jmp BaseOfKernel:61h
        jmp BaseOfKernel2:400h
        ;jmp BaseOfKernel:60h
        ;jmp BaseOfKernel:0
        ;jmp BaseOfKernel:OffSetOfLoader
        ;jmp BaseOfKernel2:0x30400
        ;jmp BaseOfKernel:OffSetOfLoader
        ;jmp BaseOfKernel:40h
        ;jmp OVER
        
BaseOfKernel2   equ     0x30000  
```

`jmp BaseOfKernel2:400h`会跳转到`0x30400`。

编译时出错：

```shell
[root@localhost v3]# make
nasm -o loader.bin loader.asm
loader.asm:194: warning: word data exceeds bounds [-w+number-overflow]
dd if=boot.bin of=a.img count=1 conv=notrunc
```



```shell
<bochs:2> sreg
es:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
cs:0xf000, dh=0xff0093ff, dl=0x0000ffff, valid=7
	Data segment, base=0xffff0000, limit=0x0000ffff, Read/Write, Accessed
ss:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
ds:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
fs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1
tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1
gdtr:base=0x0000000000000000, limit=0xffff
idtr:base=0x0000000000000000, limit=0xffff
```



~~我的猜想是，在实模式下，`jmp 段地址：偏移量`中的段地址的最大值是`0xffff`。`jmp 0x30000`超过了这个最大值，因此不能正确执行。~~

16位寄存器不能存储`0x30000`，这才是这份代码不能正确执行的原因。

#### 需要设置几个全局描述符

不知道。

在哪里需要用到全局描述符？不知道。

在哪里需要用到GDT的选择子。不知道。

全局描述符的属性应该怎么设置？不知道。这些属性不能随意设置吗？不知道。

这么多不知道的知识点，空想也没有用，只能看别人的代码了。一直以来，我都是这样做的。

怎么写操作系统？我遵循的流程是：

1. 自己想。
2. 想不出怎么写，看别人的代码，理解每一行代码，记下来，能复述出来。
3. 根据复述出来的知识点，自己动手写代码。
4. 测试代码。

以后的每项功能，都用这个流程去开发。



#### 实模式下的内存寻址方式

在实模式下，内存的寻址方式是：

1. 内存地址是：段地址:偏移量，例如：`0x6000:0x400`。
2. 这个内存地址的物理地址是：`0x60400`。计算公式是：物理地址 = 段地址 * 16 + 偏移量。

怎么验证这个公式呢？用下面的方法。

```assembly
jmp BaseOfKernel2:400h
BaseOfKernel2:	db 0x6000
```

使用bochs断点查看

```shell
<bochs:8> xp /1hx 0x6000:0x400
[bochs]:
0x0000000000060400 <bogus+       0>:	0x8766
<bochs:9> xp /1hx 0x60400
[bochs]:
0x0000000000060400 <bogus+       0>:	0x8766
```

内存`0x6000:0x400`和内存`0x60400`中的数据相同，这证明上面的公式是正确的。

在保护模式下，内存地址仍然是”段：偏移量“。不过，”段“是”全局描述符的选择子，而“偏移量”变成了物理地址。仍然不是非常理解这种表示方法。

全局描述符的选择子，表示为：全局描述符的标号 - 第一个全局描述符。

首先，建立全局描述符宏H，这个宏有三个参数，分别是：段基址、段界限、段属性。段属性最难。

然后，用H创建全局描述符。暂时只创建这几个描述符：空描述符、显存描述符。

加载GDT，使用`lgdt [GDTPtr]`。`GdtPtr`是啥？它的结构是：GDT界限 GDT的初始地址。

有一个寄存器，名称是`gdtr`，专门用来存储GDT的物理地址。gdtr的结构如下：

```shell
-----------------------------------------------------------
|			32位基地址													|		16位界限				|
-----------------------------------------------------------
```

#### 好多疑问

1. ```assembly
   ; GDT ------------------------------------------------------------------------------------------------------------------------------------------------------------
   ;                                                段基址            段界限     , 属性
   LABEL_GDT:			Descriptor             0,                    0, 0						; 空描述符
   LABEL_DESC_FLAT_C:		Descriptor             0,              0fffffh, DA_CR  | DA_32 | DA_LIMIT_4K			; 0 ~ 4G
   LABEL_DESC_FLAT_RW:		Descriptor             0,              0fffffh, DA_DRW | DA_32 | DA_LIMIT_4K			; 0 ~ 4G
   LABEL_DESC_VIDEO:		Descriptor	 0B8000h,               0ffffh, DA_DRW                         | DA_DPL3	; 显存首地址
   ; GDT ------------------------------------------------------------------------------------------------------------------------------------------------------------
   ```

   1. 设置了`LABEL_DESC_FLAT_C`、`LABEL_DESC_FLAT_RW` 这两个段基址和段界限相同、属性不同的段。这两个段的数据会互相覆盖吗？数据能共用吗？
   2. 例如，在`LABEL_DESC_FLAT_C:0x2`存储数据`aa`，那么，通过`LABEL_DESC_FLAT_RW:0x2`读取到的数据也是`aa`吗？
   3. 在`LABEL_DESC_FLAT_C:0x2`存储数据`aa`，在`LABEL_DESC_FLAT_RW:0x2`存储数据`bb`，那么，通过`LABEL_DESC_FLAT_C:0x2`和`LABEL_DESC_FLAT_RW:0x2`读取到的数据都是`bb`吗？



#### debug

```assembly
; GDT ------------------------------------------------------------------------------------------------------------------------------------------------------------
;                                                段基址            段界限     , 属性
LABEL_GDT:			Descriptor             0,                    0, 0						; 空描述符
LABEL_DESC_FLAT_C:		Descriptor             0,              0fffffh, DA_CR  | DA_32 | DA_LIMIT_4K			; 0 ~ 4G
LABEL_DESC_FLAT_RW:		Descriptor             0,              0fffffh, DA_DRW | DA_32 | DA_LIMIT_4K			; 0 ~ 4G
LABEL_DESC_VIDEO:		Descriptor	 0B8000h,               0ffffh, DA_DRW                         | DA_DPL3	; 显存首地址
; GDT ------------------------------------------------------------------------------------------------------------------------------------------------------------

GdtLen		equ	$ - LABEL_GDT
GdtPtr		dw	GdtLen - 1				; 段界限
		dd	BaseOfLoaderPhyAddr + LABEL_GDT		; 基地址

; GDT 选择子 ----------------------------------------------------------------------------------
SelectorFlatC		equ	LABEL_DESC_FLAT_C	- LABEL_GDT
SelectorFlatRW		equ	LABEL_DESC_FLAT_RW	- LABEL_GDT
SelectorVideo		equ	LABEL_DESC_VIDEO	- LABEL_GDT + SA_RPL3
; GDT 选择子 ----------------------------------------------------------------------------------

jmp	dword SelectorFlatRW:(BaseOfLoaderPhyAddr+LABEL_PM_START)
```



引发下面的错误：



```shell
<bochs:3> s
00016183765e[CPU0  ] check_cs(0x0010): not a valid code segment !
00016183765e[CPU0  ] interrupt(): gate descriptor is not valid sys seg (vector=0x0d)
00016183765e[CPU0  ] interrupt(): gate descriptor is not valid sys seg (vector=0x08)
00016183765i[CPU0  ] CPU is in protected mode (active)
00016183765i[CPU0  ] CS.mode = 16 bit
00016183765i[CPU0  ] SS.mode = 16 bit
00016183765i[CPU0  ] EFER   = 0x00000000
00016183765i[CPU0  ] | EAX=60000011  EBX=00000007  ECX=00000009  EDX=534d0400
00016183765i[CPU0  ] | ESP=00000100  EBP=000002a7  ESI=000e029d  EDI=0000007a
00016183765i[CPU0  ] | IOPL=0 id vip vif ac vm RF nt of df if tf sf zf af PF cf
00016183765i[CPU0  ] | SEG sltr(index|ti|rpl)     base    limit G D
00016183765i[CPU0  ] |  CS:9000( 0004| 0|  0) 00090000 0000ffff 0 0
00016183765i[CPU0  ] |  DS:9000( 0005| 0|  0) 00090000 0000ffff 0 0
00016183765i[CPU0  ] |  SS:9000( 0005| 0|  0) 00090000 0000ffff 0 0
00016183765i[CPU0  ] |  ES:9000( 0005| 0|  0) 00090000 0000ffff 0 0
00016183765i[CPU0  ] |  FS:0000( 0005| 0|  0) 00000000 0000ffff 0 0
00016183765i[CPU0  ] |  GS:0000( 0005| 0|  0) 00000000 0000ffff 0 0
00016183765i[CPU0  ] | EIP=00000281 (00000281)
00016183765i[CPU0  ] | CR0=0x60000011 CR2=0x00000000
00016183765i[CPU0  ] | CR3=0x00000000 CR4=0x00000000
(0).[16183765] [0x000000090281] 9000:0000000000000281 (unk. ctxt): jmpf 0x0010:00090380      ; 66ea800309001000
00016183765e[CPU0  ] exception(): 3rd (13) exception with no resolution, shutdown status is 00h, resetting
00016183765i[SYS   ] bx_pc_system_c::Reset(HARDWARE) called
00016183765i[CPU0  ] cpu hardware reset
00016183765i[APIC0 ] allocate APIC id=0 (MMIO enabled) to 0x0000fee00000
00016183765i[CPU0  ] CPU[0] is the bootstrap processor
00016183765i[CPU0  ] CPUID[0x00000000]: 00000005 68747541 444d4163 69746e65
00016183765i[CPU0  ] CPUID[0x00000001]: 00000633 00010800 00002028 17cbfbff
00016183765i[CPU0  ] CPUID[0x00000002]: 00000000 00000000 00000000 00000000
00016183765i[CPU0  ] CPUID[0x00000003]: 00000000 00000000 00000000 00000000
00016183765i[CPU0  ] CPUID[0x00000004]: 00000000 00000000 00000000 00000000
00016183765i[CPU0  ] CPUID[0x00000005]: 00000040 00000040 00000003 00000020
00016183765i[CPU0  ] CPUID[0x80000000]: 80000008 68747541 444d4163 69746e65
00016183765i[CPU0  ] CPUID[0x80000001]: 00000633 00000000 00000101 ebd3f3ff
00016183765i[CPU0  ] CPUID[0x80000002]: 20444d41 6c687441 74286e6f 7020296d
00016183765i[CPU0  ] CPUID[0x80000003]: 65636f72 726f7373 00000000 00000000
00016183765i[CPU0  ] CPUID[0x80000004]: 00000000 00000000 00000000 00000000
00016183765i[CPU0  ] CPUID[0x80000005]: 01ff01ff 01ff01ff 40020140 40020140
00016183765i[CPU0  ] CPUID[0x80000006]: 00000000 42004200 02008140 00000000
00016183765i[CPU0  ] CPUID[0x80000007]: 00000000 00000000 00000000 00000000
00016183765i[CPU0  ] CPUID[0x80000008]: 00003028 00000000 00000000 00000000
```

这个错误是段属性造成的。

`jmp	dword SelectorFlatC:(BaseOfLoaderPhyAddr+LABEL_PM_START)` 会把`cs`设置成`SelectorFlatC`的值`0x0010`。例如：

```assembly
; GDT ------------------------------------------------------------------------------------------------------------------------------------------------------------
;                                                段基址            段界限     , 属性
LABEL_GDT:			Descriptor             0,                    0, 0						; 空描述符
LABEL_DESC_FLAT_C:		Descriptor             0,              0fffffh, DA_CR  | DA_32 | DA_LIMIT_4K			; 0 ~ 4G
LABEL_DESC_FLAT_RW:		Descriptor             0,              0fffffh, DA_CR | DA_32 | DA_LIMIT_4K			; 0 ~ 4G
LABEL_DESC_VIDEO:		Descriptor	 0B8000h,               0ffffh, DA_DRW                         | DA_DPL3	; 显存首地址
; GDT ------------------------------------------------------------------------------------------------------------------------------------------------------------

GdtLen		equ	$ - LABEL_GDT
GdtPtr		dw	GdtLen - 1				; 段界限
		dd	BaseOfLoaderPhyAddr + LABEL_GDT		; 基地址

; GDT 选择子 ----------------------------------------------------------------------------------
SelectorFlatC		equ	LABEL_DESC_FLAT_C	- LABEL_GDT
SelectorFlatRW		equ	LABEL_DESC_FLAT_RW	- LABEL_GDT
SelectorVideo		equ	LABEL_DESC_VIDEO	- LABEL_GDT + SA_RPL3
; GDT 选择子 ----------------------------------------------------------------------------------

jmp	dword SelectorFlatRW:(BaseOfLoaderPhyAddr+LABEL_PM_START)
```



```shell
(0) [0x000000090281] 9000:0000000000000281 (unk. ctxt): jmpf 0x0010:00090380      ; 66ea800309001000
<bochs:2> sreg
es:0x9000, dh=0x00009309, dl=0x0000ffff, valid=1
	Data segment, base=0x00090000, limit=0x0000ffff, Read/Write, Accessed
cs:0x9000, dh=0x00009309, dl=0x0000ffff, valid=1
	Data segment, base=0x00090000, limit=0x0000ffff, Read/Write, Accessed
ss:0x9000, dh=0x00009309, dl=0x0000ffff, valid=7
	Data segment, base=0x00090000, limit=0x0000ffff, Read/Write, Accessed
ds:0x9000, dh=0x00009309, dl=0x0000ffff, valid=3
	Data segment, base=0x00090000, limit=0x0000ffff, Read/Write, Accessed
fs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1
tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1
gdtr:base=0x000000000009013d, limit=0x1f
idtr:base=0x0000000000000000, limit=0x3ff
<bochs:3> s
Next at t=16183766
(0) [0x000000090380] 0010:0000000000090380 (unk. ctxt): xchg bx, bx               ; 6687db
<bochs:4> sreg
es:0x9000, dh=0x00009309, dl=0x0000ffff, valid=1
	Data segment, base=0x00090000, limit=0x0000ffff, Read/Write, Accessed
cs:0x0010, dh=0x00cf9b00, dl=0x0000ffff, valid=1
	Code segment, base=0x00000000, limit=0xffffffff, Execute/Read, Non-Conforming, Accessed, 32-bit
ss:0x9000, dh=0x00009309, dl=0x0000ffff, valid=7
	Data segment, base=0x00090000, limit=0x0000ffff, Read/Write, Accessed
ds:0x9000, dh=0x00009309, dl=0x0000ffff, valid=3
	Data segment, base=0x00090000, limit=0x0000ffff, Read/Write, Accessed
fs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1
tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1
gdtr:base=0x000000000009013d, limit=0x1f
idtr:base=0x0000000000000000, limit=0x3ff
```

在bochs中查看内存中的数据，仍然使用“段地址：偏移量”，例如：`xp /1wx 0x0010:0x90380`，bochs会自动计算出事件内存地址并且打印出该内存中的数据。在实模式下，我还能手工直接算出内存的实际地址，在保护模式下，计算实际内存地址很麻烦。

纠正上面的说法，只是从选择子计算对应的段基址比较麻烦，实际内存地址（线性地址）的计算方法仍然是：段基址 + 偏移量。下面的断点调试结果能够验证这个结论。

```shell
<bochs:18> xp /1wx 0x8:0x90380
[bochs]:
0x0000000000090380 <bogus+       0>:	0x66db8766
<bochs:19> xp /1wx 0x90380
[bochs]:
0x0000000000090380 <bogus+       0>:	0x66db8766
```

当前语境中，`0x8`对应的段的段基址是0。

若是如此，我有很充分的理由相信：不同的段，段基址相同，段偏移量相同，那么，这两个段的内存空间是重合的。

```shell
<bochs:6> xp /1wx 0x0008:0x00000000000905da
[bochs]:
0x00000000000905da <bogus+       0>:	0x00c3d975
<bochs:7> xp /1wx 0x00000000000905da
[bochs]:
0x00000000000905da <bogus+       0>:	0x00c3d975
<bochs:8> xp /1wx 0x0010:0x00000000000905da
[bochs]:
0x00000000000905da <bogus+       0>:	0x00c3d975
<bochs:9> 
```

上面的断点数据，又证明了不同的段（段基址、段界限）使用的相同的内存空间。那么，有啥必要弄两个基本相同、只是属性不同的段？

内存访问为啥要分段访问？

1. 为了重定位。以前，程序中使用内存的物理地址，要同时运行多个程序非常麻烦（需要在程序中写死它所使用的内存，还要保证这片内存不被其他程序改写）。
2. 为了访问所有内存。以前，能访问的内存很小，要访问全部内存，只能将内存划分为段基址不同的若干个段，然后通过在不同的段之间跳转来访问所有的内存。
3. 后来，能够用一个段访问全部内存空间，为啥还是要分段访问内存？



#### 段描述符的属性

详情见《操作系统真相还原》4.3.1节。

在这个问题上耗费了40多分钟，原因是：两本书上的说明不一致。

《操作系统真相还原》

![image-20210223152935498](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210223152935498.png)



《X86汇编语言：从实模式到保护模式》

![image-20210223153134430](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210223153134430.png)

《一个操作系统的实现》

![image-20210223153212938](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210223153212938.png)

三本书都没有错。第一本书和后面两本书对应不上，是因为第一本书没有按照第0位到第3位的顺序排列。

对代码段来说，按照从第0位到第3位的顺序排列，依次是：X、C、R、A。用下面的实例来理解：

1. Ch。12 = 8 + 4。1100。X:1，C:1。可执行、一致代码段。
2. Ah。10 = 8 + 2。1010。X:1,C:0,R:1。可执行、可读。
3. Bh。11 = 8 + 3。1011。X：1，C：0，R：1，A：1。可执行、可读、已访问。

TYPE和S结合起来才有意义。S为0时，表示系统段；S为1时，表示数据段（又叫非系统段）。

在第一张图中，非系统段又分为代码段和数据段。怎么区分二者呢？看X位是多少。X是1，代码段。X是0，数据段。代码段可执行，数据段不可执行。只用一位，自然不能同时表示这个段可执行、又不可执行。这或许就是于上神要对0~~4GB这片内存创建两个段描述符的原因吧。感觉这个解释仍然不是很让我信得过。

数据段一定是可读的，一定是不可执行的。

代码段一定是不可写的，一定是可执行的。

创建段描述符的宏的第三个参数，段属性，写成多个值组成的比较好。段属性的构成要素是：TYPE、S、DPL、P、AVL、L、D/B、G。我觉得，直接把所有的要素都写到参数中更好，直观。如果只写出一个结果，例如'Ch'，可读性太差，还需要计算。

目前，可执行段、可读写段、视频段：

1. 都是非系统段，S为1。
2. DPL
   1. 可执行段、可读写段，设置为0。
   2. 视频段，设置为：3。必须为3，经过运行，确实如此。原因未知。
3. P，设置为0。
4. AVL，设置为0。
5. L，设置为0。
6. D/B，设置为1。
7. G，设置为1。
8. TYPE
   1. 可执行段，设置为：X：1，C：1，R：0，A：0。Ah。
   2. 可读写段，设置为：X：0，E：0，W：1，A：0。2h。
   3. 视频段，设置为：X：0，E：0，W：1，A：0。2h。

一直深感恐惧的段描述符及其属性，在这个阶段，只需要简单设置就行了。

#### 别人的代码流程

1. FAT12文件头。

2. 用宏创建三个段描述符。

   1. 可执行段。
   2. 可读写段。
   3. 视频段。

3. 创建GdtPtr。它存储GDT的物理地址。GDT的物理地址就是GDT中的第一个元素的地址。

   1. 本结构由48个bit组成。低16位是界限，高32位是基地址。
   2. 基地址是GDT中的第一个元素的物理地址。
   3. 界限是GDT的最后一个字节的地址，等于GDT的长度-1，因为，计算从0开始。例如，长度是3，从0开始计数，最后一个地址是2。
   4. CPU提供了专门存储GDT物理地址的寄存器，`lgdt`。加载GDT物理地址到`lgdt`的语法：`lgdt [GdtPtr]`。

4. 创建段选择子。

   1. 很容易。用目标描述符的标号-第一个描述符的标号。
   2. 选择子的结构：第0~2位是RPL，第3位是T1，第4~15位是描述符索引（GDT中的偏移量，第几个描述符）。
   3. T1是0，表示这个选择子是在GDT中索引段描述符；T1是1，表示这个选择子是在LDT中索引段描述符。
   4. 为什么要创建选择子？在保护模式下，段地址：偏移量的寻址方式中，段地址是段的选择子。创建选择子，是保护模式下内存寻址的需要。

5. 进入保护模式。

   1. 上面准备好GDT和GDT的物理地址后，下面开启保护模式。

   2. 关中断，`cli`。在进入保护模式的过程中，CPU处理中断的机制发生改变，若接收到中断（实模式下的中断协议）会发生错误。我的猜想：跳入32位代码之前，中断机制就在某个步骤发生了改变。

   3. 打开A20。

      1. 就是往一个端口写入数据，使用`in`、`out`指令。

      2. 哪个端口？92h。把端口92h的第2位设置为1。

      3. 代码：

         1. ```assembly
            ; 把端口92h中的数据读入al
            in al, 92h
            ; 把al中的数据的第2位设置为1
            or al, 10h
            ; 把修改过后的al中的数据写到端口92h中
            out 92h, al
            ```

         2. `in`、`out`两个指令的操作数的顺序，很容易混淆。这样记忆吧，这两个指令等同于`mov`，第一个参数都是数据的目标位置。

   4. 设置cr0的PE位（cr0的第0位）为1。

      1. PE是0时，CPU处于实模式；PE是1时，CPU处于保护模式。

      2. 代码：

         1. ```assembly
            mov eax, cr0
            or eax, 1
            mov cr0, eax
            ```

         2. 为啥能直接用eax？不是还没有进入保护模式吗？我的猜想：打开了A20，就已经能使用大于20位的数据线了。

         3. 还不清楚A20的工作机制。

   5. 把GDT的物理地址加载到`lgdt`，`lgdt [GdtPtr]`。

   6. 跳转到32位代码。注意，这个跳转需要指定数据类型（？这个说法准确吗），`jmp dword`。

   7. 上面的步骤能改变顺序吗？

6. 进入保护模式后，cs被`jmp`设置成了可执行代码段，然后，显式设置ds、es、fs、ss的值为可读可写代码段选择子，设置gs的值是视频段的选择子。

7. 在内存中重新放置内核。

8. 跳转到内核的第一个程序段的入口。

### 写内核

怎么写内核？我也忘记了。

编译时，设置对应选项，编译成elf文件。

内核代码，忘记了。

```assembly
; kernel.asm
[section .text]

global	_start

_start:
	mov ah, 0Fh
	mov al, 'K'
	mov gs, 0xB800
	mov [gs:(80*1+39)*2], ax
	
	jmp $
```

编译：

```shell
nasm -f elf kernel.asm -o kernel.o
ld -s kernel.o -o kernel.bin -m elf_i386
```



非常神奇。elf文件能像DOS文件一样被读入内存，然后跳转到这块内存执行指令。若是如此，就没有必要使用elf文件了。

elf文件的必要性是什么？