# 写操作系统的笔记

## 写loader

loader要完成的工作：准备好GDT、进入保护模式、读取内核文件到内存、将内核重新放置到内存中。

实模式下，能使用的最大内存是1M。地址总线是20位，能接收并寻址的最大内存地址是2的20次方-1，内存地址的初始地址是0，所以，能使用的最大内存是1M。

能不能在“准备好GDT、进入保护模式”前完成下面两项工作？

1. 读取内核文件到内存。
2. 将内核重新放置到内存中。

在测试阶段，可以，把内核写得很小就行。实际中，不行。内核所需要的空间必定会大于1M。

于上神在实模式下读取内核文件到内存中。为啥不在进入保护模式后再做这件事情？

没有找到答案，先在进入保护模式前把内核文件读取到内存吧。

怎么把内核文件读取到内存？我可以直接去看“读取loader到内存”的代码。写过的代码，也会忘记。我想先回忆，怎么把内核文件读取到内存。

读取到哪块内存？要确定存储内核文件的内存的初始位置。

用什么方法读取？用bios的系统调用（已经忘记）读取。

### 从软盘中读取数据

从哪里读取？从软盘中读取。（已经忘记了怎么从软盘中读取）。

1. 在FAT12的根目录区通过对比文件名找到目标文件对应的根目录项。
2. 从根目录项中获取目标文件在FAT中的第一个FAT项的编号（初始编号是2）。
3. 目标文件的第一个FAT项的编号的值是第二个FAT项的编号，第二个FAT项的编号是第三个FAT项的编号，剩余的FAT项的编号按照相同的方法查找。FAT项的编号，既是下一个FAT项的编号，又是目标文件在数据区的扇区号。这实质是一个单链表。
   1. FAT项的值，有的表示当前FAT项是最后一个FAT项，有的表示当前FAT项对应的簇是坏簇。具体数值，我忘记了。
4. 每个FAT项占用12位，所以，一个FAT项可能跨越扇区。为了完整获取每个FAT项，需要读取两个扇区。3个字节刚好存储2个FAT项。又忘记了那个计算公式。
5. 两个公式：
   1. 根据扇区在软盘中的扇区号，计算出扇区在软盘中的柱面号、磁头号、在X柱面X磁头的扇区号。
   2. 根据FAT项编号，计算出这个FAT项在软盘中的扇区号。
      1. 一个FAT项占用8个bit，即1.5个字节。FAT项的编号从0开始，若FAT项的编号是X，那么，这个FAT项的偏移量是X个FAT项（0~~~X-1），一共是多少个字节？X * 1.5个字节。在汇编中，X * 1.5 的等价运算是，X * 3，然后，X / 2。
      2. 结果若无余数，刚好占用整数个字节N。结果若有余数，占用整数个字节N + 0.5个字节。
      3. 无论结果是哪种，偏移量都是N个字节，因为，内存寻址的最小单位是字节，而不是其他的（比如BIT）。
      4. 无余数，偏移量就是N个字节。目标FAT项是12个bit，8 bit + 4 bit，从N-1开始，读取1个字节，再读取4个bit。
      5. 有余数，偏移量是N个字节。目标FAT项是12个bit，8 bit + 4 bit。
      6. 在4、5两个步骤想了很久，心算画图都没能解决问题。看代码后，理解了。从N字节（包括）开始，读取2个字节。
         1. 无余数，取两个字节16个bit的低12位。
         2. 有余数，取两个字节16个bit的高12位。因为，低四位属于前一个FAT项。

把数据写入内存，使用的仍然是系统调用（bios还是DOS？），能指定内存位置。

把内核文件写入内存后，再从内存中，把程序头（是这个术语吗）复制到另外的内存位置P，然后将cs:ip指向P，就能将控制权交给内核。

在控制权交给内核前，需要先初始化好GDT、进入保护模式吗？

在内核中，会使用1M之外的内存，因此，需要进入保护模式。在保护模式下，内存寻址需要GDT，因此，需要初始化GDT。

但是，也可以不在内核中使用1M之外的内存吧？

### 重新放置内核到内存

一个星期前，写过这个知识点的文章，此刻，又忘记了。

内核文件，是ELF文件。读取内核到内存，就是把ELF文件的所有程序段读取到指定的内存位置。

ELF文件的构成要素：ELF头，sections(节)，节头表，程序头表。

唉！忘记了，全忘记了！

学习很艰难，或者说，记忆很艰难。我十天前一个字一个字写出的文章，再看，很陌生，好像看不懂了。

使用函数 `memcpy(程序段在内存中的虚拟地址，程序段在内存中的地址，程序段的长度)` 实现功能。复制操作会重复进行，重复次数由程序段的个数决定。

从elf头中能获取由多少个程序段。从程序头中能获取`memcpy`的三个参数。

有几个疑问：

1. 为什么重新放置内核的目标地址是虚拟内存地址？
   1. 不清楚。搁置。后面再看。
2. 虚拟内存地址是什么？
   1. 逻辑地址。段地址：偏移量。
   2. 线性地址。实模式下，段地址*16+偏移量。保护模式下，选择子-->全局描述符-->段基址+偏移量。
   3. 物理地址。没有开启页机制，线性地址就是物理地址。
   4. 虚拟地址。是上面的哪个地址？不是任何一个。涉及到MMU等，在目前的书和代码中，没有提到这个东西，先搁置吧。

#### 实现memcpy

```assembly
; Mempcy(程序段的虚拟内存地址，程序段在内存中的地址，程序段的长度)
; 逐字节复制
; [es:di]--->[ds:si]
Memcpy:
	push ax
	push cx
	push bp
	mov bp, sp
	; 三个参数
	mov cx, [bp+16]
	mov di, [bp+12]
	mov si, [bp+8]
	
.1:
	cmp cx, 0
	jmp .2
	mov al, [ds:si]
	mov [es:di], al
	inc di
	inc si
	dec cx
	jmp .1
	
.2
	mov ax, [bp+8]
	
	pop bp
	pop cx
	pop ax
	
	
	ret
```



很不熟练。大概需要20分钟才能写得出来这个函数。

疑问。函数堆栈中的第一个元素、第二个元素，分别是什么？

![image-20210218173229879](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210218173229879.png)

call的作用是把eip入栈。



![image-20210218173248737](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210218173248737.png)



ret的作用是把参数和eip出栈。



![image-20210218173326540](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210218173326540.png)



长调用，call把cs、eip入栈。

长调用是不同段间的调用。

我不愿先开启保护模式再重新放置内核，是因为我不想写GDT那块代码，更具体地说，我不想写特权级那块的代码。

特权级，我还没有弄明白是咋回事。RPL、CPL、DPL，很烦。

进入保护模式之后，才重新放置内核到内存中。为何如此？因为，在内核中，需要使用1M之上的内存。

#### 开启保护模式

很简单，套路。打开A20，设置cr0。一个跳转。

#### 初始化GDT

这很难。最难的是，设置全局描述符的属性。

需要几个段？至少三个。

第一个：代码段。

第二个：数据段。

第三个：视频段。

上面是我的设想。看看于上神怎么做的。

### v1-loader

第一版v1。实现一个功能：把内核文件读取到内存中。模仿于上神的方法，复制一个新文件夹。

大部分内容与boot一样，从软盘中读取名为“kernel.bin"的文件，并且放置到内存位置为A的那片内存。

我打算直接复制boot.asm的代码。重新写一次，很耗费时间，调试更加耗费时间。这个知识，并不常用。

但是，可以复述一下读取数据到内存的过程。

使用bios的系统调用读取数据。这个系统调用需要一些参数，柱面号、磁头号、偏移扇区号，读取到哪里。

#### 用扇区号计算bios系统调用的参数

根据扇区号，能计算出所需要的参数。扇区号又能从软盘的头信息中获取。

扇区号除以每磁道包含的扇区数，商是磁道数，余数是在X柱面X磁头的扇区偏移量，扇区号是余数+1。

磁道数除以每个柱面包含的磁道的数量，商是柱面号，余数没有作用。

磁道数 & 1，结果是磁头号。（这个公式，理解起来，仍然有点费劲）

这个计算方法的前提是，每个柱面包含2个磁道，有两个磁头。

#### 用FAT编号计算扇区号

1. 使用FAT编号计算出字节偏移量O、整数字节偏移量ON。
   1. O是整数，O等于ON，字节O、字节O+1两个字节的低12位是当前FAT项。
   2. O不是整数，字节ON、字节ON+1两个字节的高12位是当前FAT项。因为低4位上一个FAT项的高4位。
2. 判断FAT编号为N的FAT项的字节偏移量是不是整数字节的方法：
   1. N * 3 / 2
   2. 检查上一步的余数是不是0
      1. 是0，整数。
      2. 不是0，非整数。
   3. 原理：一个FAT项占用1.5个字节，编号为N的FAT项的字节偏移量是N * 1.5。上面的计算公式是N * 1.5的等价运算。

怎么写loader？完全没有思路。只能参考于神的代码。

没有section，开头必须是`org 0x100`。

#### debug1

读取内核文件的时候，获取到的第一个FAT项的编号是0。这是不正确的。

我试图验证，是读取kernel文件时出错了吗？

已知di，如何查看某个段内的数据？用bochs。

````shell
xp /1wx 0x800:0x100

xp /1wx 0x800:0x120
xp /1wx 0x800:0x140
xp /1wx 0x800:0x160
xp /1wx 0x800:0x180

xp /1wx 0x800:0x19a

<bochs:16> r
CPU0:
rax: 00000000_0000004c
rbx: 00000000_00000b90
rcx: 00000000_0009000b
rdx: 00000000_00000000
rsp: 00000000_0000ffd4
rbp: 00000000_00000000
rsi: 00000000_000e7d07
rdi: 00000000_00000100
r8 : 00000000_00000000
r9 : 00000000_00000000
r10: 00000000_00000000
r11: 00000000_00000000
r12: 00000000_00000000
r13: 00000000_00000000
r14: 00000000_00000000
r15: 00000000_00000000
rip: 00000000_00007c78


xp /1wx 0x800:0x17a

xp /1bx 0x0:0xe7d06


# si 的值虽然是 00000000_000e7d07，但是，lodsb 的等价运算 lodsb al, byte ptr ds:[si] 中的 si 的值应该是 0x7d06 而不是 0xe7d06。原因未知，这是运行代码得到的结果。

xp /1bx 0x0:0x7d06

xp /1bx 0x9000:0xe7d06


xxd -u -a -g 1 -c 16 -s +9728 -l 1024 a.img
````

### v2-loader

#### 重新放置内核

在实模式下，`0x80000`是能够被使用的内存地址。`0x80000`是32KB，在1MB之内。

elf格式的内核文件的开头是elf头。从elf头中，能获取：

1. 程序头的个数。
2. 程序头表在内核文件中的偏移量。

内核文件的物理位置，加上程序头表在内核文件中的偏移量，等于程序头表的位置。在第一个程序头中，能获取这个程序头对应的程序段的虚拟内存地址、目标程序段在文件中的偏移量、目标程序段的长度。

怎么从elf头和程序头中获取数据呢？根据元素的数据类型。假如，在elf头中，程序头的个数是第三个元素，前两个元素的数据类型都占用4个字节，那么，程序头的个数从第8个字节开始。具体数字，我忘记了。

#### Memcpy

按字节复制，第三个参数是多少，就循环多少次。每次循环，把数据从第二个参数内存位置复制到第一个参数内存位置。

使用什么完成的复制？用al做中间变量。在[es:di]和[ds:si]之间复制。es和ds的值，需要注意。

这个函数有返回值。返回值是第一个参数内存位置，把它放在ax中返回。

循环，仍然不使用loop，而是使用cx手工完成。

调用函数时，`call Memcpy`，需要对`sp`进行操作吗？是增还是减？数量呢？

`sub sp, 4`。使用减。是必须的。原因是，不能影响与函数调用无关的栈。

~~例如，函数参数入栈前，sp的位置是16，`sub sp,4`后，sp的位置是12，入栈一个参数后，sp的位置是10。位置10到位置0的数据不会覆盖位置16。这段解说是错误的。~~

只需要在调用结束后，对sp进行加操作，释放参数占用的栈空间。

可以用 `/home/cg/yuyuan-os/osfs09/f` 中的文件分析elf、FAT12系统。

#### 分析elf

```shell
[root@localhost v2]# xxd -u -a -g 1 -c 16  kernel.bin
00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010: 02 00 03 00 01 00 00 00 00 04 03 00 34 00 00 00  ............4...
00000020: 18 04 00 00 00 00 00 00 34 00 20 00 01 00 28 00  ........4. ...(.
00000030: 03 00 02 00 01 00 00 00 00 00 00 00 00 00 03 00  ................
00000040: 00 00 03 00 06 04 00 00 06 04 00 00 05 00 00 00  ................
00000050: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
*
00000400: EB FE EB FE EB FE 00 2E 73 68 73 74 72 74 61 62  ........shstrtab
00000410: 00 2E 74 65 78 74 00 00 00 00 00 00 00 00 00 00  ..text..........
00000420: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000430: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000440: 0B 00 00 00 01 00 00 00 06 00 00 00 00 04 03 00  ................
00000450: 00 04 00 00 06 00 00 00 00 00 00 00 00 00 00 00  ................
00000460: 10 00 00 00 00 00 00 00 01 00 00 00 03 00 00 00  ................
00000470: 00 00 00 00 00 00 00 00 06 04 00 00 11 00 00 00  ................
00000480: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00  ................
```



```shell
00000040: 00 00 03 00 06 04 00 00 06 04 00 00 05 00 00 00  ................
```



```shell
00000400: EB FE EB FE EB FE 00 2E 73 68 73 74 72 74 61 62  ........shstrtab
```



`EB FE EB FE EB FE`是下面代码的机器码，总计6个字节，与`00000040: 00 00 03 00 06 04 00 00 06 04 00 00 05 00 00 00  ................`中的`06`吻合。

```assembly
[section .text]

global _start

_start:
;       mov ax, 0xB800
        jmp $
        jmp $
        jmp $
;       mov gs, ax
;       mov ah, 0Fh
;       mov al, 'C'
;       mov [gs:(80 * 20 + 40) * 2], ax
;       jmp $
```



仅存的疑问：

```assembly
; InitKernel ---------------------------------------------------------------------------------
; 将 KERNEL.BIN 的内容经过整理对齐后放到新的位置
; 遍历每一个 Program Header，根据 Program Header 中的信息来确定把什么放进内存，放到什么位置，以及放多少。
; --------------------------------------------------------------------------------------------
InitKernel:
        xor   esi, esi
        mov   cx, word [BaseOfKernelFilePhyAddr+2Ch];`. ecx <- pELFHdr->e_phnum
        movzx ecx, cx                               ;/
        mov   esi, [BaseOfKernelFilePhyAddr + 1Ch]  ; esi <- pELFHdr->e_phoff
        add   esi, BaseOfKernelFilePhyAddr;esi<-OffsetOfKernel+pELFHdr->e_phoff
.Begin:
        mov   eax, [esi + 0]
        cmp   eax, 0                      ; PT_NULL
        jz    .NoAction
        push  dword [esi + 010h]    ;size ;`.
        mov   eax, [esi + 04h]            ; |
        add   eax, BaseOfKernelFilePhyAddr; | memcpy((void*)(pPHdr->p_vaddr),
        push  eax		    ;src  ; |      uchCode + pPHdr->p_offset,
        push  dword [esi + 08h]     ;dst  ; |      pPHdr->p_filesz;
        call  MemCpy                      ; |
        add   esp, 12                     ;/
.NoAction:
        add   esi, 020h                   ; esi += pELFHdr->e_phentsize
        dec   ecx
        jnz   .Begin

        ret
```



```assembly
mov   eax, [esi + 04h]            ; |
add   eax, BaseOfKernelFilePhyAddr; | memcpy((void*)(pPHdr->p_vaddr),
```



`BaseOfKernelFilePhyAddr`是文件开头，内容是：`00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............`。

可是，我猜想，重新放置内核，需要复制的内容是：`00000400: EB FE EB FE EB FE 00 2E 73 68 73 74 72 74 61 62  ........shstrtab`。没有找到能达到这个目的的代码。

#### 小结

今天，又耗费了一天，没有完成“重新放置内存”。

1. 直接读取elf文件到内存中，就像处理DOS文件一样，跳转到elf文件，就能执行。那么，就没有必要使用elf了。
2. 理解不了于上神重新放置内存的代码，具体说，源代码的位置，理解不了。
3. 直接操作显存，显存数值的列与行坐标，都不能超过最大值，否则，数据不会在屏幕上显示。
4. 解析elf文件、fat12系统，一定要分析一个实例，并且把分析过程准确记录下来。若心算太慢，就用笔算。
5. 不能读取全部指令，那么，这些指令一条也不会被执行。



为啥进展这么慢？时间跨度长达一天，我不记得准确细节了。遇到棘手的问题，立刻用写作来辅助思路，不要心算。

#### debug

```shell
prefetch: EIP [00010000] > CS.limit [0000ffff]
```

.COM文件的大小为什么不能超过64KB？

在实模式下跳转

```shell
loader.asm:192: warning: word data exceeds bounds [-w+number-overflow]
loader.asm:192: warning: word data exceeds bounds [-w+number-overflow]
```



```shell
<bochs:2> sreg
es:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
cs:0xf000, dh=0xff0093ff, dl=0x0000ffff, valid=7
	Data segment, base=0xffff0000, limit=0x0000ffff, Read/Write, Accessed
ss:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
ds:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
fs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1
tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1
gdtr:base=0x0000000000000000, limit=0xffff
idtr:base=0x0000000000000000, limit=0xffff
```



#### 实例分析elf文件一

```assembly
[section .text]
STR:    db      "Hello"
LEN     equ     $-STR

global _start

_start:
        jmp $
        mov eax, 4

        mov ebx, 1
        mov ecx, STR
        mov edx, LEN
        int 0x80
        mov eax, 1
        mov ebx, 0
        int 0x80
```



用下面的命令编译这个文件

```shell
[root@localhost v2]# nasm -f elf -o kernel.o kernel.asm
# 在 64 位 centos 上编译32位汇编代码，需要使用 -m elf_i386
[root@localhost v2]# ld -s -o kernel kernel.o -m elf_i386
```

查看编译出来的文件kernel的二进制数据

```shell
[root@localhost v2]# xxd -u -a -g 1 -c 16 kernel
00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010: 02 00 03 00 01 00 00 00 65 80 04 08 34 00 00 00  ........e...4...
00000020: 98 00 00 00 00 00 00 00 34 00 20 00 01 00 28 00  ........4. ...(.
00000030: 03 00 02 00 01 00 00 00 00 00 00 00 00 80 04 08  ................
00000040: 00 80 04 08 87 00 00 00 87 00 00 00 05 00 00 00  ................
00000050: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 48 65 6C 6C 6F B8 04 00 00 00 BB 01 00 00 00 B9  Hello...........
00000070: 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00 00 00  `...............
00000080: BB 00 00 00 00 CD 80 00 2E 73 68 73 74 72 74 61  .........shstrta
00000090: 62 00 2E 74 65 78 74 00 00 00 00 00 00 00 00 00  b..text.........
000000a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000c0: 0B 00 00 00 01 00 00 00 06 00 00 00 60 80 04 08  ............`...
000000d0: 60 00 00 00 27 00 00 00 00 00 00 00 00 00 00 00  `...'...........
000000e0: 10 00 00 00 00 00 00 00 01 00 00 00 03 00 00 00  ................
000000f0: 00 00 00 00 00 00 00 00 87 00 00 00 11 00 00 00  ................
00000100: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00  ................
```



第一个程序头

![image-20210221140113344](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210221140113344.png)

第一个程序段在文件中的偏移量

![image-20210221140214796](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210221140214796.png)

第一个程序段的虚拟内存地址`08048000`。

![image-20210221140427497](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210221140427497.png)

第一个程序段的长度：0087H

![image-20210221140533376](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210221140533376.png)

第一个程序段的内容：

![image-20210221140658787](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210221140658787.png)

程序的入口：`08048065`。

![image-20210221143530667](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/image-20210221143530667.png)

第一个程序段被复制到的虚拟内存地址是`08048000h`，程序的入口也是一个虚拟内存地址：`08048065h`。可见，前面的`65h`个字节不是指令，换句话说，从第`66h`个字节开始，才是指令数据。这段数据有多长呢？第一个程序段的长度是`0087H`，所以，第一个程序段的数据是：

```shell
[root@localhost v2]# xxd -u -a -g 1 -c 16 kernel
00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010: 02 00 03 00 01 00 00 00 65 80 04 08 34 00 00 00  ........e...4...
00000020: 9C 00 00 00 00 00 00 00 34 00 20 00 01 00 28 00  ........4. ...(.
00000030: 03 00 02 00 01 00 00 00 00 00 00 00 00 80 04 08  ................
00000040: 00 80 04 08 89 00 00 00 89 00 00 00 05 00 00 00  ................
00000050: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 48 65 6C 6C 6F EB FE B8 04 00 00 00 BB 01 00 00  Hello...........
00000070: 00 B9 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00  ..`.............
00000080: 00 00 BB 00 00 00 00
```

第一个程序段的指令数据的开始位置是距离文件偏移量为`65h`个字节的位置，即

```shell
00000060: 48 65 6C 6C 6F EB FE B8 04 00 00 00 BB 01 00 00  Hello...........
00000070: 00 B9 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00  ..`.............
00000080: 00 00 BB 00 00 00 00
```

把指令数据单独截取出来，是

```shell
# ----------------- 表示非指令数据
00000060: ----------------- EB FE B8 04 00 00 00 BB 01 00 00  Hello...........
00000070: 00 B9 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00  ..`.............
00000080: 00 00 BB 00 00 00 00
```

`jmp $`的二进制代码是`EB FE`，吻合。再验证一次。

将源代码修改为：

```assembly
[section .text]
STR:    db      "Hello"
LEN     equ     $-STR

global _start

_start:
        jmp $
        mov eax, 4

        mov ebx, 1
        mov ecx, STR
        mov edx, LEN
        int 0x80
        mov eax, 1
        mov ebx, 0
        int 0x80
        jmp $
```



```shell
[root@localhost v2]# xxd -u -a -g 1 -c 16 kernel
00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010: 02 00 03 00 01 00 00 00 65 80 04 08 34 00 00 00  ........e...4...
00000020: 9C 00 00 00 00 00 00 00 34 00 20 00 01 00 28 00  ........4. ...(.
00000030: 03 00 02 00 01 00 00 00 00 00 00 00 00 80 04 08  ................
00000040: 00 80 04 08 8B 00 00 00 8B 00 00 00 05 00 00 00  ................
00000050: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 48 65 6C 6C 6F EB FE B8 04 00 00 00 BB 01 00 00  Hello...........
00000070: 00 B9 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00  ..`.............
00000080: 00 00 BB 00 00 00 00 CD 80 EB FE 00 2E 73 68 73  .............shs
00000090: 74 72 74 61 62 00 2E 74 65 78 74 00 00 00 00 00  trtab..text.....
000000a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000c0: 00 00 00 00 0B 00 00 00 01 00 00 00 06 00 00 00  ................
000000d0: 60 80 04 08 60 00 00 00 2B 00 00 00 00 00 00 00  `...`...+.......
000000e0: 00 00 00 00 10 00 00 00 00 00 00 00 01 00 00 00  ................
000000f0: 03 00 00 00 00 00 00 00 00 00 00 00 8B 00 00 00  ................
00000100: 11 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00  ................
00000110: 00 00 00 00
```



程序入口虚拟内存地址：`65 80 04 08`，`08048065h`。它在文件中的偏移量是24个字节。

第一个程序段的长度是：`8B 00 00 00`，`8Bh`。它在程序头中的偏移量是`10h`个字节。二进制数据如下：

```shell
00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010: 02 00 03 00 01 00 00 00 65 80 04 08 34 00 00 00  ........e...4...
00000020: 9C 00 00 00 00 00 00 00 34 00 20 00 01 00 28 00  ........4. ...(.
00000030: 03 00 02 00 01 00 00 00 00 00 00 00 00 80 04 08  ................
00000040: 00 80 04 08 8B 00 00 00 8B 00 00 00 05 00 00 00  ................
00000050: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 48 65 6C 6C 6F EB FE B8 04 00 00 00 BB 01 00 00  Hello...........
00000070: 00 B9 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00  ..`.............
00000080: 00 00 BB 00 00 00 00 CD 80 EB FE
```

第一个程序段的虚拟内存地址是：`00 80 04 08`，`08048000h`。它在程序头中的偏移量是`08h`个字节。

上面二进制数据中的行号如`00000010`是十六进制数，是数据在文件中的位置编号（内存地址是内存中的位置编号）。把这些数据复制到内存中后，如果能查看内存中的数据，这些数据的内存地址的编号的相对位置（偏移量）和它们在文件中的相对位置相同。如果把这个程序段复制到内存地址为`08048000h`初始位置的一段内存，那么，在内存中，二进制数据如下：

```shell
08048000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
08048010: 02 00 03 00 01 00 00 00 65 80 04 08 34 00 00 00  ........e...4...
08048020: 9C 00 00 00 00 00 00 00 34 00 20 00 01 00 28 00  ........4. ...(.
08048030: 03 00 02 00 01 00 00 00 00 00 00 00 00 80 04 08  ................
08048040: 00 80 04 08 8B 00 00 00 8B 00 00 00 05 00 00 00  ................
08048050: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
08048060: 48 65 6C 6C 6F EB FE B8 04 00 00 00 BB 01 00 00  Hello...........
08048070: 00 B9 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00  ..`.............
08048080: 00 00 BB 00 00 00 00 CD 80 EB FE
```

二进制数据的入口地址是`08048065h`，很容易得到下面的结论。

指令二进制数据如下：

```shell
00000060: ----------- EB FE B8 04 00 00 00 BB 01 00 00  Hello...........
00000070: 00 B9 60 80 04 08 BA 05 00 00 00 CD 80 B8 01 00  ..`.............
00000080: 00 00 BB 00 00 00 00 CD 80 EB FE
```

开头和结尾都是`EB FE`，源代码的开头和结尾也都是`jmp $`，吻合。

#### 疑难杂症

1. .COM文件的大小为啥不能超过64KB？
2. 在loader中跳转到kernel，跳转目标是随意设定的，但仍然能执行kernel中的指令，这是为什么？kernel是elf文件、DOS文件都是如此。
3. 内核有必要编译成ELF文件吗？
4. 由于可随意指定跳转的目标地址，所以，无法验证重新放置内核是否正确。怎么验证重新放置内核是否正确？



昨天就被这个问题阻碍了，一直没有明确问题，而是在分析ELF文件等。没有详细记录，总之，时间被不明不白地消耗掉了。



```shell
prefetch: EIP [00010000] > CS.limit [0000ffff]
```

哪条语句导致这个问题？

没有`jmp $`会导致这句。	

一个重要的猜想：cpu执行机器指令时，若当前指令是合法指令，就执行；若是不能识别的指令，就跳过继续执行下一条指令。

基于这个猜想，上面的第2个问题，就能解释清楚了。无论kernel是ELF文件还是DOS文件或其他文件，将IP指向这个文件，遇到了文件中的合法指令，就会执行。因此，我能看到执行效果。

既然如此，似乎没有必要在内存中重新放置ELF文件啊，把它们全部复制到内存中，然后逐条执行不也可以吗？的确是可以，我能想到的弊端除了“耗费内存、耗费CPU”外，再也想不到其他需要ELF的必要性了。

我已经验证了上面的猜想。验证方法是：

1. 用两条`jmp $`作为kernel的结尾。第2条kernel的偏移量是`73h`。那么，跳过所有指令的地址相对于第一个段的开头的偏移量是`75h`。

2. 将跳转目标设置为：`jmp BaseOfKernel:75h`。执行结果，没有打印字符，重复出现`prefetch: EIP [00010000] > CS.limit [0000ffff]`。

3. 将跳转目标设置为：`jmp BaseOfKernel:73h`。没有打印字符，也没有重复出现`prefetch: EIP [00010000] > CS.limit [0000ffff]`。这是执行了`jmp $`的原因。

4. 将跳转目标设置为：`jmp BaseOfKernel:61h`。执行结果，打印出了字符。

   1. ip应该指向程序的入口地址，据此，跳转目标应该如此设置：`jmp BaseOfKernel:60h`。可是执行结果却有多远的闪烁字符。

      1. ```shell
         ext at t=14396751
         (0) [0x000000080060] 8000:0060 (unk. ctxt): mov eax, 0xe88eb800       ; 66b800b88ee8
         ```

      2. ```
         <bochs:3> s
         Next at t=14396751
         (0) [0x000000080061] 8000:0061 (unk. ctxt): mov ax, 0xb800            ; b800b8
         ; 66 b800 b8 8ee8
         ; 	 b800 b8
         ```

      3. ```shell
         00000060: 66 B8 00 B8 8E E8 B4 0F B0 43 65 66 A3 D0 0C 00  f........Cef....
         ```

      4. 跳转目标的偏移量应该是`60h`。可执行结果为何异常？

下面是用来验证的源代码：

```assembly
;[section .text]

;global _start

;_start:
        ;mov ax, 2
        ;jmp $
        mov ax, 0xB800
       ;jmp $
       ;jmp $
       ;jmp $
        mov gs, ax
        mov ah, 0Fh
        mov al, 'C'
        mov [gs:(80 * 20 + 40) * 2], ax
        jmp $
        jmp $
```



编译上面的代码后，用xxd查看二进制数据：

```assembly
[root@localhost v2]# xxd -u -a -g 1 -c 16 kernel.bin
00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
00000010: 02 00 03 00 01 00 00 00 60 80 04 08 34 00 00 00  ........`...4...
00000020: 88 00 00 00 00 00 00 00 34 00 20 00 01 00 28 00  ........4. ...(.
00000030: 03 00 02 00 01 00 00 00 00 00 00 00 00 80 04 08  ................
00000040: 00 80 04 08 75 00 00 00 75 00 00 00 05 00 00 00  ....u...u.......
00000050: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000060: 66 B8 00 B8 8E E8 B4 0F B0 43 65 66 A3 D0 0C 00  f........Cef....
00000070: 00 EB FE EB FE 00 2E 73 68 73 74 72 74 61 62 00  .......shstrtab.
00000080: 2E 74 65 78 74 00 00 00 00 00 00 00 00 00 00 00  .text...........
00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000000b0: 0B 00 00 00 01 00 00 00 06 00 00 00 60 80 04 08  ............`...
000000c0: 60 00 00 00 15 00 00 00 00 00 00 00 00 00 00 00  `...............
000000d0: 10 00 00 00 00 00 00 00 01 00 00 00 03 00 00 00  ................
000000e0: 00 00 00 00 00 00 00 00 75 00 00 00 11 00 00 00  ........u.......
000000f0: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00  ................
```



从上面的二进制数据中提取关键数据：

1. 第一个程序段的长度：

   1. ```shell
      00000030: ----------- 01 00 00 00 00 00 00 00 00 80 04 08  ................
      00000040: 00 80 04 08 75 00 00 00 75 00 00 00 05 00 00 00  ....u...u.......
      00000050: 00 10 00 00 -----------------------------------   ................
      ```

   2. ```
      00000030: ----------- ** ** ** ** ** ** ** ** ** ** ** **  ................
      00000040: ** ** ** ** 75 00 00 00 ** ** ** ** ** ** ** **  ....u...u.......
      00000050: ** ** ** ** -----------------------------------   ................
      ```

   3. 经过上面的分析，结果是`75 00 00 00`，`75h`。

2. 第一个程序段在文件中的偏移量：`00 80 04 08`

3. 程序的入口地址（即ip应该指向哪个地址)：

   1. ```shell
      00000000: 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............
      00000010: 02 00 03 00 01 00 00 00 60 80 04 08 34 00 00 00  ........`...4...
      ```

   2. 偏移量是：`60 80 04 08`，它在文件中的偏移量是`24h`。

##### 验证重新放置后的内核

通过bochs断点调试验证。

### 写内核

怎么写内核？我也忘记了。

编译时，设置对应选项，编译成elf文件。

内核代码，忘记了。

```assembly
; kernel.asm
[section .text]

global	_start

_start:
	mov ah, 0Fh
	mov al, 'K'
	mov gs, 0xB800
	mov [gs:(80*1+39)*2], ax
	
	jmp $
```

编译：

```shell
nasm -f elf kernel.asm -o kernel.o
ld -s kernel.o -o kernel.bin -m elf_i386
```



非常神奇。elf文件能像DOS文件一样被读入内存，然后跳转到这块内存执行指令。若是如此，就没有必要使用elf文件了。

elf文件的必要性是什么？