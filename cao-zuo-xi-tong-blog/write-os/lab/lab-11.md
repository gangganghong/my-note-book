# 实现进程---一个进程

## 无题

终于，要实现进程了。

本该在今天一起床就写进程，可我看了一个小时左右无用资讯。

光阴可贵，不可浪费一分一秒。

应该先整理代码吗？整理，是指，把代码分门别类放入文件夹。

暂时不整理。我迫不及待想推进进度。等代码更多了再整理。不看于上神的整理方案，自己整理自己写的代码。

这会导致一个问题：本来已经通过测试的的代码，经过调整后，出现很多错误。既然是自己写的代码，就必须能够解决出现大的问题。

闲话就说到这里。

## 理论

### 回顾

#### 进程和中断

进程，和中断例程相似。怎么调用中断例程？告诉CPU中断例程所在的代码段的选择子、中断例程的偏移量，CPU会自动完成剩余的事情。

怎么启动第一个进程？往栈中压入进程体所在的代码段的选择子、偏移量。还压入了哪些元素？然后，用`ret`出栈被压入的元素。进程体的选择子、偏移量更新到cs、eip，CPU开始执行进程。

第一个进程是这样启动的。操作系统不是一直运行同一个进程，而是运行多个进程。只有一个CPU（多核CPU是多个CPU吗？先只分析这种情况），要运行多个进程，只能运行一会A进程，然后运行B进程，然后又运行A进程。

CPU运行的进程在不同进程之间换来换去，以人类的感知，这种切换非常非常快。这就是进程切换。A进程运行得好好的，突然被换成B进程。打断A进程的契机是时钟中断。时钟中断按某个频率发生。每次发生时钟中断，CPU会停止正在做的事，转而执行中断例程。所有中断都能让CPU放下正在做的事情、转而执行中断例程。在时钟中断例程中，选择下一个要执行的进程。怎么选择下一个要执行的进程，这是“进程调度”要解决的问题。

#### 进程的一生

从“进程”的视角看CPU的执行流程：

1. 运行内核。
2. 通过`ret`运行进程A。
3. 时钟中断发生，执行中断例程，中断例程将要下一个要执行的进程B的选择子和偏移量入栈。
   1. 有错误。运行进程A，发生时钟中断，入栈的是A的选择子和偏移量。
   2. 要运行进程B，从哪里获取进程B的选择子和偏移量？
   3. 在进程B运行、发生时钟中断时，B的选择子和偏移量已经入栈。从进程B的堆栈从获取B的选择子和偏移量。
4. 在中断例程中使用`ret`(还是`reft`\`iret`)，让CPU执行进程B。

#### 时钟中断做什么

时钟中断例程做两件事：

1. 保存当前进程。
2. 选择下一个要执行的进程。

将当前进程保存到堆栈。哪个堆栈？

恢复另一个进程，从堆栈中获取进程的数据。又是哪个堆栈？

*上述知识，不是进程调度算法等具体知识。花这么多时间写它们，有用吗？*

#### PCB

进程控制块，Process Control Block。

每个进程的信息保存在它对应的PCB中，多个PCB组成一个数组A。这个元素是PCB的数组不叫“进程表”，PCB自己叫“进程表”。这点需要确认。

PCB存储一个进程的所有信息：

1. 中断发生前那一刻的寄存器中的值。
2. 进程ID。
3. 进程名称。
4. 进程优先级。
5. 进程堆栈。与第1点重复。寄存器中的值保存在进程堆栈中。
   1. 这是难点，是主要知识点。
   2. 内容很多，寄存器的值压栈的顺序有要求吗？是该记住它们还是照抄书本？和外部中断类似，内容多。
   3. 为“记住它们还是照抄书本”而浪费太多时间，还不如花点时间把它们全部记住，又不是比登蜀道还难。

时钟中断发生时，从数组A中取出当前进程的PCB，把当前进程的快照存入PCB的一个成员中。说到这里，隐瞒不了了，PCB是一个结构体。保存不止一项数据，最合适的数据结构是结构体。

数组A中那么多PCB，怎么才能挑选出当前进程的进程体呢？

~~创建一个当前进程体变量P，恢复进程时，把这个进程的进程体放入当前进程体变量P。~~

~~在时钟中断场景中，可以这么做。~~

创建一个变量P，存储当前进程体在数组A中的索引。例如，数组A是`{P1、P2、P3}`，当前进程体是P2，那么，P的值是1。

时钟中断发生时，P = 1，从数组A中获取当前进程的进程体P2，把当前进程的快照存储到P2中。

下一个要运行的进程是哪一个？实质是从数组A中选择PCB。确定了数组A的索引，也就确定了要从数组A中选择哪个PCB。从选择的PCB中获取要运行的进程的数据压入堆栈，使用`ret`填充寄存器，让CPU运行选择的进程。

已经讲完了进程机制的主要知识。

根据这些知识，每添加一个进程，需要在数组中A中增加一个进程体。

这与我的经验不同。我运行正在使用的写作软件，并没有在数组A中增加进程体，只是点击写作软件的图标。怎么解释？我不值得。

#### 我会怎么实现进程

脱离文字想这个问题，就是心算。思路不连贯。

先从第一个进程的启动开始说起吧。

启动第一个进程，特权级从0转移到3，使用`retf`实现。需要在执行`retf`前，在栈中按顺序准备好cs、eip的值。

准备好这两个值，进程就能够启动了。然而，我依稀记得，于上神的代码不只这样。

我回忆不起来更多知识了。继续回忆，只是浪费时间。

存储所有PCB的数组A，用遍历的方式初始化每个PCB。PCB由哪些元素构成？

1. 所有寄存器。
2. 进程名称。
3. 进程ID。

目前，只关注寄存器。PCB为进程建立快照时，只保存寄存器吗？

进程中的变量存储在哪里？

数组A又存储在哪里？

### 学习

#### v1

进程表包含哪些元素？

1. CPU快照，即通用寄存器和段寄存器的值。
2. LDT在GDT中的选择子。
3. ~~TSS在GDT中的选择子。~~
4. LDT表。

TSS不在进程表中。

LDT的GDT选择子和LDT表为什么要放在进程表中？怎么放到进程表中？

LDT表用变量`ldts`表示。`ldts`是在进程表中。LDT表本来就在进程表中，后面所做的，只是用进程的真实的代码段地址和数据段地址填充LDT表。

LDT的GDT表选择子也是如此。它本来就是进程表的一部分，填充了新内容而已。

进程的LDT的GDT选择子不放到本进程的进程表中，会怎么样？

不放到本进程的进程表中，那么，放到哪里呢？只能说，放到了本进程大的进程表之外。放到了本进程的进程表之外，也需要用单独的变量存储。有什么弊端？

1. 不可能用许多单独的变量存储进程的LDT的GDT选择子，更可能使用一个数组存储许多进程的LDT的GDT选择子。
   1. 若是如此，还比不上放到进程表中。管理起来更集中。
   2. 放到进程表之外的变量中，会被其他进程修改吗？
   3. 进程表中的数据，其他进程能修改吗？

我认为，把LDT的GDT选择子和LDT表放到进程表中，是为了集中管理进程使用的资源，没有体现进程拥有独立的地址空间（内存空间）。现有的进程实现，我只看到了进程能使用独立的CPU。

##### 疑问

能够使用不同的描述符（全局或局部）指向同一块内存。这句话，正确吗？

如果正确，通过描述符对内存实施保护，是不是不起作用。

例如，创建描述符A（特权级是0）指向内存区域AA，3特权级的用户进程无权限访问内存区域AA。可是，再创建描述符B（特权级是3）指向内存区域AA，3特权级的用户进程是不是就能够访问内存区域AA了？

`selector_ldt += 1 << 3;`，运算顺序是怎样的？

##### 怎么实现

进程表的构成要素：

1. CPU快照，即通用寄存器和段寄存器的值。
2. LDT的GDT选择子。LDT是一块内存，这块内存通过GDT中的一个描述符来指向。找到这个描述符的钥匙是LDT的GDT选择子。
   1. 选择子能人为设置，例如，把LDT的GDT选择子设置为3。
   2. 难点是，怎么让这个选择子指向LDT？
      1. GDT在初始化时固定了描述符的数量。
      2. 分配从第N个描述符开始的M个描述符作为M个进程的LDT的描述符。
      3. 初始化这M个描述符。其实就是用M个进程的LDT这段内存的初始地址和界限填充这些描述符。
      4. 问题又出现了，怎么知道LDT的初始地址和界限？
         1. 界限，容易知道，128个字节。
         2. 初始地址呢？
3. LDT。LDT的构成要素：
   1. 数据段。ds。
   2. 代码段。cs。
   3. ds、cs：把ring0的ds、cs修改特权级后得到。我不清楚为什么要这样做。如果不这样做，有其他的方法吗？

初始化进程，需要填充这个进程的进程表。

*非常不顺利。理解不了部分细节。无意中脱离了之前的学习方法。*

怎么学？

先回忆，回忆不起来知识点，再学习。每学习一次，马上再回忆。多次看，直到回忆出全部知识点。尽量不放过任何一个疑点。一直到能够记住全部知识点、自己实现全部进程为止。

#### v2

##### tss

用C语言重写，在init_prot初始化：

1. 全局变量tss。
2. 用tss填充GDT：描述符、段基址、偏移量、属性。
3. `tss.ss0`赋值。
4. 在恢复进程时，把进程的堆栈存储到了tss.esp0。

注意了，tss.esp0存储的是当前运行中的进程的堆栈。使用`lea`指令把进程表中的堆栈的栈顶地址赋值给`tss.esp0`。

`tss`存储运行中的进程的堆栈，供其他特权级向当前特权级转移时使用。给tss中的堆栈赋值时，运行在0特权级，保存当前进程的CPU快照使用的是tss.esp0。

上面的说法不正确。在进程的重启和切换中，有三个堆栈：

1. 进程使用的堆栈。
2. 进程表。
3. 内核栈。

保存在tss中的是进程表中的堆栈。当前进程被挂起时，把这个进程的CPU快照保存到这个进程的进程表的堆栈中。

进程在3特权级，进程表在0特权级。进程表所在的特权级高于对应进程所在的特权级。所以，tss中不存在3特权级的堆栈。因为，没有比3特权级堆栈更低的特权级。

tss中的构成元素那么多，我记不住。看书能写出来就行。

##### 实现进程

1. 初始化TSS和LDT的全局描述符。
   1. TSS只有一个，全局通用。
   2. 每个进程有一个LDT。
2. 初始化进程表。
   1. 设置进程表中的LDT的选择子。
   2. 设置进程表中的LDT中的局部描述符。
      1. 有两个。
      2. 分别是cs、ds。
      3. LDT中的cs、ds是0特权级修改特权级后的值。
   3. 段寄存器。
      1. cs是LDT中的cs，是LDT中的第一个描述符。
      2. 其他段寄存器（ds、es、fs、ss)是LDT中的第二个描述符，值是选择子（索引是1 + 选择子的TI + 选择子的RPL)。
      3. gs。
   4. 通用寄存器。
      1. eip。进程函数名称。
      2. eax。
      3. ecx。
      4. ebx。
      5. edx。
      6. esp.
      7. ebp
      8. 第一次启动进程，只需设置通用寄存器中的eip、esp。在建立进程快照的时候，需保存所有通用寄存器中的值到进程表中。
3. 第一次启动进程：
   1. 把esp指向这个进程的堆栈栈顶。
   2. 把tss.esp0赋值为这个进程的堆栈的原始栈顶。
   3. 手工出栈gs、fs、es、ds等。
   4. `popad`。
   5. iretd。中断例程必须用这个指令结尾，目的是修改IOPL。

写到这个程度，差不多就能够动手写进程了。可我仍然感觉没有掌握进程的实现。

时间久了，又会忘记，该怎么办？

一个进程，有它需要执行的代码，这就是进程体，外在表现形式是一个C语言函数。其实，也不需要是一个C语言函数，在汇编中，进程体可以是一个汇编函数或一段用标量标识位置的代码。进程的实质是一段指令，为了方便使用它的位置才把它写成一个函数。

这个函数内部使用的堆栈，在哪里设置的？

在初始化进程表时设置的。不同的进程，ss相同，但是esp不同。

我仍然不理解，一个进程中的局部变量存储在哪里。

#### v3

##### 实现进程

写出每个细节。

怎么实现一个进程？

1. 初始化tss。
   1. 用0填充tss结构，只设置tss.iobase的值是tss的大小。
   2. 用tss的相关数据填充GDT中的tss描述符。把tss的选择子和tss的描述符联系起来。
   3. 是在这个时候把tss的选择子写进进程表的吗？如果是多进程，不能在这里写到进程表。无关紧要，在任何一次遍历初始化进程时都能把tss的选择子写进进程表。
2. 初始化ldt。
   1. 一个进程拥有一个LDT。
   2. 把GDT中的某些描述符用LDT的数据填充。主要是LDT的段基址、段界限。
      1. 段基址是：ds的基址 + 存储ldt的内存区域的偏移量。这个偏移量是变量名。记住了，C语言中的变量名也能当偏移量用。
      2. 段界限：2个描述符的长度-1。
3. 初始化进程表：
   1. 填充ldt。
      1. ds。
      2. cs。
   2. 填充段寄存器。
      1. cs指向ldt中的第一个描述符，选择子的索引部分是0。
      2. 其他寄存器(ds、es、fs、ss)指向ldt中的第二个描述符，选择子的索引部分是1。
      3. gs：指向loader中确定的那个gs。所有进程共用一个gs。
   3. 填充通用寄存器。
      1. eip：进程体的函数名。
      2. esp：进程的堆栈栈顶。
      3. ebp、eax、ecx、edx，在第一次启动进程时，不需要处理。
4. 启动进程。
   1. 把esp指向进程表的栈顶。
   2. 加载ldt。
   3. 设置tss.esp0的值是当前进程的进程表的原始栈顶。
   4. 出栈gs、fs、ds、es、ss等。
   5. 出栈其他通用寄存器。
   6. iretd。

*我的笔记写得真差！TSS实验，耗费时间最多的问题是什么，我竟然没有记录！*

##### tss

1. 用C语言改写tss。
2. 填充GDT的第4个（初始值是0）描述符是tss。
3. 加载tss。
4. 重启第一个进程时，设置tss的esp0的值是当前进程的进程体。记住，进程体在0特权级，在内核中。

##### 唯一的难点

唯一的难点是，进程表中的构成要素：

1. Kernel_esp。
   1. 这是什么？在哪里用到？
   2. popad会自动忽略这个吗？
2. retadr。
   1. 这是什么？

准确地说，这是疑点。我仍然没有弄清楚。

进程表中那么多东西，我没有记住。

#### v4

最后再学习一次进程的实现。

##### tss

GDT中有N个元素，每个元素都是一个描述符。认为设置第M个元素是tss的描述符。M是tss的选择子的索引部分。

用tss这块内存的基址和大小更新第M个元素的描述符。以后，使用选择子S就能从GDT中获取tss。也就是说，加载tss时，操作数是选择子S。

tss这块内存的基址是：段基址 + 偏移量（变量名）。

用0填充tss，tss.iobase = sizeof(tss)。这符合定义。

##### LDT

用LDT这块内存的基址和界限填充GDT中的第X个描述符。以后，第X个描述符就是进程的LDT的描述符。

基址是LDT这个变量所在的物理地址：段基址（根据段选择子从描述符中获取段基址） + 偏移量（变量名）。

##### 进程表

1. ldt选择子。
2. ldt[0]
3. ldt[1]
4. 段寄存器
   1. 值都是LDT的选择子。
   2. cs是索引部分为0的选择子。
   3. 其他段寄存器的值是索引部分是1的选择子。
5. 通用寄存器
   1. eip：进程体的函数名
   2. esp：一个C语言数组。例如，arr[5]，那么，esp的值是 arr + 5。
6. eflags。
   1. 这是难点。
   2. 怎么确定这个值？详情见《一个操作系统的实现》第3.5节。
   3. if控制中断是否打开或关闭。

![image-20210413155320423](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210413155320423.png)

##### 启动进程

1. 把esp指向进程表中堆栈的栈顶。
2. 加载ldt。
3. 设置tss.esp0。
4. 出栈gs等段寄存器。
5. 出栈通用寄存器。
6. iretd

上面的每个步骤，我都理解。但我仍然觉得不踏实，不知道原因。

这种行为，应该叫背诵还是叫学习？

## 写代码

代码在：/home/cg/os/pegasus-os/v19。

先写出方案，再写代码。

可是，我很反感这种做法。边写边想，不痛快，符合习惯。先想好全部再写，违背习惯，不适应。

### v1

1. 用C重写tss，结构，s_tss。
2. 写进程表。
   1. struct s_proc。成员：
      1. struct regs。
         1. CPU快照，段寄存器和通用寄存器。
         2. 顺序，如何确定？
            1. 最先入栈的那几个值的顺序是固定的。
            2. 使用popad出栈的那几个值也是固定的。
            3. 其他的段寄存器能够人为设置。
      2. pid。
      3. ldt选择子。16个bit。
      4. ldt表ldts。数组，元素类型是描述符，数组长度是LDT_SIZE。
3. 创建全局变量tss、proc。
4. 在init_propt中初始化tss和ldt。
   1. tss
      1. 用0填充tss，使用自定义函数`memset`。
      2. tss.iobase = sizeof(tss)。
      3. 用tss填充GDT中的第N个描述符。从此，第N个描述符指向tss。
   2. ldt
      1. 用ldt填充GDT中第M个描述符。从此，第M个描述符指向ldt。
      2. 怎么用ldt填充GDT中的描述符？
         1. 无非就是设置描述符中的段基址和段界限。
         2. ldt这块内存的段基址是多少？ldt所在的段基址 + ldt的偏移量。
         3. ldt这块内存的段界限是多少？ldt的大小减去1。
5. 在kernel_main中初始化进程表
   1. 设置进程表中的ldt选择子。启动进程时加载ldt会使用。
   2. 填充ldt。
      1. ldt只有两个描述符：代码段描述符合数据段描述符。
      2. 把内核的cs、ds修改特权级后填充进去就行。
   3. 设置段寄存器。
      1. cs的值是ldt中的第1个描述符的选择子，索引部分是0。
      2. 其他段寄存器(ds、es、ss、fs)的值是ldt中的第2个描述符的选择子，索引部分是1。
      3. gs的值是全局gs的值修改特权级后的值。
      4. 注意了，进程的段选择子并非必须指向ldt。
   4. 设置通用寄存器。
      1. eip的值是进程体的函数名，TestA。
      2. esp的值是proc_stack + STACK_SIZE。它是一个数组proc_stack[STACK_SIZE]。
      3. 不用管其他通用寄存器的值。
6. 启动进程。
   1. 把esp指向进程表的栈顶，填充内容后的栈顶。
   2. 从进程表中获取ldt选择子，加载ldt。
   3. 设置tss.ss0的值是下一个要运行的进程的进程表的堆栈的原始栈顶。
   4. 出栈段寄存器。
   5. 出栈部分通用寄存器。
   6. iretd，出栈eflags、ss、cs、eip。

写成这个样子，基本就算掌握了理论知识。

### v2

#### tss

对照书上的结构图，写出这个结构。

I/O位图的详细讲解在《操作系统真相还原》的第11章（11.1）和第5章（5.4.2）。

![image-20210401143442704](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210401143442704.png)





![image-20210401143901516](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210401143901516.png)



![image-20210401144159974](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210401144159974.png)

找tss的资料图用了许多时间。

1. `ss0、ss1、ss2、gs`等段寄存器用32位还是16位表示？
2. tss的成员都用32位也可以。我不理解这点。在iobase前面，有个trap或trace，是什么？
3. iobase用32位或16位都行，不理解。
4. 注意了，struct的第一个成员在低内存地址处，最后一个成员在高内存地址处。

#### regs

同样对照书上的结构图写出这个结构。

栈顶那几个元素，是时钟中断压入的，顺序固定。

#### Memset

`Memset(void *dest, char character, int size)`。

用si或di指向dest，然后，使用character逐字节填充dest。

填充次数为size时结束填充，手工递增ecx和si或di。over.

#### 疑问

###### tss

tss的描述符的属性是怎样的？

1. tss是一段内存，数据段，0特权级。
2. 因此，tss的属性和数据段的全局描述符属性一致。

tss的选择子是C代码中定义的常量，怎么在汇编代码中加载tss，即，怎么在汇编代码中使用C代码中定义的常量？

答案是：不能在汇编代码中使用C代码中定义的常量，需要在汇编代码中定义值相同的变量。

###### ldt

ldt的全局描述符的属性是什么？与tss同理，也和数据段的全局描述符属性一致。

ldt内的局部描述符的属性是什么？属性中的特权级部分要改成第3特权级。

## 调试

在C语言中，定义了结构体A，函数B使用结构体A，那么，函数B必须放在定义了结构体A的代码后面。



```assembly
; 加载tss
	; 怎么使用C代码中的常量？
	; ltr TSS_SELECTOR
	ltr [TSS_SELECTOR]
```

导致下面的错误

```shell
(0) [0x00000003044a] 0008:000000000003044a (unk. ctxt): ltr word ptr ds:0x00000040 ; 0f001d40000000
<bochs:32> sreg
es:0x0030, dh=0x00cf9300, dl=0x0000ffff, valid=31
	Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed
cs:0x0008, dh=0x00cf9b00, dl=0x0000ffff, valid=1
	Code segment, base=0x00000000, limit=0xffffffff, Execute/Read, Non-Conforming, Accessed, 32-bit
ss:0x0030, dh=0x00cf9300, dl=0x0000ffff, valid=31
	Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed
ds:0x0030, dh=0x00cf9300, dl=0x0000ffff, valid=31

<bochs:33> xp /1gx 0x30:0x40
[bochs]:
0x0000000000000040 <bogus+       0>:	0xf000f84dc0000156
<bochs:34> s
00017988612e[CPU0  ] LTR: selector.ti != 0

```

因为 `ltr [TSS_SELECTOR]`被解释成`ltr word ptr ds:0x00000040`。





```shell
(0) [0x00000003044a] 0008:000000000003044a (unk. ctxt): xor eax, eax              ; 31c0
<bochs:5> s
Next at t=17988613
(0) [0x00000003044c] 0008:000000000003044c (unk. ctxt): mov ax, 0x0040            ; 66b84000
<bochs:6> s
Next at t=17988614
(0) [0x000000030450] 0008:0000000000030450 (unk. ctxt): ltr ax                    ; 0f00d8
<bochs:7> s
00017988614e[CPU0  ] LTR: doesn't point to an available TSS descriptor!
```



`1111000000000000111000111111111011110000000000001111100001000001`



```shell
<bochs:7> xp /1hx 0x30:0x346a0
[bochs]:
0x00000000000346a0 <bogus+       0>:	0x0038
<bochs:8> xp /1hx 0x30:0x346a2
[bochs]:
0x00000000000346a2 <bogus+       0>:	0x000d
<bochs:9> xp /1hx 0x30:0x346a4
[bochs]:
0x00000000000346a4 <bogus+       0>:	0x000d
<bochs:10> xp /1hx 0x30:0x346a6
[bochs]:
0x00000000000346a6 <bogus+       0>:	0x000d
<bochs:11> xp /1hx 0x30:0x346a8
[bochs]:
0x00000000000346a8 <bogus+       0>:	0xec89
<bochs:12> xp /1hx 0x30:0x346aa
[bochs]:
0x00000000000346aa <bogus+       0>:	0xc35d

```



```assembly
; 启动进程
restart:
	mov esp, [proc_table]
	; 加载ldt
	lldt [proc_table + 52]
	; 设置tss.esp0
	lea eax, [proc_table + 52]
	mov [tss + 4], eax 
	; 出栈 	
	pop gs
	pop fs
	pop es
	pop ds

	popad
	
	iretd
```



```
<bochs:15> xp /1wx 0x30:0x346d0
[bochs]:
0x00000000000346d0 <bogus+       0>:	0x00030e56
<bochs:16> xp /1wx 0x30:0x346d4
[bochs]:
0x00000000000346d4 <bogus+       0>:	0x00000005
<bochs:17> xp /1wx 0x30:0x346d8
[bochs]:
0x00000000000346d8 <bogus+       0>:	0x00001202
<bochs:18> xp /1wx 0x30:0x346dc
[bochs]:
0x00000000000346dc <bogus+       0>:	0x0000000d
<bochs:19> xp /1wx 0x30:0x346e0
[bochs]:
0x00000000000346e0 <bogus+       0>:	0xffff0048

```



```
(0) [0x000000030598] 0008:0000000000030598 (unk. ctxt): iret                      ; cf
<bochs:21> s
00017989104e[CPU0  ] check_cs(0x0005): not a valid code segment !
Next at t=17989105
(0) [0x000000030538] 0008:0000000000030538 (unk. ctxt): push 0x0000000d           ; 6a0d
<bochs:22> 

```



00017989104e[CPU0  ] check_cs(0x0005): non-conforming code seg descriptor dpl != cpl, dpl=2, cpl=1

```
<bochs:10> sreg
es:0x000d, dh=0x00cfb300, dl=0x0000ffff, valid=1
	Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed
cs:0x0008, dh=0x00cf9b00, dl=0x0000ffff, valid=1
	Code segment, base=0x00000000, limit=0xffffffff, Execute/Read, Non-Conforming, Accessed, 32-bit
ss:0x0030, dh=0x00cf9300, dl=0x0000ffff, valid=31
	Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed
ds:0x000d, dh=0x00cfb300, dl=0x0000ffff, valid=1
	Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed
fs:0x000d, dh=0x00cfb300, dl=0x0000ffff, valid=1
	Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed
gs:0x0038, dh=0x8600f30b, dl=0x8000ffff, valid=1
	Data segment, base=0x860b8000, limit=0x0000ffff, Read/Write, Accessed
ldtr:0x0048, dh=0x00008203, dl=0x46e2000f, valid=1
tr:0x0040, dh=0x00008b03, dl=0x3e20006b, valid=1
gdtr:base=0x0000000000033820, limit=0x3ff
idtr:base=0x0000000000033ea0, limit=0x7ff
<bochs:11> s
00017989104e[CPU0  ] iret: SS.rpl != CS.rpl

```



```
========================================================================
148865704000i[CPU0  ] CPU is in protected mode (halted)
148865704000i[CPU0  ] CS.mode = 32 bit
148865704000i[CPU0  ] SS.mode = 32 bit
148865704000i[CPU0  ] EFER   = 0x00000000
148865704000i[CPU0  ] | EAX=00030d00  EBX=46884444  ECX=00000000  EDX=00000036
148865704000i[CPU0  ] | ESP=000346d0  EBP=00e6b80e  ESI=00033de8  EDI=00000006
148865704000i[CPU0  ] | IOPL=1 id vip vif ac vm rf nt of df if tf sf zf AF pf cf
148865704000i[CPU0  ] | SEG sltr(index|ti|rpl)     base    limit G D
148865704000i[CPU0  ] |  CS:0008( 0001| 0|  0) 00000000 ffffffff 1 1
148865704000i[CPU0  ] |  DS:000d( 0001| 1|  1) 00000000 ffffffff 1 1
148865704000i[CPU0  ] |  SS:0030( 0006| 0|  0) 00000000 ffffffff 1 1
148865704000i[CPU0  ] |  ES:000d( 0001| 1|  1) 00000000 ffffffff 1 1
148865704000i[CPU0  ] |  FS:000d( 0001| 1|  1) 00000000 ffffffff 1 1
148865704000i[CPU0  ] |  GS:0038( 0007| 0|  0) 860b8000 0000ffff 0 0
148865704000i[CPU0  ] | EIP=0003055d (0003055d)
148865704000i[CPU0  ] | CR0=0x60000011 CR2=0x00000000
148865704000i[CPU0  ] | CR3=0x00000000 CR4=0x00000000
(0).[148865704000] [0x00000003055d] 0008:000000000003055d (unk. ctxt): push 0x00000000           ; 6a00
148865704000i[CMOS  ] Last time is 1618438905 (Wed Apr 14 15:21:45 2021)

```



```
<bochs:2> q
00017989419i[      ] dbg: Quit
00017989419i[CPU0  ] CPU is in protected mode (active)
00017989419i[CPU0  ] CS.mode = 32 bit
00017989419i[CPU0  ] SS.mode = 32 bit
00017989419i[CPU0  ] EFER   = 0x00000000
00017989419i[CPU0  ] | EAX=000346a0  EBX=00003400  ECX=0000000f  EDX=00033e20
00017989419i[CPU0  ] | ESP=000337d0  EBP=000337fc  ESI=00033e8c  EDI=00000000
00017989419i[CPU0  ] | IOPL=0 id vip vif ac vm rf nt of df if tf sf zf AF PF cf
00017989419i[CPU0  ] | SEG sltr(index|ti|rpl)     base    limit G D
00017989419i[CPU0  ] |  CS:0008( 0001| 0|  0) 00000000 ffffffff 1 1
00017989419i[CPU0  ] |  DS:0030( 0006| 0|  0) 00000000 ffffffff 1 1
00017989419i[CPU0  ] |  SS:0030( 0006| 0|  0) 00000000 ffffffff 1 1
00017989419i[CPU0  ] |  ES:0030( 0006| 0|  0) 00000000 ffffffff 1 1
00017989419i[CPU0  ] |  FS:0030( 0006| 0|  0) 00000000 ffffffff 1 1
00017989419i[CPU0  ] |  GS:003b( 0007| 0|  3) 000b8000 0000ffff 0 0
00017989419i[CPU0  ] | EIP=0003047f (0003047f)
00017989419i[CPU0  ] | CR0=0x60000011 CR2=0x00000000
00017989419i[CPU0  ] | CR3=0x00000000 CR4=0x00000000
(0).[17989419] [0x00000003047f] 0008:000000000003047f (unk. ctxt): push ebp                  ; 55

```



![image-20210414232831823](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210414232831823.png)





![image-20210415000352268](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210415000352268.png)

来之不易啊！

必须在进程中使用 delay，否则会出现错误。

再次测试，发现，不使用delay也不会出现错误。



![image-20210415060516929](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210415060516929.png)

![image-20210415061101300](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210415061101300.png)



![image-20210415061240627](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210415061240627.png)



TSS的描述符的属性的低八位是0x89。按照图中的顺序，从左往右填充，并且写成十六进制。注意，如果DPL是1，写成01而不是10。



1、状态标志(Status Flags)
EFLAGS寄存器的状态标志(0、2、4、6、7以及11位)指示算术指令（如ADD, SUB, MUL以及DIV指令）的结果，这些状态标志的作用如下：

CF(bit 0) [Carry flag]   若算术操作产生的结果在最高有效位(most-significant bit)发生进位或借位则将其置1，反之清零。这个标志指示无符号整型运算的溢出状态，这个标志同样在多倍精度运算(multiple-precision arithmetic)中使用。
PF(bit 2) [Parity flag]   如果结果的最低有效字节(least-significant byte)包含偶数个1位则该位置1，否则清零。
AF(bit 4) [Adjust flag]   如果算术操作在结果的第3位发生进位或借位则将该标志置1，否则清零。这个标志在BCD(binary-code decimal)算术运算中被使用。
ZF(bit 6) [Zero flag]   若结果为0则将其置1，反之清零。
SF(bit 7) [Sign flag]   该标志被设置为有符号整型的最高有效位。(0指示结果为正，反之则为负)
OF(bit 11) [Overflow flag]   如果整型结果是较大的正数或较小的负数，并且无法匹配目的操作数时将该位置1，反之清零。这个标志为带符号整型运算指示溢出状态。
在这些状态标志中，只有CF标志能够通过使用STC, CLC以及CMC指令被直接修改，或者通过位指令(BT, BTS, BTR以及BTC)将指定的位拷贝至CF标志中。

这些状态标志允许单个的算术操作产生三种不同数据类型的结果：无符号整型，有符号整型以及BCD整型。如果把该结果当做无符号整型，那么CF标志指示越界(out-of-range)状态——即进位或借位，如果被当做有符号整型，则OF标志指示进位或借位，若作为BCD数，那么AF标志指示进位或借位。SF标志指示有符号整数的符号位，ZF指示结果为零。此外在执行多倍精度算术运算时，CF标志用来将一次运算过程中带进位的加法(ADC)或带借位的减法(SBB)产生的进位或借位传递到下一次运算过程中。

2、DF标志(DF flag)
这个方向标志(位于EFLAGS寄存器的第10位)控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），清除该标志则使得串指令自动递增。STD以及CLD指令分别用于设置以及清除DF标志。

3、系统标志以及IOPL域(System Flags and IOPL Field)
EFLAGS寄存器中的这部分标志用于控制操作系统或是执行操作，它们不允许被应用程序所修改。这些标志的作用如下：

TF(bit 8) [Trap flag]   将该位设置为1以允许单步调试模式，清零则禁用该模式。
IF(bit 9) [Interrupt enable flag]   该标志用于控制处理器对可屏蔽中断请求(maskable interrupt requests)的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。
IOPL(bits 12 and 13) [I/O privilege level field]   指示当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。
NT(bit 14) [Nested task flag]   这个标志控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。
RF(bit 16) [Resume flag]   控制处理器对调试异常的响应。
VM(bit 17) [Virtual-8086 mode flag]   置1以允许虚拟8086模式，清除则返回保护模式。
AC(bit 18) [Alignment check flag]   该标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。
VIF(bit 19) [Virtual interrupt flag]   该标志是IF标志的虚拟镜像(Virtual image)，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展(virtual mode extensions)
VIP(bit 20) [Virtual interrupt pending flag]   该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零。【Software sets and clears this flag; the processor only reads it.】与VIF标志结合使用。
ID(bit 21) [Identification flag]   程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。

## 小结

一、首先遇到的问题，是C语法问题：

1. 在使用结构体之前，必须先创建结构体。例如，一个函数的参数使用了进程表结构体，这个函数的声明和创建都必须在声明进程表结构体代码的后面。
2. C语言中，函数的参数类型是指针，这个参数对应的实参应该是内存地址，例如，`&a`。
3. 内存地址虽然是一个32位整数，但与其他整数运算前必须先强制类型转换成整数。例如，(int)&a。
4. 还有其他一些错误，我忘记了。下次，要立刻、马上记录下来。

二、汇编问题

1. `pop ax`执行后，esp会增加4个字节。无论我用什么方法，都不能让esp只增加2个字节。对应地，我只能把栈中和ax对应的数据修改成4个字节而不是2个字节。例如，进程表中的寄存器堆栈，我用4个字节而不是2个字节表示段寄存器的值。而段寄存器中存储的值是16位。
2. popad。
   1. 这个命令按顺序出栈一系列值到寄存器中，其中，就包含esp的值。
   2. 在进程表中，存储CPU快照的堆栈中，pushad会入栈一个esp，中断本身也会入栈一个esp，iretd强制要求堆栈的最高地址处几个元素中包含esp。
   3. 堆栈的最高地址处的esp是中断发生时强制入栈的，有用。pushad入栈的数据中也有esp。这个值无关紧要，最终会被popad更新。
   4. 我漏掉了进程表中的低地址处的esp，导致执行iretd后，部分段寄存器的值被赋予到其他寄存器，导致明显错误。
   5. 怎么发现这个问题的？通过对比于上神的代码和我的代码，发现了问题。

三、汇编代码和C代码交互数据

早在loader中，已经创建了GDT，并且创建了几个描述符，显存描述符就是其中一个。

进入内核后，我用C代码建立了GDT，把内存中的GDT复制到了C结构。

数据并没有被正确复制过来，出现了差异。显存描述符的数据就存在差异。在汇编中建立显存描述符时，我把段基址设置成`0xb8000`。到了C代码中，显存的段基址却变成了其他值，例如`0x68b8000`。

我怎么发现这个问题的？启动进程时，更新gs的值后，发现gs中的值所指向的描述符的段基址发现了变化。当然，表面现象是：无法在屏幕上打印字符。

试了很多次，我才怀疑：显存的段基址错误，导致无法在屏幕上打印字符。尽管，显存的选择子并没有发生改变，它指向的描述符的段基址却发生了变化。

我不知道它在哪里发生了变化，我只看到：更新gs后，发生了变化。我想到一个方法，解决了这个问题：在初始化TSS描述符时，再次初始化显存的描述符，把显存的段基址重新设置成`0xb8000`。

更新gs，会更新选择子指向的描述符。

四、位移使数据溢出

134，右移24位，变成负数。

根据段名求物理地址，计算结果是负数。原因就是对描述符的最高8位右移24位变成的。

怎么规避这个错误？对位移结果强制转换数据类型。

可是，在复制GDT的过程中，没有找到能强制转换数据类型的机会。

五、特权级转移

bochs报错，似乎要求：

1. CS.RPL = SS.RPL

还有其他，看到这些特权级信息，我没有把握，只能猜测，或重看资料。这块知识，我仍没有掌握。

六、难点与重点

1. TSS和LDT，描述符属性各自有固定值，在《操作系统真相还原》中已经写出来了。
2. 进程的段寄存器中的值是选择子，选择子的低3位要反映出：
   1. 它们是指向LDT的。
   2. 特权等级。
3. 在bochs中查看到的描述符值，是小端法；在《一个操作系统的实现》中看到的那张描述符结构图，也是小端法。从左到右，描述符值和描述符结构图，是一一对应的。
4. 用小端法表示。特权级1，DPL的两个bit从左到右，依次是：`01`。

七、疑点

1. 一开始，不使用delay，运行进程总是出现：Invalid Code。后来，无论是否使用delay，进程都能正常运行。原因是什么？
2. 显存描述符为什么和当初设置的值不同？

八、todo

创建GDT描述符的宏或函数的属性参数修改成16位，第8~~11位修改成0。

九、小结

1. 写完全部代码，大概用了3个小时。
2. 调试并解决所有问题，大概用了八个小时。仍然很低效，无脑调试。我懒得起床，躺在床上调试了很久。
3. 实现进程，拖了这么久，不应该。
4. 学习知识，按下面的流程：
   1. 先回忆，尽力回忆。
   2. 学习，学习，熟读成诵。
   3. 自己写代码。
5. 按这个流程，就算是进程，也不应该拖这么久！首先，我觉得进程的内容比较多，所以一直不想做这个实验；然后，我回忆的时间太长太长了。不记得以前学习过的内容，就应该尽快学习。


## 总结



## 其他

《微机原理和接口技术》的目录在第6页，能用WPS的左下角的页面跳转跳到目标页面。

第13页PDF对应书的页码第1页。

PDF页数 = 13 + 书的页码