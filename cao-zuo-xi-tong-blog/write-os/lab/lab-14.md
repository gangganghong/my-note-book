# 实现进程---中断重入--简化版本

## 代码位置

/home/cg/os/pegasus-os/v22

## 回忆

在实现多进程时，我把中断例程划分成了三个部分：建立快照、中间代码（调度程序）、启动进程。

第一、第三个是原子操作，中间代码在执行过程中，会接收其他中断。

我把其他中断分成两类：时钟中断和非时钟中断。

### 时钟中断

当前正处于时钟中断例程中，将会根据调度规则选择下一个要运行的进程。突然又发生时钟中断。发生时钟中断的目的是什么？也是调度进程。目的一致，那么，不处理这个中断，让CPU继续执行这个中断发生前的任务。

为什么？

说不出原因。先不管原因。

怎么做到”不处理这个中断，让CPU继续执行这个中断发生前的任务“？

设置一个变量，reenter，初始值是-1。

1. 进入中间代码，reenter + 1，变为 0。
2. 进入启动进程流程，reenter -1，变为-1。
3. 进入中间代码前，检查 reenter
   1. 等于 -1，继续进入中间代码。
   2. 等于0，跳过中间代码，进入启动进程流程。

### 非时钟中断

非时钟中断不会进入时钟中断例程。但是，非时钟中断例程仍然分为三个过程：

1. 建立快照。
2. 中间代码。
3. 启动进程。

中间代码不是进程调度代码，而是处理中断请求，例如键盘操作。启动进程，是启动被中断挂起的进程。

### 疑问

时钟中断例程正在运行，有人敲击了键盘，此时，CPU会怎么处理？

具体化条件，时钟中断例程正在运行在中间代码。必定是这种情况，才会处理键盘操作。

1. 挂起中断例程，进入键盘中断例程。
2. 在键盘中断例程中，为时钟中断例程建立快照。
3. 执行键盘中断例程。
4. 发生时钟中断，检查reenter是0，继续运行键盘中断例程。
5. 键盘中断例程执行完毕，启动时钟中断例程。
6. 时钟中断例程继续运行。

### 结论

所有中断例程都能分成三个部分：建立进程快照、中间代码、启动进程。

时钟中断例程的中间代码调度进程。非时钟中断例程，例如键盘中断例程，处理中断请求。

正在运行键盘中断例程的中间代码，又发生了中断请求，怎么办？我不知道。

非时钟中断例程的代码在执行前，是不是打开了中断？也不知道。

时钟中断例程处理中断重入的方法是：

1. 创建变量reenter，初始值是-1。
2. 进入中间代码后，reenter + 1，值变成0。
3. 进入启动进程代码后，reenter - 1，值变成-1。
4. 进入中间代码前，检查reenter。
   1. 等于0，跳转到启动进程代码。
   2. 等于-1，进入中间代码。

无论是时钟中断还是非时钟中断，重入时，在时钟中断中，都这样处理。

## 学习

看不明白。

只能多次看，直到能独立写出所有代码。

这样，反而节约时间。

### v1

#### 屏蔽当前中断

进入当前中断后，中断被关闭，是所有中断被关闭。屏蔽当前中断。即使打开了中断，也不会再接收当前中断。

在当前中断没有处理完之前，一直屏蔽当前中断。在当前中断处理结束后，再打开当前中断。

这是为什么？

仍然不能明白这点。

### v2

于上神把中断例程抽象成了模板。我观察到中断例程的重复部分，但并没有绝对有必要把它们做成模板。可能是我写得中断例程不多。

强行去掌握模板，只能像背诵一样。我决定，暂时不把中断例程抽象成模板。

目前，只实现时钟中断例程、辨别中断重入就可以了。

#### 中断重入

1. 不屏蔽当前中断。我没有体会到这样做的必要性。
2. 只考虑时钟中断的中断例程。其他中断例程，我现在想不清楚，也不知道如何验证。

## 写代码

1. 在kernel_main函数中给全局变量k_reenter赋值为-1。
2. 在中间代码中，自增k_renenter，检查k_reenter
   1. 不等于0，是中断重入，跳过中间代码。
   2. 等于0，不是中断重入，运行中间代码。
3. 启动进程，
   1. 第一次启动进程的代码和恢复进程的代码应该分开吗？
   2. 关键在于k_reenter的处理
   3. 启动进程，不处理k_reenter
   4. 恢复进程，自减k_reenter
   5. 分开吧。因为我暂时想不明白。先写出来，再优化代码。

## 调试

一、在C中用char、short创建全局变量，赋值为-1，能在汇编代码中正确使用吗？

1. 在C中创建 char k = -1。
2. 在汇编中能否正常运行。
   1. `inc byte [k]`
   2. `cmp byte [k], 0`
   3. `dec byte [k]`
3. 在C中用int创建全局变量，在汇编中能正常运行。

二、汇编指令jne

1. jne。`cmp [k],0`。当k不等于0时跳转。

> JNZ（或JNE）（jump if not zero, or not equal），[汇编](https://baike.baidu.com/item/汇编)语言中的条件转移指令。结果不为零（或不相等）则转移。

> 格式： JNZ（或JNE） PRO

> 测试条件：ZF=0

三、弄错了逻辑

1. 我没有在中间代码中加入延迟函数，根本就不会发生中断重入，我却一直期望看到中断重入的运行结果，反复调试了很多次。
2. 无论是否有中断重入，hwint0都应该跳转到restore，而不是跳入restore或restart。

## 总结

懈怠，不想继续学。

写过的中断例程太少，不足以理解抽象出来的中断例程模板，非要写得和书上一样，只能多看然后记下来。理解中断例程模板，花了一些时间。

我打算等我写过很多中断例程后，再优化中断例程，封装成模板。

在调试上花的时间最多。遇到了的问题，在上面的调试中已经写出来了。

## 遗留问题

中断重入时，没有运行中间代码，这意味着，时钟中断次数没有增加。

能怎么改进？

发现是中断重入，不更换进程表，但时钟中断次数仍然增加1。