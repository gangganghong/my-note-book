# 编码建立文件系统

## 代码位置

/home/cg/os/pegasus-os/fs/v2

## 流程

建立文件系统，实质是把一些数据结构写入到硬盘中。

需要先写好一些方法。

梳理一下流程，也不是完全的流程。在梳理的过程中，看看需要先写好哪些方法。

流程如下：

1. 数据结构。
   1. 超级块。
      1. 有一个成员，安装文件系统的分区的扇区数量。通过IPC用硬盘驱动获取。
      2. 硬盘驱动需增加`IOCTL`方法，从硬盘分区信息中获取主扩展分区的大小。
   2. inode-map。
   3. sector-map。
   4. inode-array。
   5. 根目录。
2. 上面的每个数据结构都要写入硬盘。
   1. 写入硬盘由硬盘驱动完成。硬盘驱动需要实现读写方法。
   2. 文件系统通过IPC请求硬盘驱动读写硬盘。
   3. 在文件系统中，使用一个函数实现读写硬盘功能。
   4. 在文件系统中，读写硬盘的函数需要很多参数，使用两个宏函数（读和写）封装这个函数。

## 优化IPC

目前，IPC不支持中断。我使用自旋锁实现延迟。

暂时不优化IPC，比较难。

不优化不能做其他工作，才优化；完成其他工作后，再优化。

## 获取分区的扇区数

### 硬盘驱动

仿照打开硬盘的代码框架，增加“GET_HD_IOCTL"。

不必写思路。太简单。

### 文件系统

思路很简单。不写。

### 难点

不解决IPC回访问题，无法运行其他功能。

两种方案：

1. 先解决IPC回访问题。
2. 先写好其他功能，但是不测试。

使用第2个方案。

## 读写硬盘

### 硬盘驱动

#### 疑问

##### `port_read(REG_DATA, hdbuf, SECTOR_SIZE);`

当硬盘中的数据不足一个扇区时，port_read函数也读取一个扇区的数据。这会出现问题吗？

假设硬盘的容量是X个扇区，

1. 从X-1个扇区的位置读取一个扇区的数据，能正常读取。
2. 从X个扇区的位置读取一个扇区的数据，不能正常读取。

我担忧什么？担忧硬盘中的数据不足一个扇区时，会把硬盘中不是目标数据的数据读取出来。

什么是目标数据？从硬盘的指定位置开始，一个扇区内的数据都是目标数据。只会存在剩余数据是否有一个扇区大小的问题，而不会存在剩余数据是不是目标数据的问题。

再讨论：硬盘的剩余数据不足一个扇区会出现什么结果？

硬盘，具体说，安装了文件系统的硬盘的逻辑分区，大小是整数个扇区。如果用扇区为单位去读硬盘，在读取之前，剩余的扇区数量一定是N个扇区。N的取值范围是`[0, 逻辑分区的扇区数量]`。

只需要讨论：

1. 当逻辑分区的扇区数量是5个，逻辑分区的第1个扇区的LBA地址是0，最后一个扇区即第5个扇区的LBA地址是4。
2. 读取逻辑分区的第1个扇区，指定初始地址是0。
3. 读取逻辑分区的第5个扇区，指定初始地址是4。
4. 指定初始地址是5，读取逻辑分区的第多少个扇区？
   1. 这是硬盘会考虑的事情，我管不了。我可以测试一下，会读取到什么。
   2. 逻辑分区的最大LBA地址是4，指定初始地址是5，这是非法的。
5. 问题消失了。

##### port_write(REG_DATA, la, bytes);

~~要写入硬盘的数据不足一个扇区时，会出现问题吗？~~

~~为什么不和读硬盘时一样、总是读取一个扇区呢？~~

~~因为，会写入脏数据。~~

在硬盘驱动中，写硬盘时，起点是`512*N`，要写入的数据的大小也是`512*N`。

为什么？这是由文件系统调用硬盘驱动时传递的参数决定的。硬盘驱动只负责以扇区为单位读写硬盘。

可是，实际读写文件时，读写文件的位置不总是`512*N`，读取或写入的数据的大小也不总是`512*N`。

吃午饭时，想明白了怎么理解“读写硬盘时单位是非整数扇区”问题。

假设，从LBA是N的扇区开始，读取M个扇区。

怎么确定M的值呢？把LBA是N到LBA是（N+M-1)的扇区都读取到内存中。要操作的数据（读或写）在这些扇区的范围内。

为什么这样说？不好说。画一张简单的图，就能明白。

| LBA/POS | N               | pos               |                 |      | M               | pos_end           |                 |
| ------- | --------------- | ----------------- | --------------- | ---- | --------------- | ----------------- | --------------- |
| 扇区    | 扇区的初始位置N | 扇区中的某个位置N | 扇区的结束位置N |      | 扇区的初始位置M | 扇区中的某个位置M | 扇区的结束位置M |
|         |                 |                   |                 |      |                 |                   |                 |

读取的数据A是：`扇区的初始位置N`到`扇区的结束位置M`。实际需要的数据B是：`扇区的某个位置N`到`扇区的某个位置M`。

A数据是不是包括了B数据？是！

先从硬盘中读取A数据，再进行读写操作。

1. 读。
   1. 从A数据中获取B。
   2. 这很简单。
   3. 从A数据的offset开始读取len个字节的数据。
   4. offset是什么？是`pos%512`。
   5. len是什么？要读取多少字节数据，len就是多少。
2. 写。
   1. 假设要写入硬盘的数据是C。
   2. 用C填充A中的B。也就是，从A的offset开始，把C数据复制到B的范围。
   3. 把A写入硬盘。

###### min(bytes_left, chunk * SECTOR_SIZE - off);

`fs/read_write.c#do_rdwt`中的`int bytes = min(bytes_left, chunk * SECTOR_SIZE - off);`。

在文件系统的`do_rdwt`中，数据读写单位是fsbuf吗？不一定。数据读写单位一定是`chunk * SECTOR_SIZE`。

读数据，`phys_copy((void*)va2la(src, buf + bytes_rw),(void*)va2la(TASK_FS, fsbuf + off),bytes);`。

写数据，`phys_copy((void*)va2la(TASK_FS, fsbuf + off),(void*)va2la(src, buf + bytes_rw),bytes);`。

如果bytes超过`chunk * SECTOR_SIZE - off`，没有意义，而且，可能有副作用。

先看读。

1. 只读取了`chunk * SECTOR_SIZE`字节数据到fsbuf中。
2. 从fsbuf的off字节开始复制数据。
3. 只复制剩余的`chunk * SECTOR_SIZE - off`字节数据都是硬盘中的数据。
4. 如果复制`chunk * SECTOR_SIZE - off + 1`字节数据，那么，最后1个字节的数据不是来自硬盘，而是内存中的固有的随机数据R。
5. R数据显然不是我们要读取的目标数据。

再看写。

1. 只写入`chunk * SECTOR_SIZE`字节数据到硬盘。
2. 如果复制到`fsbuf+off`的数据超过了`chunk * SECTOR_SIZE - off`字节，这些数据将不会写入硬盘。

### 文件系统



## 数据结构

尽量不看书和作者的代码。写代码时，文件系统需要什么样的数据结构（数据结构需要哪些成员），就建立什么样的数据结构。实现文件系统不需要的成员，就不添加到数据结构中。

## mkfs

为文件系统填充数据，然后写入硬盘。这是工作量最大的部分。

## 小结

### 2021-07-05 06:18

编码建立文件系统需要做哪些工作，梳理清楚了。

有点开心，终于要开始在硬盘上建立文件系统了，不是完全抄写于上神的代码，自己知道该怎么做。

耗时39分。

毫无紧张感，速度应该再快些。

### 2021-07-05 06:42

增加"GET_HD_IOCTL"，耗时22分。

复制粘贴，写操作系统也存在这样的工作。

由于IPC不能多次使用，无法先运行"HD_OPEN"，再运行”GET_HD_IOCTL"。

### 2021-07-05 12:14

写硬盘读写函数时无思路，看于上神的代码，又有许多不理解的地方。

时间消耗在理解`kernel/hd.c#hd_rdwt`。

疑问在上面的`读写硬盘#硬盘驱动#疑问`。

耗时58分钟。

又看了11分钟。看`fs/read_write.c#do_rdwt`。

里面有我以前写的注释。

哪些代码写了注释，哪些没有写，我没有记录，现在也不记得。消耗那么多时间的学习成果，不该这么轻易扔掉。

记忆力可能下降了，不写笔记，会做更多无用功。

我若记得这个函数，不会在`hd_rdwt`受阻那么久。

在`do_rdwt`中，硬盘读写是以扇区为单位的，在`hd_rdwt`中，读写硬盘的初始位置，必定是某个扇区的初始位置，不会是不足一个扇区的位置。

### 2021-07-05 13:44

读文件系统和硬盘驱动读写硬盘的代码。费劲。耗时29分。

让我费解的问题是：非整扇区数据的读写问题。

### 2021-07-05 15:03

时间主要消耗在`fs/read_write.c#do_rdwt`中的`int bytes = min(bytes_left, chunk * SECTOR_SIZE - off);`。

另外，这个函数中的循环，不是多余的。

因为，`int chunk = min(rw_sect_max - rw_sect_min + 1,FSBUF_SIZE >> SECTOR_SIZE_SHIFT);`。

chunk不是我认为的总是`rw_sect_max - rw_sect_min + 1`，还有可能是`FSBUF_SIZE >> SECTOR_SIZE_SHIFT`。若是后者，会循环多次。

不知道怎么解释这句：`fs/read_write.c#do_rdwt`中的`int bytes = min(bytes_left, chunk * SECTOR_SIZE - off);`。

耗时49分。

### 2021-07-05 15:32

说清楚了`fs/read_write.c#do_rdwt`中的`int bytes = min(bytes_left, chunk * SECTOR_SIZE - off);`。

精神很不好。耗时18分。

搞错了。目前，并不需要先写出`do_rdwt`函数。

### 2021-07-05 17:33

看`hd.c#hd_rdwt`。在小细节受阻。迟迟未能前进一步。非常沮丧。

难点在哪里？

1. 理解不了小细节。
2. 近似抄袭。
   1. 理解于上神的全部的代码，复述出这个函数，然后，自己写出来。这就是所谓的写操作系统。
   2. 现有功能，我都是这么写出来的。但那个时候，不是一个函数一个函数地写，而是以完整功能为单位写。
   3. 现在为什么不能像之前那样做？现在的功能，有点复杂。

耗时40分。

不能总这个样。今天，必须写完mkfs。否则，要到猴年马月才能写完最后的两大功能。

### 2021-07-05 17:33

看`hd.c#hd_rdwt`。什么感觉？沮丧。

两大障碍：

1. 细节。
   1. `assert((pos >> SECTOR_SIZE_SHIFT) < (1 << 31));`。
      1. 仍然不理解啥意思。
      2. 注意pos的数据类型。
   2. `assert((pos & 0x1FF) == 0);`。
2. 延迟。
   1. `interrupt_wait();`。
   2. `waitfor(STATUS_DRQ, STATUS_DRQ, HD_TIMEOUT)`。

耗时1小时23分。

为啥花了这么多时间？

大量时间，都是无效时间。当我理解不了的时候，不知道从哪里着手去理解，看着看着，有时突然就理解了。

### 2021-07-05 21:32

理解下面的语句。

```c
// file：/home/cg/yuyuan-os/osfs09/j/kernel/hd.c
PRIVATE void hd_rdwt(MESSAGE * p)
{
  		// some code
  		// sect_nr就是LBA地址。
        u32 sect_nr = (u32)(pos >> SECTOR_SIZE_SHIFT); /* pos / SECTOR_SIZE */
        // 根据次设备号找出硬盘分区信息中对应的逻辑分区号。
        int logidx = (p->DEVICE - MINOR_hd1a) % NR_SUB_PER_DRIVE;
        // 1. 计算出绝对LBA地址。
        // 2. 绝对LBA地址 = 主扩展分区的LBA地址 + 偏移量。
        // 3. 下面的语句中，表面上看起来，绝对LBA地址 = 逻辑分区的LBA地址 + 偏移量。
        // 4. 实际上，也是符合第2点中的计算公式的。
        // 5. 在第3点中，偏移量是相对于逻辑分区的偏移量，而逻辑分区的LBA地址，就是逻辑分区相对于
        //      主扩展分区的绝对LBA地址。
        // 6. 还有一个疑问：偏移量相对于逻辑分区还是主扩展分区是如何判断的？
        // 7. 解答在fs/read_write.c#do_rdwt中的
        //      int rw_sect_min=pin->i_start_sect+(pos>>SECTOR_SIZE_SHIFT)
        //      上面的注释。
        sect_nr += p->DEVICE < MAX_PRIM ?
                hd_info[drive].primary[p->DEVICE].base :
                hd_info[drive].logical[logidx].base;
  		// some code
}
```

思考过程很有条理，我比较满意。

仍然面临老问题：怎样才能不是抄袭于上神的操作系统而是自己写呢？我的做法：看懂每行代码，尽量记住代码逻辑，然后，自己写出来。

耗时1个小时16分。