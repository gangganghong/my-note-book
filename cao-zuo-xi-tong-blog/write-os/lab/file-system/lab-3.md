# 编码建立文件系统

## 代码位置

/home/cg/os/pegasus-os/fs/v2

## 流程

建立文件系统，实质是把一些数据结构写入到硬盘中。

需要先写好一些方法。

梳理一下流程，也不是完全的流程。在梳理的过程中，看看需要先写好哪些方法。

流程如下：

1. 数据结构。
   1. 超级块。
      1. 有一个成员，安装文件系统的分区的扇区数量。通过IPC用硬盘驱动获取。
      2. 硬盘驱动需增加`IOCTL`方法，从硬盘分区信息中获取主扩展分区的大小。
   2. inode-map。
   3. sector-map。
   4. inode-array。
   5. 根目录。
2. 上面的每个数据结构都要写入硬盘。
   1. 写入硬盘由硬盘驱动完成。硬盘驱动需要实现读写方法。
   2. 文件系统通过IPC请求硬盘驱动读写硬盘。
   3. 在文件系统中，使用一个函数实现读写硬盘功能。
   4. 在文件系统中，读写硬盘的函数需要很多参数，使用两个宏函数（读和写）封装这个函数。

## 优化IPC

目前，IPC不支持中断。我使用自旋锁实现延迟。

暂时不优化IPC，比较难。

不优化不能做其他工作，才优化；完成其他工作后，再优化。

## 获取分区的扇区数

### 硬盘驱动

仿照打开硬盘的代码框架，增加“GET_HD_IOCTL"。

不必写思路。太简单。

### 文件系统

思路很简单。不写。

### 难点

不解决IPC回访问题，无法运行其他功能。

两种方案：

1. 先解决IPC回访问题。
2. 先写好其他功能，但是不测试。

使用第2个方案。

## 读写硬盘

### 硬盘驱动

#### 疑问

##### `port_read(REG_DATA, hdbuf, SECTOR_SIZE);`

当硬盘中的数据不足一个扇区时，port_read函数也读取一个扇区的数据。这会出现问题吗？

假设硬盘的容量是X个扇区，

1. 从X-1个扇区的位置读取一个扇区的数据，能正常读取。
2. 从X个扇区的位置读取一个扇区的数据，不能正常读取。

我担忧什么？担忧硬盘中的数据不足一个扇区时，会把硬盘中不是目标数据的数据读取出来。

什么是目标数据？从硬盘的指定位置开始，一个扇区内的数据都是目标数据。只会存在剩余数据是否有一个扇区大小的问题，而不会存在剩余数据是不是目标数据的问题。

再讨论：硬盘的剩余数据不足一个扇区会出现什么结果？

硬盘，具体说，安装了文件系统的硬盘的逻辑分区，大小是整数个扇区。如果用扇区为单位去读硬盘，在读取之前，剩余的扇区数量一定是N个扇区。N的取值范围是`[0, 逻辑分区的扇区数量]`。

只需要讨论：

1. 当逻辑分区的扇区数量是5个，逻辑分区的第1个扇区的LBA地址是0，最后一个扇区即第5个扇区的LBA地址是4。
2. 读取逻辑分区的第1个扇区，指定初始地址是0。
3. 读取逻辑分区的第5个扇区，指定初始地址是4。
4. 指定初始地址是5，读取逻辑分区的第多少个扇区？
   1. 这是硬盘会考虑的事情，我管不了。我可以测试一下，会读取到什么。
   2. 逻辑分区的最大LBA地址是4，指定初始地址是5，这是非法的。
5. 问题消失了。

##### port_write(REG_DATA, la, bytes);

~~要写入硬盘的数据不足一个扇区时，会出现问题吗？~~

~~为什么不和读硬盘时一样、总是读取一个扇区呢？~~

~~因为，会写入脏数据。~~

在硬盘驱动中，写硬盘时，起点是`512*N`，要写入的数据的大小也是`512*N`。

为什么？这是由文件系统调用硬盘驱动时传递的参数决定的。硬盘驱动只负责以扇区为单位读写硬盘。

可是，实际读写文件时，读写文件的位置不总是`512*N`，读取或写入的数据的大小也不总是`512*N`。

吃午饭时，想明白了怎么理解“读写硬盘时单位是非整数扇区”问题。

假设，从LBA是N的扇区开始，读取M个扇区。

怎么确定M的值呢？把LBA是N到LBA是（N+M-1)的扇区都读取到内存中。要操作的数据（读或写）在这些扇区的范围内。

为什么这样说？不好说。画一张简单的图，就能明白。

| LBA/POS | N               | pos               |                 |      | M               | pos_end           |                 |
| ------- | --------------- | ----------------- | --------------- | ---- | --------------- | ----------------- | --------------- |
| 扇区    | 扇区的初始位置N | 扇区中的某个位置N | 扇区的结束位置N |      | 扇区的初始位置M | 扇区中的某个位置M | 扇区的结束位置M |
|         |                 |                   |                 |      |                 |                   |                 |

读取的数据A是：`扇区的初始位置N`到`扇区的结束位置M`。实际需要的数据B是：`扇区的某个位置N`到`扇区的某个位置M`。

A数据是不是包括了B数据？是！

先从硬盘中读取A数据，再进行读写操作。

1. 读。
   1. 从A数据中获取B。
   2. 这很简单。
   3. 从A数据的offset开始读取len个字节的数据。
   4. offset是什么？是`pos%512`。
   5. len是什么？要读取多少字节数据，len就是多少。
2. 写。
   1. 假设要写入硬盘的数据是C。
   2. 用C填充A中的B。也就是，从A的offset开始，把C数据复制到B的范围。
   3. 把A写入硬盘。

###### min(bytes_left, chunk * SECTOR_SIZE - off);

`fs/read_write.c#do_rdwt`中的`int bytes = min(bytes_left, chunk * SECTOR_SIZE - off);`。

在文件系统的`do_rdwt`中，数据读写单位是fsbuf吗？不一定。数据读写单位一定是`chunk * SECTOR_SIZE`。

读数据，`phys_copy((void*)va2la(src, buf + bytes_rw),(void*)va2la(TASK_FS, fsbuf + off),bytes);`。

写数据，`phys_copy((void*)va2la(TASK_FS, fsbuf + off),(void*)va2la(src, buf + bytes_rw),bytes);`。

如果bytes超过`chunk * SECTOR_SIZE - off`，没有意义，而且，可能有副作用。

先看读。

1. 只读取了`chunk * SECTOR_SIZE`字节数据到fsbuf中。
2. 从fsbuf的off字节开始复制数据。
3. 只复制剩余的`chunk * SECTOR_SIZE - off`字节数据都是硬盘中的数据。
4. 如果复制`chunk * SECTOR_SIZE - off + 1`字节数据，那么，最后1个字节的数据不是来自硬盘，而是内存中的固有的随机数据R。
5. R数据显然不是我们要读取的目标数据。

再看写。

1. 只写入`chunk * SECTOR_SIZE`字节数据到硬盘。
2. 如果复制到`fsbuf+off`的数据超过了`chunk * SECTOR_SIZE - off`字节，这些数据将不会写入硬盘。

### 文件系统

## 计算逻辑分区数组索引

这个问题，把我难倒了。

根据次设备号，计算逻辑分区数组索引。

写详细点，否则，时间长了，就不看不懂了。

打开硬盘后，我把硬盘分区信息存储在全局变量`hd_info`。

```c
struct hd_info{
  	primary_part[4];
  	logical_part[64];
};
```

我的难题是：根据次设备号计算`hd_info.logical_part`数组的索引。

看了`partition`函数中`hd_info.logical_part`数组的索引的计算方法后，我找到答案了。如其说找到了答案，倒不如说我通过心算理解了于上神的计算方法。计算公式是：
$$
逻辑分区数组索引 = (次设备号-16)/64
$$


## 数据结构

尽量不看书和作者的代码。写代码时，文件系统需要什么样的数据结构（数据结构需要哪些成员），就建立什么样的数据结构。实现文件系统不需要的成员，就不添加到数据结构中。

文件系统的数据结构放在哪个头文件？

文件系统的数据结构只在文件系统中使用吗？

我都不清楚。先写吧。边写边改。

### 超级块

### inode

### dir_entry

### file_desc

## 文件系统中的读写硬盘函数

### rd_wt

通过IPC调用硬盘驱动中的`hd_wt`。

函数原型：`void rd_wt(int pos, int device, int buf, int len, int type)`。

### 两个宏

把这两个宏放在哪个文件？

目前，我只知道在文件系统中会用到。暂时，只需保证在文件系统中能使用就行。

这个问题，其实并不难回答。有多少个模块，一个个考察，看是否用到这个宏。

不必在这种问题上浪费太多时间。

自己写项目当然可以这样。可是，在一些要求动手前把全部细节确定下来的地方，就没有这样自由了。

宏的参数怎么确定？

#### RD_SECT

宏的参数。

1. type。在替换表达式中。
2. buf。全局变量。在替换表达式中。
3. len。在替换表达式中。
4. device。
5. pos。

#### WT_SECT



## mkfs

为文件系统填充数据，然后写入硬盘。这是工作量最大的部分。

开始写吧。尽管，文件系统需要用到的数据结构可能不完善。

在根目录中，不初始化终端。目前，没有用到，不想增加难度。

mkfs，需要做什么？

为每个小功能设定一个难度系数吧。最高难度是5。

### super block

难度系数：1。

填充好超级块的数据，然后调用`WT_SECT`写入硬盘。

ROOT_DEV 是安装文件系统的分区的次设备号。

如何确定ROOT_DEV的值？

```c
[root@localhost v2]# fdisk -l 80m.img
Disk 80m.img: 79.8 MiB, 83607552 bytes, 163296 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xd7f3d6ef

Device     Boot  Start    End Sectors   Size Id Type
80m.img1            63  20159   20097   9.8M 83 Linux
80m.img2         20160 163295  143136  69.9M  5 Extended
80m.img5   *     20223  60479   40257  19.7M 99 unknown
80m.img6         60543  90719   30177  14.8M 83 Linux
80m.img7         90783 133055   42273  20.7M 83 Linux
80m.img8        133119 161279   28161  13.8M 83 Linux
80m.img9        161343 163295    1953 976.5K 83 Linux
```

`Id`是`0x99`，意思什么？

我的文件系统将安装在这个分区吗？如果是，次设备号是多少？是(hda1 + 16)。

#### 疑问

本分区只容纳N个文件，若本分区容纳N个文件后还有剩余空间，岂不是浪费了空间？

不理会。

精心设计文件大小和数据结构的大小就能解决这个问题。

### inode-map

难度系数：2。

第0个bit，保留位。

第1个bit，根目录使用。

这个区域，只有1个扇区，对于第1个字节，需要特殊处理，其他字节的每个bit，都设置成0。

调用`WT_SECT`的两个参数，怎么确定？

1. 第一个参数，次设备号，ROOT_DEV，very easy.
2. 第二个参数，写入inode-map的位置。仍然很easy。1(boot sector)+1(super block)。

#### 难点

512个字节，第一个字节的前2个bit设置成1，其他的bit设置成0。怎么实现这个功能？

> 写操作系统，好像也没太大难度啊。写CRUD，调用数据库、调用Redis、调用各种框架，洋洋洒洒一出手就是几百行，开口闭口就是这架构那架构。可写操作系统，只是实现上面这样细小的功能。很困惑。

不难。

```c
c = 0x3;
Memcpy(fsbuf, 0x3, 1);
Memcpy(fsbuf + 1, 0, 511);
```

### sector-map

难度系数：3。

#### 界定问题

初始化文件系统，使用了几个扇区？

初始化文件系统，数据区域只有根目录这个文件。根目录占用多少个扇区？

根目录也是一个文件，每个文件占用的扇区数量是固定的。根目录也是一个普通文件吗？如果是，根目录占用的扇区数量也是固定的。

是否把根目录设计成普通文件，这由我决定。

每个根目录项占用多少字节？16个字节。

每个普通文件占用多少个扇区？2048个扇区。这是我规定的。

一共有多少个文件？4096个。

需要多少个目录项？4096个。

4096个目录项占用多少个扇区？`4096*16/512 = 128`。根目录使用不完分配给它的2048个扇区。

> 上述思考过程，需要笔算，心算，我可能不能如此清晰地计算出结果。

新建“根目录”这个文件，从数据区域的第一个扇区开始，占用2048个扇区，需要多少个字节记录？2048/8=256。

把sector-map写入硬盘，要实现这个功能：

1. 把sp.cnt_of_sector_map_sect个扇区写入硬盘。
2. sp.cnt_of_sector_map_sect个扇区的前256个字节是0xFF。
3. 再具体一些。sp.cnt_of_sector_map_sect个扇区中的第一个扇区的前256个字节是0xFF，剩余所有的bit都是0。

界定问题，耗时28分。

#### 解决问题

##### 第一个扇区

第一个扇区怎么处理？

difficult.

```c
// Memset(fsbuf+pos*SECTOR_SIZE, 0xFF, SECTOR_SIZE>>1);
// Memset(fsbuf+pos*SECTOR_SIZE+SECTOR_SIZE>>1, 0xFF, SECTOR_SIZE>>1);
Memset(fsbuf, 0xFF, SECTOR_SIZE>>1);
Memset(fsbuf+SECTOR_SIZE>>1, 0, SECTOR_SIZE>>1);
WT_SECT(ROO_DEV, pos);
```

难点是确定pos。

pos是什么？开始写入sector-map的位置。1（引导扇区）+ 1（超级块）+ 1 (inode-map)。

##### 剩余扇区

剩余扇区怎么处理？

easy.

```c
for(int i = 1; i < 剩余扇区数量; i++){
  	//Memset(fsbuf+i*SECTOR_SIZE, 0, SECTOR_SIZE);
  	Memset(fsbuf, 0, SECTOR_SIZE);
  	WT_SECT(ROO_DEV, pos + i);
}
```

$$
剩余扇区数量 = sp\\.cnt\_of\_sector\_map\_sect - 1
$$

耗时33分。

> 和于上神的同功能代码似乎很不同，但我的代码，似乎没问题。

### inode-array

难度系数：3。

#### 界定问题

1. inode-array区域只有一个inode。这个inode对应根目录。
2. 向硬盘写数据仍然以扇区为单位。
3. 没有思路。和上面的map，是不同类型的问题。
4. 一个扇区不可能只存储一个inode。
5. inode应该写入inode-array的哪个位置，能够确定。确定后，读取包含这个位置的扇区。
6. 一个inode的大小是16字节，一个扇区包含多少个inode？512/16 = 32个。
7. 一个扇区包含32个inode。
8. inode-map中的索引 / (32) = 扇区数量
9. inode-map中的索引 % (32) = inode数量*16
10. 先用`RD_SECT(ROOT_DEV, 扇区数量)`读取一个扇区。我将把inode写入这个扇区。
11. 写入inode的位置是`fsbuf + inode数量*16`。
12. 再把写入了inode后的fsbuf写入硬盘，使用`WT_SECT(ROOT_DEV, 扇区数量)`。
13. 最关键的是第8、第9点。
14. 考虑了这么多，其实，在初始化inode-array、只写入第一个inode时，根本不需要考虑这么多。因为，写入第一个inode，一定是从inode-array的最开始位置写入。

耗时28分。

#### 解决问题

### 根目录

难度系数：2。

根目录中只有一个目录项。

怎么写入硬盘？

初始位置，能确定。

很简单。





## C代码

```c
#include <stdio.h>

int main(int argc, char **argv)
{
        //int a = 1 << 31;
        unsigned int a = (1 << 31);
        printf("a = %d\n", a);


        unsigned long long pos = 512;
        printf("pos >> 9 = %llu\n", pos >> 9);
        printf("1 << 31 = %llu\n", 1 << 31);
        if((pos >> 9) < (1 << 31)){
                printf("res = %d\n", 1);
        }else{
                printf("res = %d\n", 0);
        }

        return 0;
}
```

这段代码的价值：

1. 数据类型。`pos`是` unsigned long long`，`pos >> 9`也是` unsigned long long`。
2. 打印` unsigned long long`类型数据使用`%llu`。

## 小结

### 2021-07-05 06:18

编码建立文件系统需要做哪些工作，梳理清楚了。

有点开心，终于要开始在硬盘上建立文件系统了，不是完全抄写于上神的代码，自己知道该怎么做。

耗时39分。

毫无紧张感，速度应该再快些。

### 2021-07-05 06:42

增加"GET_HD_IOCTL"，耗时22分。

复制粘贴，写操作系统也存在这样的工作。

由于IPC不能多次使用，无法先运行"HD_OPEN"，再运行”GET_HD_IOCTL"。

### 2021-07-05 12:14

写硬盘读写函数时无思路，看于上神的代码，又有许多不理解的地方。

时间消耗在理解`kernel/hd.c#hd_rdwt`。

疑问在上面的`读写硬盘#硬盘驱动#疑问`。

耗时58分钟。

又看了11分钟。看`fs/read_write.c#do_rdwt`。

里面有我以前写的注释。

哪些代码写了注释，哪些没有写，我没有记录，现在也不记得。消耗那么多时间的学习成果，不该这么轻易扔掉。

记忆力可能下降了，不写笔记，会做更多无用功。

我若记得这个函数，不会在`hd_rdwt`受阻那么久。

在`do_rdwt`中，硬盘读写是以扇区为单位的，在`hd_rdwt`中，读写硬盘的初始位置，必定是某个扇区的初始位置，不会是不足一个扇区的位置。

### 2021-07-05 13:44

读文件系统和硬盘驱动读写硬盘的代码。费劲。耗时29分。

让我费解的问题是：非整扇区数据的读写问题。

### 2021-07-05 15:03

时间主要消耗在`fs/read_write.c#do_rdwt`中的`int bytes = min(bytes_left, chunk * SECTOR_SIZE - off);`。

另外，这个函数中的循环，不是多余的。

因为，`int chunk = min(rw_sect_max - rw_sect_min + 1,FSBUF_SIZE >> SECTOR_SIZE_SHIFT);`。

chunk不是我认为的总是`rw_sect_max - rw_sect_min + 1`，还有可能是`FSBUF_SIZE >> SECTOR_SIZE_SHIFT`。若是后者，会循环多次。

不知道怎么解释这句：`fs/read_write.c#do_rdwt`中的`int bytes = min(bytes_left, chunk * SECTOR_SIZE - off);`。

耗时49分。

### 2021-07-05 15:32

说清楚了`fs/read_write.c#do_rdwt`中的`int bytes = min(bytes_left, chunk * SECTOR_SIZE - off);`。

精神很不好。耗时18分。

搞错了。目前，并不需要先写出`do_rdwt`函数。

### 2021-07-05 17:33

看`hd.c#hd_rdwt`。在小细节受阻。迟迟未能前进一步。非常沮丧。

难点在哪里？

1. 理解不了小细节。
2. 近似抄袭。
   1. 理解于上神的全部的代码，复述出这个函数，然后，自己写出来。这就是所谓的写操作系统。
   2. 现有功能，我都是这么写出来的。但那个时候，不是一个函数一个函数地写，而是以完整功能为单位写。
   3. 现在为什么不能像之前那样做？现在的功能，有点复杂。

耗时40分。

不能总这个样。今天，必须写完mkfs。否则，要到猴年马月才能写完最后的两大功能。

### 2021-07-05 17:33

看`hd.c#hd_rdwt`。什么感觉？沮丧。

两大障碍：

1. 细节。
   1. `assert((pos >> SECTOR_SIZE_SHIFT) < (1 << 31));`。
      1. 仍然不理解啥意思。
      2. 注意pos的数据类型。
   2. `assert((pos & 0x1FF) == 0);`。
2. 延迟。
   1. `interrupt_wait();`。
   2. `waitfor(STATUS_DRQ, STATUS_DRQ, HD_TIMEOUT)`。

耗时1小时23分。

为啥花了这么多时间？

大量时间，都是无效时间。当我理解不了的时候，不知道从哪里着手去理解，看着看着，有时突然就理解了。

### 2021-07-05 21:32

理解下面的语句。

```c
// file：/home/cg/yuyuan-os/osfs09/j/kernel/hd.c
PRIVATE void hd_rdwt(MESSAGE * p)
{
  		// some code
  		// sect_nr就是LBA地址。
        u32 sect_nr = (u32)(pos >> SECTOR_SIZE_SHIFT); /* pos / SECTOR_SIZE */
        // 根据次设备号找出硬盘分区信息中对应的逻辑分区号。
        int logidx = (p->DEVICE - MINOR_hd1a) % NR_SUB_PER_DRIVE;
        // 1. 计算出绝对LBA地址。
        // 2. 绝对LBA地址 = 主扩展分区的LBA地址 + 偏移量。
        // 3. 下面的语句中，表面上看起来，绝对LBA地址 = 逻辑分区的LBA地址 + 偏移量。
        // 4. 实际上，也是符合第2点中的计算公式的。
        // 5. 在第3点中，偏移量是相对于逻辑分区的偏移量，而逻辑分区的LBA地址，就是逻辑分区相对于
        //      主扩展分区的绝对LBA地址。
        // 6. 还有一个疑问：偏移量相对于逻辑分区还是主扩展分区是如何判断的？
        // 7. 解答在fs/read_write.c#do_rdwt中的
        //      int rw_sect_min=pin->i_start_sect+(pos>>SECTOR_SIZE_SHIFT)
        //      上面的注释。
        sect_nr += p->DEVICE < MAX_PRIM ?
                hd_info[drive].primary[p->DEVICE].base :
                hd_info[drive].logical[logidx].base;
  		// some code
}
```

思考过程很有条理，我比较满意。

仍然面临老问题：怎样才能不是抄袭于上神的操作系统而是自己写呢？我的做法：看懂每行代码，尽量记住代码逻辑，然后，自己写出来。

耗时1个小时16分。

### 2021-07-06 05:34

写完`hd_rdwt`的伪代码。比较顺利。耗时33分。

### 2021-07-06 11:00

把`hd_rdwt`的伪代码改写成正式代码。

没有领域知识，难点在于，在项目已有代码的基础上写代码：

1. 完善Message结构体。几个月前看到于上神设计的Message，不明白；现在，我有了需求，知道怎么设计它了。---- 想了一会，时间实际消耗不多。
2. 求变量的线性地址，即写`v2l`函数。我记得项目中有相关函数，但我找了很久才找到它们的具体位置。看到求进程基地址的函数，又不理解了。------- 主要时间消耗点，找代码，如何写成和于上神的代码相似。

耗时1小时33分。

为什么花这么多时间？

看上面两点后面的说明。

补充。我认为，找原来的代码，花了很多时间。

做的事情，花了多少时间，只能猜测。怎么避免？时间记录的粒度要更细！

### 2021-07-06 12:03

把`hd_rdwt`的伪代码改写成正式代码，写调用`hd_cmd_out`代码。

复制粘贴，修改参数。

耗时15分。

### 2021-07-06 12:25

计算逻辑分区数组索引。

稍微遇到点麻烦，原因是心算错误。

耗时22分。

为什么会耗费22分钟？记得于上神的代码片段，但心算后，觉得他的代码不正确。无条理地犹豫了一会儿。这消耗了最多时间。

如果知道怎么做，写一行代码，然后复制粘贴，应该只需消耗四五分钟。

除了`wait_for`和`interrupt_wait`，`hd_rdwt`函数已经比较完善了。

下一步，到文件系统中写请求`hd_rdwt`的函数和`mkfs`。文件系统终于快要写入到硬盘中了。

### 2021-07-06 13:44

写文件系统用到的数据结构。写出来的东西残缺不全，我不记得了。

边写代码边补充吧。实在想不起来，看于上神的代码。

耗时35分钟。

### 2021-07-06 18:04

写文件系统用到的数据结构。尽力了。我写出了我会用到的数据结构的成员。

耗时33分。

### 2021-07-07 08:11

写完文件系统中的`rd_wt`，正确性未知。用到了IPC，不好测试，因为IPC有问题。工作量是复制粘贴，不过要明白系统进程的pid是多少。

耗时22分。能再快些：1. 适度紧张；2.不散步、喝水、想琐事。

### 2021-07-07 08:50

写封装文件系统中的`rd_wt`的宏：

1. 把宏放在哪个文件？
2. 宏参数是什么？
3. 上面两项，耗时15分。有条理地思考，我比较满意。
4. 写完了宏。毫无难度，不必思考。正确性未知，没有测试。耗时12分。

总计耗时31分。

终于要写mkfs了。可我设计的文件系统数据结构不完整。现在，我有两个选择：

1. 看于上神的代码，把数据结构补充完整。
2. 按照目前的设计，去写mkfs。在写的过程中，如果发现缺少了某些成员，再补上。

我更想选择第2个。因为，这很像真正在写操作系统，但是，进度会很慢。

### 2021-07-07 10:46

向硬盘写入`super block`。耗时55分。

时间消耗在确定超级块数据结构的成员的值，写笔记。详情见代码`/home/cg/os/pegasus/fs/v2/fs/fs_main.c#mkfs`。

还算正常。我不知道怎么再加快速度。打字再快些？

### 2021-07-07 11:19

向硬盘写入`inode-map`。耗时29分。主要时间消耗在思考。

和记忆中的于上神的代码大大不同，我的代码，简化了很多很多。

### 2021-07-07 14:11

向硬盘写入`sector-map`。耗时1个小时01分。

做的事情：

1. 界定问题。
2. 想出解决问题的方案。

### 2021-07-07 18:44

向硬盘写入`sector-map`。照着之前想出的方案写代码。耗时13分。

### 2021-07-07 19:42

向硬盘写入inode-array。耗时52分。

1. 界定问题。耗时28分钟。有点费劲。
2. 写代码。耗时24分。

偏移量，这些东西，我很烦。

### 2021-07-07 21:57

向硬盘写入根目录。耗时30分。

时间消耗点，怎么设置`dir_entry.filename`，具体说，设置字符数组时，要不要添加末尾的`0`。