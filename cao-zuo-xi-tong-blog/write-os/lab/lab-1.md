# 从实模式到保护模式

## 环境

### 项目路径

物理机：/Users/cg/data/code/os/pegasus-os

虚拟机：/home/cg/os/pegasus-os

不用freedos调试，理由如下：

1. 我不知道怎么在freedos下断点调试。
2. 已经拥有读入内核并运行内核的功能，不需要使用freedos。

## 怎么做

切换到保护模式的步骤：

1. 打开A20
2. 设置cr0的pe位
3. 跳转语句

怎么证明已经成功切换到了保护模式？

实模式下，内存寻址方式是：段地址 + 段偏移量。

寄存器是16位的，地址总线是20位的，为了充分利用20位的地址总线的寻址能力，将段地址右移4位，段地址变为20位。

20位的二进制能表示的最大数是2的20次方-1。20位能表示的内存地址是2的20次方（保护第0个内存单位），是1M。

16位能表示的内存单位是2的16次方，1024 * (2的6次方) = 64kb。

一个段的最大长度由段偏移量决定，所以，实模式下，一个段的最大内存只有64kb。

烦啊。原来，我对这个知识点并没有想象中的那么熟悉。

能寻址的最大内存地址由地址总线决定。地址总线是20位的。能寻址的最大内存地址是2的20次方-1。无论“段地址+段偏移量”如何组合，都不能突破这个限制。因此，实模式下，能寻址的最大内存地址是`1M-1`，能寻址的内存容量是`1M`。因为，内存容量计算的初始值是0。

在实模式下能使用2M以上的内存吗？

我的回答，不能。20位地址总线无法传输1M以上的内存地址。

实模式下，有什么限制？

1. 每个段的长度不能超过64Kb。
2. 能使用的内存不能超过1M。

怎么证明，当前所处的模式不是实模式而是保护模式？

1. 段的长度能超过64kb。
2. 段的基地址在1M以上，比如2M。

第1点，没有想到更好的测试方法。暂时这样测试：把段界限设置成1M。可是，偏移量怎么设置成超过65Kb？

~~这样做，重复70kb，然后，在这之后声明标量，跳转到这个标量。~~

```assembly
jmp dword SelectFlatX:(BaseOfLoaderPhyAddr + LABEL_PM_START)
```

`BaseOfLoaderPhyAddr + LABEL_PM_START`已经超过64kb了。

第2点，非常容易测试。

段基址直接设置成2M。

测试步骤如下：

1. 读取这个段的0偏移量的数据。
2. 向这个段的0偏移量位置写入数据'A'。
3. 再读取这个段的0偏移量的位置，检查数据是多少？

读，使用`lodsb`把数据从`[es:si]`加载到`ax`中。

写，直接使用`mov [es:si], ax`可以吗？可以。

```assembly
; 测试读写5M之上的内存读写 start
push es
mov ax, SelectFlatWR_TEST
mov es, ax
mov esi, 0
mov edi, 0
xchg bx, bx
mov byte [es:edi], 'W'
mov byte al, [es:edi]
mov ah, 0Ah
mov [gs:(80*20 + 20) * 2], ax

mov byte [es:edi], 'Q'
mov byte al, [es:edi]
mov [gs:(80*20 + 21) * 2], ax

pop es
; 测试读写5M之上的内存读写 end
```



### GDT宏

没有难度。我没有记下来，但是，让我对照书上的结构图，能很轻松写出GDT宏的结构。

### 切换到保护模式

没有难度。我没有记下来。

编程时，没有必要记下来每个API。同理，这种固定的套路，也没有必要记住。

### 设置GDT

有点费劲。

用宏创建GDT时，使用三个参数，分别是段基址、段界限、段属性。所有描述符的段基址都设置成0，在后面通过直接改写描述符对应位的方式修改为实际的段基址。段基址是标号。

我不理解，为什么使用宏创建描述符时不直接使用这些段基址标号创建描述符？

回答不了这个问题。我会直接测试：用宏创建描述符时，段基址参数设置为标号。

先弄清楚，怎么修改描述符的段基址？

段基址分布在描述符的几个不同的位，把段基址转化成X为（例如32位），然后依次放置到描述符的这些位置就行了。

由于我不记得段描述符的格式，需要看书。

需要把书中的段描述符的格式记住吗？

不知道。如果看一眼就能记住，那多好。

时间充足，需要记住。

可是，我的时间被消耗在哪里了？这三天，消耗在无用资讯和焦虑上了。

### 创建GDT和选择子

创建全局描述符，很费劲。费劲点在描述符属性。我没有记住属性，之前花了很多时间，似乎理解了属性这块。

关于属性，特别费劲的一点是，是否需要向于上神那样把所有用到的属性都写出来。能写出那些属性，需要全局视野。我不具备，边写边拼凑吧。

选择子，我们所看到的代码，是全局描述符的标号减去空全局描述符；如果对属性有要求，需再加上属性。

### 加载GDT

使用`lgdt [GdtPtr]`。

`GdtPtr`的结构，记得不清楚。大概是第一个描述符的地址 + GDT的界限。

看书上的结构图，很容易写出来。

理解和记忆是两回事。

记忆并不总是需要理解。我所使用的每个汉字，是死记硬背学会的。

一想到我还有那么多操作系统实验要做，就沮丧。早知如此、明知如此，为啥要浪费时间呢？

”觉得事情太多“，这种负面情绪和焦虑一样，阻碍我完成事情。

事虽多，日日做，总会有做完的那一天。

我的计划是，做完所有操作系统实验之后，再写操作系统时，直接把通过测试的代码复制过去。

### 代码分布

这个标题不知道是否恰当。本小节要说的问题是，怎么使用`section、bits 16、align 32`等。，

`section`，增加代码的可读性，无其他意义。什么叫增加代码的可读性？实现一个功能的汇编代码，全部连在一起，阅读源码时，分不清哪块是干什么的。有了`section`，就会让读者一目了然。

`bits 16`。首先，我没有掌握这个伪指令的语法，需要加中扩号吗？

这个指令的作用，设置一个范围内的代码的编译模式是16位的。一个范围是指，从当前bits指令到下一个bits指令之间的代码。

在实模式下，汇编代码默认被当做16位编译。

在保护模式下，汇编代码默认被当做32位编译。在保护模式下，使用`[BITS 16]`表示这段代码需要被当做16位执行。通过在指令前面加上前缀达到这种识别效果。

这个前缀，被叫做反转前缀。什么叫反转？在默认16位模式下，遇到指令带有反转前缀，这些指令会被当做32位指令处理；在默认32位模式下，遇到指令带有反转前缀，这些指令会被当做16位指令处理。

## 写代码

写了上面那么多，已经基本扫清了全部理论障碍，下面，该写代码了。

本节，记录在写代码过程中遇到的一切问题。

悲剧啊！

自己前阵子写的汇编代码，刚写出来的时候，和白话文一样容易懂，要看哪里就好像使用自己的手指一样容易。放了这么长时间，我发现，我看不懂了，找不出问题在哪里，不知道那么多`v3、v4、v5、v6`的目的是什么。

<bochs:4> xp /1wx 0x9000:0x100
[bochs]:
0x0000000000090100 <bogus+       0>:	0x6f006c41

xp /1wx 0x0000:0xe7d0d

lodsb al, byte ptr ds:[si]

从实模式进入保护，我之前已经实现过了。

已经实现过的功能，就不再重复实现了。再写一次，也不会让我记住更多。

理解，记忆，是两件事情。

做出来后，通过反复看或多次写文章，来强化记忆吧。

## 问题

### 内核超过64kb

很久才定位到这个原因。

无法解决，依靠曾经的印象（以前遇到过），翻看于上神的代码，找到了解决方法。

修改`es`。奇怪的是，只是将`es`增加了`4kb`。

`bx`是16位寄存器，能存储的最大值是2的16次方减去1。

`4kb`是4096，是2的12次方。

64kb是4kb的16倍，是2的16次方。

```
Next at t=49065651
bx_dbg_read_pmode_descriptor: selector (0x0008) > GDT size limit
(0) [0x00000009023b] 9000:000000000000023b (unk. ctxt): jmpf 0x0008:00090300      ; 66ea000309000800
<bochs:2> r

<bochs:3> sreg
es:0x8100, dh=0x00009308, dl=0x1000ffff, valid=1
	Data segment, base=0x00081000, limit=0x0000ffff, Read/Write, Accessed
cs:0x9000, dh=0x00009309, dl=0x0000ffff, valid=1
	Data segment, base=0x00090000, limit=0x0000ffff, Read/Write, Accessed
ss:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
ds:0x9000, dh=0x00009309, dl=0x0000ffff, valid=3
	Data segment, base=0x00090000, limit=0x0000ffff, Read/Write, Accessed
fs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
gs:0xb800, dh=0x0000930b, dl=0x8000ffff, valid=7
	Data segment, base=0x000b8000, limit=0x0000ffff, Read/Write, Accessed
ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1
tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1
gdtr:base=0x0000000000000000, limit=0x0
idtr:base=0x0000000000000000, limit=0x3ff



00014803614i[CPU0  ] [14803614] Stopped on MAGIC BREAKPOINT
(0) Magic breakpoint
Next at t=14803614
(0) [0x00000009023b] 9000:000000000000023b (unk. ctxt): jmpf 0x0008:00090300      ; 66ea000309000800
<bochs:2> sreg
es:0x8000, dh=0x00009308, dl=0x0000ffff, valid=1
	Data segment, base=0x00080000, limit=0x0000ffff, Read/Write, Accessed
cs:0x9000, dh=0x00009309, dl=0x0000ffff, valid=1
	Data segment, base=0x00090000, limit=0x0000ffff, Read/Write, Accessed
ss:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
ds:0x9000, dh=0x00009309, dl=0x0000ffff, valid=3
	Data segment, base=0x00090000, limit=0x0000ffff, Read/Write, Accessed
fs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1
	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
gs:0xb800, dh=0x0000930b, dl=0x8000ffff, valid=7
	Data segment, base=0x000b8000, limit=0x0000ffff, Read/Write, Accessed
ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1
tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1
gdtr:base=0x000000000009013e, limit=0x1f
idtr:base=0x0000000000000000, limit=0x3ff


<bochs:12> r
CPU0:
rax: 00000000_00030000
rbx: 00000000_00000600
rcx: 00000000_00040420
rdx: 00000000_0000010f
rsp: 00000000_0000ff9a
rbp: 00000000_0000ffaa
rsi: 00000000_00090000
rdi: 00000000_00030000
r8 : 00000000_00000000
r9 : 00000000_00000000
r10: 00000000_00000000
r11: 00000000_00000000
r12: 00000000_00000000
r13: 00000000_00000000
r14: 00000000_00000000
r15: 00000000_00000000
rip: 00000000_000703a4
eflags 0x00000006: id vip vif ac vm rf nt IOPL=0 of df if tf sf zf af PF cf


```







