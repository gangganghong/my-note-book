# 实现进程---保存进程快照

## 代码位置

/home/cg/os/pegasus-os/v20

## 回忆

时钟中断发生时，会为当前运行中的进程A建立一个快照，然后运行其他进程B。

这个时钟中断例程做两件事：

1. 为运行中的进程建立快照。
2. 启动另外一个进程。

### 建立快照

建立快照就是把运行当前进程时的CPU中的数据（寄存器中的数据）保存到进程表中。

CPU中的数据分成两部分：通用寄存器中的数据和段寄存器中的数据。在此分清楚两类寄存器，没有意义。

时钟中断发生时，会自动把cs、ss、esp、eflags、eip中的值压入堆栈中。可能我写漏了一些寄存器。不过，我不用应试，不必非记住它们不可。

压入哪个堆栈？时钟中断发生时，尤其是在进程运行时发生时钟中断，会发生特权级转移：从低特权级转移到高特权级。

这种转移，CPU会自动把esp指向TSS中对应的特权级的ss和esp。例如，转移目标是0特权级，那么，CPU会把ss和esp设置成TSS中的ss0和esp0。

在中断例程中，我再手工入栈剩余的寄存器，使用pushad入栈一部分，再逐个入栈剩余的寄存器中的值。

### 启动进程

下一个要运行的进程，可能是之前刚刚建立过快照的进程，也可能是更早之前被挂起的进程。

启动进程，在上一个实验，已经做过了。在本实验，只需要将esp指向目标进程的进程表。

### 中间

显然，在建立快照和启动进程之间，有一个中间过程。我想在这个中间过程打印几个字符，会修改寄存器中的值。为了还原被我修改的值，在修改一个寄存器的值前，要先把它的值放入堆栈。

建立快照的时候，使用的是被挂起的进程的进程表的堆栈。不能随意往这个堆栈中增删数据，否则，恢复进程时会出现错误。

我只能专门建立一个内核堆栈。中间代码使用这个堆栈。

启动进程时，再把esp指向目标进程的进程表的堆栈。

整个过程，使用了三类堆栈：

1. 进程的堆栈。
2. 进程表中的堆栈。
3. 内核堆栈。

进程表中的堆栈有两个：

1. 被挂起的进程的进程表中的堆栈。
2. 要启动的进程的进程表中的堆栈。

### 知识点

也是需要我做的工作。

#### 时钟中断

时钟中断打开了没有？怎么打开？

设置8259A的ICW0，把时钟中断对应的引脚设置为0。

IDT。

中断例程。

## 学习



## 写代码

1. 内核栈已经用了。
2. 检查时钟中断是否在运行。
   1. 在时钟中断中打印字符。
3. 在时钟中断例程中写代码。
4. 建立快照的代码不封装，直接写到中断例程中。
5. 跳转到启动进程的代码。

## 调试

### 时钟中断

非常不顺利。反复修改，反复运行。

时钟中断对应的中断向量号是几号？是第0号。

对照lab-6解决了时钟中断问题，要点如下：

1. 要将8259A的ICW0的第0号引脚设置为0。
2. 要在时钟中断例程后设置一个循环。
3. 时钟中断例程是hwint0。

怎么打印跳动的字符？

1. 在某个位置P写入一个字符。
2. 自增位置P处的数据。`inc byte [P]`。

## 疑问

一、进程体内的打印语句必须在一个死循环内部，否则，会出现Invalid Code异常。

