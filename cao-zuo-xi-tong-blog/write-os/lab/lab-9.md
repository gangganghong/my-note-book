# 在内核中添加中断处理--复杂版本

## 理论

### 回忆

已经成功做完了”在内核中添加中断处理“的简化版本。先复习一次简化版本实验。

1. 在内核中添加中断处理，仍然要初始化8259A。如果在loader中已经初始化了，在内核中可以不必再初始化。
2. 和GDT不同，不需要把loader中的IDT复制到内核中，而是另起炉灶，重新建立IDT。
   1. GDT不能另起炉灶。不确定是否如此。使用选择子进入内核，然后抛弃这个选择子，重建这个选择子。我不知道是否行得通。
   2. IDT能另起炉灶，也可以在loader中建立的IDT的基础上增加IDT项。
3. 修改idt_ptr。
   1. 建立两个指针分别指向idt_ptr的低2位和高4位。
      1. short *pm_idt_limit = (short *)(&idt_ptr[0]);
      2. int *pm_idt_base = (int *)(&idt_ptr[2]);
      3. 很有用的用法，如何获取数组的局部。
   2. 修改指针指向的数据。
      1. *pm_idt_limit = idt项的数量 * sizeof(Gate);
      2. *pm_idt_base = (int)(&idt);
      3. 数据类型分别是：short、int。
4. 初始化IDT项。
   1. 用指针。`Gate *gate = &idt[0]`。
      1. `Gate *gate`表示`gate`这个变量的数据类型是`Gate *`。这是一个指针数据类型，赋值必须和这个类型匹配，需要是内存地址。
      2. `gate = &idt[0]`。不加上数据类型`Gate *`，`gate`的数据类型也是`Gate *`，赋值必须和这个类型匹配。
      3. `*gate = (int)(&idt[0])`。`*`表示获取指针类型数据指向的数据。
      4. 第2、3中的语句都是正确的。我说不出理由。
   2. 中断描述符的四个组成要素分别是：
      1. 中断例程的偏移量。`typedef void (*int_handle)()` 配合中断函数名实现用函数名做偏移量。
      2. 中断例程所在的代码段的选择子。是在loader中创建的GDT中的第2个选择子（初始序号是1），选择子是0x8，不是0x1。
      3. ParamCount。0
      4. 中断描述符的属性：TYPE + 特权级。E + 8。
   3. 中断向量号和中断例程的对应关系能随便设置，可是按照大家约定的习惯设置二者的对应关系更好。
5. 用`lidt [idt_ptr]`重新加载IDT。
6. 触发中断。例如，`int 0x1`。

### 学习

#### v1

##### 任务是什么

通过lab-8实验，已经掌握了”在内核中添加中断处理“的主要知识。所谓复杂版本实验，只是为上一个版本添加细节。

添加哪些细节呢？

1. 增加更多的IDT项。约定俗成有多少个中断，就增加多少个IDT项。这是大量重复工作。
2. 中断函数使用相同的模板。
   1. 在中断函数中使用统一异常处理代码 Exception，使用jmp跳转到Exception。
   2. 在 Exception 中调用C语言编写的 ExceptionHandler 函数。
   3. 在 ExceptionHandler 中打印 eip、cs、vec_no、错误码。
   4. 打印函数是，disp_str_color，能设置打印字符的颜色。打印字符还是打印字符串？
   5. 把eip、cs、错误码等也打印出来。当字符串还是当十六进制整数还是当十进制整数打印？

没弄清的知识点：

1. 中断产生时的错误码。是CPU产生的还是开发者设置的？

难点是：

1. 打印字符串。
2. 把十六进制数转换成十进制。

*大约两个星期前，我为了理解上面的两个难点写过文章。如今，又忘记了。*

*操作系统知识似乎比编译原理容易多了，更多依赖记忆。而编译原理更多依赖理解。*

*两个多星期，我就能掌握不少操作系统知识。这说明操作系统知识没有含金量、没有难度吗？我应该继续学习吗？*

##### 攻克难点

###### 打印字符串

我能想到的方法：

1. 直接写显存逐字符打印。
2. 首个字符的打印坐标怎么确定？
3. 打印语句是：`mov [gs:edi]`。
4. 使用ecx、递增edi、递减ecx模拟循环打印全部字符。
5. ecx的初始值是要打印的字符串的长度，怎么获取字符串的长度？

###### atoi

不同于C语言内置函数`atoi`。我的`atoi`函数只把十六进制数转化成字符串。

十六进数字有两种形式：0x02 和 02h。

我处理第一种形式，0x02。

输入：0x02；输出："0x2"。

用指针p指向0x02。疑问：能用指针指向整型？

p的前两个分别指向0、x。

当前元素是0时，丢弃，做法是指针后移，却不添加整型数的元素。

当前元素不大于9，直接添加这个元素。

当前元素大于9，获取这个元素的字符串形式。方法是：

1. 计算当前元素和字符0的差diff：当前元素 - '0'。
2. 计算当前元素的字符形式：diff + ?。

只记得上面这么多了。

#### v2

##### disp_str

###### 思路

原型是：`void disp(char *str)`

算法是：

1. 用全局变量记录下一个要使用的显存地址。disp_pos。
2. 从栈中获取str。
   1. 这是一个难点。
   2. str在栈中的位置是：`[ebp + 8]`。
      1. [ebp + 0]、[ebp + 4] 分别是cs、eip。
      2. str作为函数参数，入栈的是str这个字符串的内存地址。
      3. 内存地址是32位的。栈中的每个元素所占用的空间都是相同的，都是32位、4个字节。这也是难点。差点理解错了。
      4. 把esi指向str的内存地址。
      5. 使用lodsb把esi指向的数据复制到al中。esi默认是自增还是自减？
3. 逐字节处理字符。这又是一个难点，是最大的难点。
   1. 当前字符不是回车符`0x0A`，打印它。
   2. 当前字符是回车符`0x0A`。难点出现了。
      1. 下一个字符的打印位置是：(当前行号 + 1) * 160。
      2. 当前行号的计算方法：edi除以160。
      3. 下一个字符的打印位置是：
         1. (edi / 160 + 1)*160 = edi + 160。
         2. 这个公式耗费了很多时间。
         3. 把左边的表达式展开，结果确实是 edi + 160。可是，这不符合实际结果。
         4. 想不通，搁置吧。
         5. 我这样计算：
            1. 先计算当前行号：edi / 160。
            2. 当前行号 + 1
            3. 将新行号乘以160。
      4. 处理下一个字符。
   3. 当前字符是空，函数结束。

###### 调试

花了非常多时间。

栽在这句：`mov word [dis_pos], 0`。莫名其妙地给[dis_pos]赋予了一个非零值。

试了很多次。看了于上神的代码，修改为`mov dword [dis_pos], 0`，才能正常运行。

理解不了。暂时搁置。和显存的界限有关系吗？即使和界限有关，那[dis_pos]的值也应该能被正常赋予0啊。存疑，搁置。

还有一个问题，断点调试。

我在函数disp_str内部设置断点D，函数在文件的末尾，然后在调用函数的那行代码的下面设置断点A。我期望看到：先在A断点停留，然后在断点D停留。执行时，并未在断点A停留，直接在断点D停留。

这是当然。没有遇到跳转语句，CPU从前往后执行指令，A在D的后面，执行时自然直接在D停留。函数出现的位置不等同指令位置。

###### 怎么清屏

向显存中写入空白字符。伪代码如下：

```c
for(i  0----->5){
  		for(j  0-------->160){
        	disp_str("   ");
      }
}
```

##### disp_str_color

在disp_str的基础上修改两个地方。

##### atoi

###### 思路

C语言内置函数atoi的简化版，仅仅实现下面两个功能：

1. 去掉数字开头的0。输入是0x002，输出是0x2。
2. 把十六进制数字转换成二进制字符串。输入是0x002，输出是'0000 0000 0000 0000 0000 0000 0000 0010'。

怎么把数字当字符串一样获取数字的每一位？使用位移，右移。

怎么把数字转换成二进制形式？和`0xF`做`&`运算。

怎么去掉数字开头的0？当数字是0并且在开头，不添加到结果；当数字是0但不在开头，添加到结果。

怎么处理每个数字？

1. 数字等于0。
2. 数字小于10。
3. 数字大于等于10。
   1. 只有这种情况，是所谓的难点。
   2. 数字的字符形式之间的差值和数字之间的差值，本该相同。
      1. 上面两种情况，只在`0~~9`和`10~~~15`两段之间成立。
      2. 两个不同的段的数字，字符形式的差值和数字之间的差值，不同。
         1. 例如，0的字符形式的ascii码是48，10的字符形式A的ascii码是65，二者的差值是：65-48 = 17。
         2. 而10 - 0 = 10。差值相差7。
   3. 我的目的是什么？
      1. 数字是10时，要把它变成A。
      2. 数字是15时，要把它变成F。F = 15 - 0 + 48 + diff。diff = F - 15 -48 = 70 - 15 - 48 = 7。
      3. 数字是0时，要把它变成48。48 = 0 - 0 + 48。
      4. 数字是1是，要把它变成49。49 = 1 - 0 + 48。
      5. 也许，聪明人一眼就能知道目的是什么并且知道怎么达到目的，而我需要找出这些中间过程。
   4. 实现目的的方法是：
      1. 当数字不大于9时，数字 - 0 + 48。
      2. 当数字大于9时，数字 - 0 + 48 + 7。
         1. 为什么？没有为什么。非要问，这是我根据具体数字计算出来的，就说是用”归纳法“得出的结论吧。

###### 写代码

要实现的功能：

1. 把十六进制数字转成二进制字符串
   1. 每位数字转成四位二进制字符串。
   2. 最高位若是0，丢弃。
   3. 用0x开头。

函数原型：atoi(int num)。

流程如下：

1. 创建指针变量char *p。
2. *p++ = '0'。
3. *p++ = 'x'。
4. 卡住了。num = 0，*p = 0。
5. 一个循环，循环8次。循环体是：
   1. 又是难点。十六进制数的最低位在循环体中还是外获得？
      1. 这个问题本身就不正确。
      2. 因为，我遍历十六进制数据的顺序是：从最高位到最低位。
   2. 现在的难点是，应该遍历多少次？
      1. 在32位模式下，把32位数字分拆成8组，每组是一个四位二进制数字。
      2. 达成上述目标，需要遍历8次还是7次？
      3. 心算不出来，可以懒一些。直接运行。
      4. 也可以用另外的方式。简化问题，计算出来。
      5. 怎么简化？
      6. 计算8位模式，把8位数字拆分成2组，每组是一个四位二进制数字，需要遍历多少次？
         1. 需要两次。
            1. 第一次，获取最高四位ch。右移四位。
            2. 第二次，获取最低四位ch。右移0位。
            3. 又遇到难点了。想了一会。由于不能快速心算，觉得有点痛苦。
               1. 难点是啥？每次右移的操作数是ch还是num？
               2. 是num。
               3. 如何获取低四位？
                  1. 除了位移，还要和0xF进行`&`运算。
                  2. 除了最低四位，其他所有四位，都用这种方法获取。
      7. 回答原始问题，应该遍历8次，循环条件的初始值是28，终止条件是小于0，自减步幅是4。
   3. 一些疑问
      1. 遍历顺序能从低位到高位吗？能，打印出来的数字字符是从低位到高位排列。
      2. 结果是四位一组还是8位一组？看需要。我计算出来的结果是4位一组。
      3. 结果中间加空格吗？不加。也可以加。
      4. 用指针p存储转换后的结果，p不断移动，如何获取最初的p即结果的开头？
         1. char *str; char *p = str;str是结果的开头。

aoti只把十六进制数转换成二进制字符串，不打印。打印十六进制数使用disp_int(int num)。

*上面的内容，与最终结果并不一致。等以后再写一系列与代码完全一致的笔记。*

#### v3

难点很少，弄清楚下面几个问题：

1. 约定俗成的常见中断有哪些：中断向量号和命名。
2. 错误码。中断发生时，有没有这个东西。
3. 写出异常（中断）处理函数。所有中断最终都交给这个函数把cs、eip、错误码等打印出来。
   1. 怎么在C语言中获取cs、eip？

#### 中断项

![image-20210406105713825](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210406105713825.png)



![image-20210406105749367](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210406105749367.png)

#### 知识点

已经弄清楚了中断处理函数的知识点。

1. 错误码。不是每个中断都会产生错误码。为了让有错误码和无错误码的堆栈一致，在没有中断码时手工入栈错误码`0xFFFFFFFF`。
2. 调用实际的中断处理函数 exception_handler 后，需要修改堆栈，把调用中断处理函数的两个参数移除，通过修改esp达成目标。
3. 在 exception_handler 中打印 cs、eip、中断向量、错误码、错误信息。
   1. 错误信息不能使用中文，否则会乱码。
   2. 错误信息很多，我是应该复制还是自己写？

#### 难点

1. 初始化字符串数组的方法。
2. 

## 实践



## 调试



```
<bochs:4> xp /1wx 0x30:0xff86
[bochs]:
0x000000000000ff86 <bogus+       0>:	0x0000ffc6
<bochs:5> xp /1wx 0x30:0xff8A
[bochs]:
0x000000000000ff8a <bogus+       0>:	0x000305f5
<bochs:6> xp /1wx 0x30:0xff8E
[bochs]:
0x000000000000ff8e <bogus+       0>:	0x00030a22
<bochs:7> xp /1wx 0x30:0xff96
[bochs]:
0x000000000000ff96 <bogus+       0>:	0x0000003f
<bochs:8> xp /1wx 0x30:0xff92
[bochs]:
0x000000000000ff92 <bogus+       0>:	0x0000000a

<bochs:9> sreg
es:0x0030, dh=0x00cf9300, dl=0x0000ffff, valid=31
	Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed
cs:0x0008, dh=0x00cf9b00, dl=0x0000ffff, valid=1
	Code segment, base=0x00000000, limit=0xffffffff, Execute/Read, Non-Conforming, Accessed, 32-bit
ss:0x0030, dh=0x00cf9300, dl=0x0000ffff, valid=31
	Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed
ds:0x0030, dh=0x00cf9300, dl=0x0000ffff, valid=31
	Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed
fs:0x0030, dh=0x00cf9300, dl=0x0000ffff, valid=1
	Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed
gs:0x003b, dh=0x0000f30b, dl=0x8000ffff, valid=7
	Data segment, base=0x000b8000, limit=0x0000ffff, Read/Write, Accessed
ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1
tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1
gdtr:base=0x000000000002013f, limit=0x3f
idtr:base=0x0000000000000000, limit=0x3ff
```



### disp_str_colour

耗费了2 + 4个小时，头晕。没有清晰思路，想到一种可能性就修改代码调试。

修改一下流程：

1. 切换完gdt、idt、堆栈之后，再打印字符串。

问题越来越复杂化了，我不停地修改代码然后运行，头脑已经不太清醒了，没有每30分钟休息一次。

现在，有几个问题：

1. 使用gdb不能设置断点。
2. 打印整数就出现GP错误。
3. disp_str从[ebp + 8]获取字符串地址，而disp_str_colour从[ebp+4]获取字符串地址。



gdb调试：

```
(gdb) target remote localhost:1234
Remote debugging using localhost:1234
0x0000fff0 in ?? ()
(gdb) b kernel_main.c:173
Breakpoint 1 at 0x306cf: file kernel_main.c, line 174.
(gdb) c
Continuing.

Breakpoint 1, disp_int (num=8) at kernel_main.c:174
174		atoi(str, num);


```



atoi 出了问题。

解决了atoi的问题。存储结果的字符串必须初始化，否则，会出现非常非常奇怪的结果。

现在的问题，disp_str打印的是上一次disp_str打印的数据，新的参数对它无效。

莫名其妙，问题基本都消失了。唯一的疑问是，disp_str、disp_str_colour的堆栈存储的数据[[ebp+4]、[[ebp+8]、[[ebp+12]分别是什么？cs、eip究竟有没有在执行call的时候入栈？函数堆栈又是如何被清空的？



```c
void disp_int(int num)
{
        //char *str = "";
        char str[16];
        atoi(str, num);
        //disp_str_colour("ABC", 0x0A);
        // disp_str(str);
        disp_str_colour(str, 0x0B);
        //return;
}
```

`char *str`，导致 str 的结果非常怪异。

`char *str = ""`，导致后续清屏操作打印的都是`atoi`的结果。

`char str[16]`，是存储`atoi`结果的非常合适的数据结构。



调试能力还是这么低效啊。我对自己在这个问题上的表现，非常非常失望！

00000000_000327f8

<bochs:6> xp /1wx 0x30:0x327c8
[bochs]:
0x00000000000327c8 <bogus+       0>:	0x000327f8

rsp: 00000000_000327c8
rbp: 00000000_000327c8
rsi: 00000000_00000000
rdi: 00000000_00000000
r8 : 00000000_00000000
r9 : 00000000_00000000
r10: 00000000_00000000
r11: 00000000_00000000
r12: 00000000_00000000
r13: 00000000_00000000
r14: 00000000_00000000
r15: 00000000_00000000
rip: 00000000_00030478
eflags 0x00000016: id vip vif ac vm rf nt IOPL=0 of df if tf sf zf AF PF cf
<bochs:12> xp /1wx 0x30:0x327d0
[bochs]:
0x00000000000327d0 <bogus+       0>:	0x00030dac
<bochs:13> xp /1wx 0x30:0x30dac
[bochs]:
0x0000000000030dac <bogus+       0>:	0x000a0041



disp_str_colour的堆栈

颜色		+ 12

字符串	+ 8

eip			+ 4

ebp			+ 0



字符串	+ 12

颜色		+ 8

eip			+ 4

ebp			+ 0

disp_str_colour("AAAA", 0x0A);

ax

Ah:05

Al:41

00000000_00030541

00000000_00030541

多看了一眼，问题似乎解决了。

可是，仍有不解之谜。



Mov ah, [ebp + 12]

Mov eax, [ebp + 12]

mov ax, [ebp + 12]



mov ax, word ptr ss:[ebp+12] ; 668b450c

(0) [0x0000000304bb] 0008:00000000000304bb (unk. ctxt): mov eax, dword ptr ss:[ebp+12] ; 8b450c

(0) [0x0000000304c2] 0008:00000000000304c2 (unk. ctxt): mov ah, byte ptr ss:[ebp+12] ; 8a650c





````shell
rsp: 00000000_000327bc
rbp: 00000000_000327f8
rsi: 00000000_00000000
rdi: 00000000_00000000
r8 : 00000000_00000000
r9 : 00000000_00000000
r10: 00000000_00000000
r11: 00000000_00000000
r12: 00000000_00000000
r13: 00000000_00000000
r14: 00000000_00000000
r15: 00000000_00000000
rip: 00000000_000304b5
eflags 0x00000012: id vip vif ac vm rf nt IOPL=0 of df if tf sf zf AF pf cf
# 当前栈顶
<bochs:4> xp /1wx 0x30:0x327bc
[bochs]:
0x00000000000327bc <bogus+       0>:	0x00030577
# esp + 4，第一个参数，字符串
<bochs:5> xp /1wx 0x30:0x327c0
[bochs]:
0x00000000000327c0 <bogus+       0>:	0x00030b80
# 第一个参数的值。因为是字符串，所以通过打印字符串的内存地址查看数据。
<bochs:6> xp /1wx 0x30:0x30b80
[bochs]:
0x0000000000030b80 <bogus+       0>:	0x41414141

<bochs:9> r
CPU0:
rax: 00000000_60000b4c
rbx: 00000000_00002600
rcx: 00000000_00090002
rdx: 00000000_00000027
rsp: 00000000_000327b8
rbp: 00000000_000327b8
rsi: 00000000_00000000
rdi: 00000000_00000000
r8 : 00000000_00000000
r9 : 00000000_00000000
r10: 00000000_00000000
r11: 00000000_00000000
r12: 00000000_00000000
r13: 00000000_00000000
r14: 00000000_00000000
r15: 00000000_00000000
rip: 00000000_000304b8
eflags 0x00000012: id vip vif ac vm rf nt IOPL=0 of df if tf sf zf AF pf cf
# 参数二、参数一、旧eip、旧ebp入栈
# 第一个参数，ebp + 8，字符串
<bochs:10> xp /1wx 0x30:0x327c0
[bochs]:
0x00000000000327c0 <bogus+       0>:	0x00030b80
<bochs:11> xp /1wx 0x30:0x30b80
[bochs]:
0x0000000000030b80 <bogus+       0>:	0x41414141
# 第二个参数，ebp + 12
<bochs:12> xp /1wx 0x30:0x327c4
[bochs]:
0x00000000000327c4 <bogus+       0>:	0x0000000c

<bochs:13> s
Next at t=17013937
(0) [0x0000000304bb] 0008:00000000000304bb (unk. ctxt): mov eax, dword ptr ss:[ebp+12] ; 8b450c
<bochs:14> r
CPU0:
rax: 00000000_60000b4c

<bochs:17> s
Next at t=17013938
# 16位代码在32位模式中，加上前缀66，要求编译器把这条指令当作16位指令执行
(0) [0x0000000304be] 0008:00000000000304be (unk. ctxt): mov ax, word ptr ss:[ebp+12] ; 668b450c
<bochs:18> r
CPU0:
rax: 00000000_0000000c

<bochs:19> s
Next at t=17013939
(0) [0x0000000304c2] 0008:00000000000304c2 (unk. ctxt): mov ah, byte ptr ss:[ebp+12] ; 8a650c
<bochs:20> r
CPU0:
rax: 00000000_0000000c

<bochs:21> s
Next at t=17013940
(0) [0x0000000304c5] 0008:00000000000304c5 (unk. ctxt): mov edi, dword ptr ds:0x00032808 ; 8b3d08280300
<bochs:22> r
CPU0:
rax: 00000000_00000c0c


````



```assembly
; 把值更新到ah寄存器
mov ah, [ebp + 12]
; 把值更新到eax寄存器，从低位开始填充。非常有可能，把值更新到al。
mov eax, [ebp + 12]
; 把值更新到eax寄存器，从低位开始填充。非常有可能，把值更新到al。
mov ax, [ebp + 12]
```

`mov eax, [ebp + 4]`为什么能获取到颜色值？`[esb+4]`是调用函数指令的下一条指令地址，即`eip`。能获取到颜色值，只不过恰好`eip`中的值能填充到eax中的ah罢了。为什么有值？不值得去弄清楚，那是其他数据的一部分被当做颜色。

`mov eax, [ebp + 12]`为什么不能获取到颜色值？因为`[esb + 12]`的值是`0x0C`，填充到eax的al的是`C`，填充到ah的是`0`。所以，没有值。

C语言调用汇编函数的堆栈，无特权级转移、近调用，堆栈是（从栈顶到栈底）：eip、参数一、参数二、参数三。压栈顺序和前面的顺序相反。不管第一个参数是不是字符串，都是如此。

字符串参数，压栈的是字符串的内存地址。

字符串的结束符是空字符，空字符的ascii码是0。这个特性在disp_str函数中也有利用。