# 实现中断

## 理论

### 回忆

#### 中断是什么

中断是什么？让CPU停止正在做的事，停止一会，然后再开始做事情。

停止前后所做的事情，可以是同一件事，也可以是不同的事。是同一件事还是不同的事，取决于CPU所执行的调度算法。

中断，流程是这样的：

1. CPU正在做A事情。
2. CPU停止做A事情，做B事情。
   1. B事情是什么？一直运行B吗？不是。利用这个契机，B会选择下一个要做的事。
   2. B是调度程序。
   3. 假设B选择的下一个要做的事情是C事情。
3. CPU做C事情。

#### 8259A

让CPU停止做正在做的事，转而做另外一件事，用8259A完成。

8259A是一个硬件。

使用这个硬件，有一个固定套路。我没有记住。

使用8259A的方法是，设置`ICW`和`OCW`。

1. `ICW`，初始化命令字。
2. `OCW`，控制命令字。
3. 这两个“东西”的专业术语是什么？能写入数据，就把它们叫做“端口”吧。

怎么向这两类端口写入数据？我不记得了。

写入数据时，先写入哪个端口后写入哪个端口，往哪个端口写入什么数据，都有规定。

`ICW`有四个，分别是：

1. `ICW0`。
2. `ICW1`。
3. `ICW2`。
4. `ICW3`。

四个端口所需数据的格式不相同。

`OCW`好像也有4个，但我们只使用2个。我记得它的作用，设置哪个中断被屏蔽、哪个中断被启用。0和1和“中断”、“屏蔽”的对应关系，我不记得了。

`ICW`是干什么的？竭尽所能，记得什么就说什么吧。

1. 8259A是级联还是单片。
2. 哪个端口挂载从片；从片连接到主片的哪个端口上。
3. 只记得这么多了。

目前，接触到的中断有：

1. 时钟中断
2. 键盘中断

时钟中断要怎么做？

1. 初始化8259A。
2. 不记得了。

看代码吧。

建立`IDT`。

`IDT`是中断向量表。对每个中断给定一个编号，例如`80`，然后，设置好这个编号对应的代码。就像PHP中的数组。一个键对应一个元素。在中断向量表中，元素就是中断处理例程。

怎么建立IDT？我的猜测是：

1. 像建立栈一样，建立一个IDT的代码段，为这个代码段设置一个标号（叫标量还是标号？）。
2. 建立一个描述符，指向IDT。手工设置IDT的描述符的段基址。
3. 建立一个选择子，指向IDT的选择子。

假如为时钟中断例程建立的IDT项是：80（向量号）-------》中断例程，那么，触发时钟中断的方法是：`int 80h`。

上面的方法只能触发一次时钟中断。而时钟中断应该不间断地重复发生。使用另外一个硬件才能让时钟中断重复发生。

上面，是我看到`IDT`后想到的。

### 最终方案

#### IDT

中断向量一共有256个。最后XX个是用户可以自定义的。

用汇编代码实现IDT的具体做法是：

1. 建立中断向量表。
   1. 可以定制中断向量表中的项的数目。对大多数项指定相同的中断例程。
      1. 这些相同的中断向量，没有标号，指向相同的中断例程。
      2. 使用nasm的伪指令`%rep`创建相同的中断向量。
   2. 处理个性化的中断向量。
      1. 有标号。
      2. 有特殊的中断例程。
2. 为中断向量表中的项建立代码段，也就是中断例程。
   1. IDT中的项，是一个门描述符。
   2. 门描述符的几个参数：
      1. 选择子。它是中断例程所在的代码段。
      2. 偏移量。它不为0。这是我遇到的关于门的新情况。之前，我没见过偏移量不是0的门描述符。偏移量不是中断例程的标号，而是`$$ - 中断例程的标号`。
      3. 门描述符指向一个中断例程，属性是什么样的？是普通的门描述符的属性吗？
3. 中断向量所在的代码段的段界限，不是`0x0fffff`。
4. 使用`int 中断向量门描述符的标号`触发中断。

*并没有什么难度。这也只不过是知识而已，看一次，记忆。不存在理解不理解的问题。第一次看这块知识，我有觉得理解不了吗？不记得那个时候的感觉了*。

#### 遗漏

和GDT一样，也需要把IDT加载到专用寄存器中。这个专用寄存器是：``。

#### 初始化8259A

这是使用中断的最大难点。

##### 回忆

初始化8259A，就是设置它的两类端口：`ICW`和`ocw`。

`ICW`有四个，分别是：`ICW1、ICW2、ICW3、ICW4`。

1. `ICW1`：是否设置级联、是否向`ICW4`写入数据。值是`011h`。
2. `ICW2`：设置主从片的起始向量号。确定了起始向量号，依次递增，后面的向量号也确定了。
   1. 主片的值是`020h`。
   2. 从片的值是`028h`。
3. `ICW3`：主片用位图设置几号引脚挂载从片，从片用二进制设置自身是第几个从片。
   1. 假设使用主片的第2号引脚挂载从片。
   2. 主片的ICW3的值是：`0000 0100`
   3. 从片大的ICW3的值是：`0000 0010`
4. `ICW4`：设置是否自动发送`EOI`。值是`001h`。

只记得这些。然而，更重要的是，**需要知道怎么完成上面的操作，怎么向四个`ICW`写入数据，写入什么数据。**

`OCW`设置放行哪些端口、屏蔽哪些端口。0表示放行，1表示屏蔽。不知道怎么用代码实现。

设置OCW1，主片向0x21端口写入数据，从片向0XA1写入数据。

设置ICW1，主片向端口`0x20`、从片向端口`0xA0`写入数据。

设置ICW2、ICW3、ICW4，主片向端口`0x21`写入数据，从片向端口`0XA1`写入数据。

ICW的详细资料见《操作系统真相还原》第7.5节第315页。

## 实践

代码在：

1. 普通中断：/home/cg/os/pegasus-os/v12
2. 时钟中断：/home/cg/os/pegasus-os/v13

按下面的流程写代码：

1. 建立IDT。
   1. 使用伪指令`%rep`。
   2. IDT中都是门描述符。
2. 包含中断例程的代码段的选择子是：SelectFlatX。
3. 建立中断例程
   1. 普通中断例程：Superious_handle。
   2. 时钟中断例程
4. 初始化8259A
   1. 设置完一个ICW后，执行io_delay
   2. Io_delay是一个函数，执行几个空指令

怎么使用中断让字符不断变化？

1. 使用时钟中断。时钟中断的向量号是`.20h`。
2. 必须执行`sti`。
3. 时钟中断例程中需要手工发送EOI。



*调试时钟中断时，犯了很可笑的错误。时钟中断代码在V13，我却一直运行V12。*

### 疑问

1. 时钟中断不必使用`int 向量号`显式调用，那它怎么被触发的？
2. 时钟中断例程为何需要手工发送`EOI`而其他中断例程不需要手工发送呢？

### 调试

遇到错误：

```shell
0) [0x00000002049d] 0008:000000000002049d (unk. ctxt): int 0x80                  ; cd80
<bochs:118> s
00031506083e[CPU0  ] interrupt(): gate descriptor is not valid sys seg (vector=0x80)
00031506083e[CPU0  ] interrupt(): gate descriptor is not valid sys seg (vector=0x0d)
00031506083e[CPU0  ] interrupt(): gate descriptor is not valid sys seg (vector=0x08)
```

执行`int 0x80`时导致上面的错误。



```shell
 fetch_raw_descriptor: GDT: index (e7) 1c > limit (67)
```

IDT中的门描述符

`00000000 00000000 10001110 00000000 00000000 00001000 00000000 00000000`

属性

`00000000 00001000`

![image-20210328091842205](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210328091842205.png)



![image-20210402102000950](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210402102000950.png)



`0x8e000008008a`

`8e0000080000`

IDT项，从右往左看。

`00000000 00000000 10001110 00000000 00000000 00001000 00000000 10001010`

属性是：`10001110 00000000`，更具体，是：`10001110`，分别对应：TYPE、S、DPL、P。

又遇到错误

```shell
00062679379i[APIC0 ] warning: misaligned APIC access. addr=0x0000fee00ffe
00062679379p[APIC0 ] >>PANIC<< APIC write with len=2 (should be 4)
========================================================================
Bochs is exiting with the following message:
[APIC0 ] APIC write with len=2 (should be 4)
========================================================================
```

这个报错信息没有提供任何线索。

把这个报错信息当关键词搜索，搜出来一系列英文结果，没有细看，但没有看到相关的结果。实在没办法，再去仔细看几条这些搜索结果。

打算怎么解决这个问题？

我怀疑，中断例程的偏移量不正确。

1. 先改成物理地址试试。
2. 如果第一步仍不能解决问题，我先验证IDT项是否完全正确。已经证明，属性是正确的。

IDT项的偏移量使用物理地址，出现这个错误：

```shell
00060899973e[CPU0  ] branch_near32: offset outside of CS limits
```



第1步已经失败。我瞎试了几个方法，都无用。现在怀疑，IDT项没有指向正确的中断例程。执行第2个步骤。

1. 找出IdtPtr的基址

   1. 在手工设置IdtPtr的基址时查看。00000000_00020ae0
   2. 在加载IdtPtr后用sreg查看。idtr:base=0x0000000000020ae0, limit=0x7f7
   3. 对比两种不同的方法查看到的基址是否相同。

2. 如果第一个步骤获得的基址是正确的，查看所有的IDT项是否相同。

   ```shell
   idtr:base=0x0000000000020ae0, limit=0x7f7
   <bochs:13> xp /1gx 0x20ae0
   [bochs]:
   0x0000000000020ae0 <bogus+       0>:	0x28e0000080082
   <bochs:14> xp /1gx 0x20ae8
   [bochs]:
   0x0000000000020ae8 <bogus+       0>:	0x28e0000080082
   ```

   

3. 解读IDT项的每个组成部分是否正确

`00000000 00000010 10001110 00000000 00000000 00001000 00000000 10000010`

![image-20210402102000950](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210402102000950.png)

上面的IDT项和图中的格式一致，左边是高位，右边是低位，与日常习惯的十进制数的高低位相反。

属性：`00000000 10001110`

偏移量：`00000000 00000010 00000000 10000010`

选择子：`00000000 00001000`

机器码

`00000000: b40c`

Superious_handle



`0x8e0000080000`

`100011100000000000000000000010000000000000000000`

`00000000 00000000 10001110 00000000 00000000 00001000 00000000 00000000`

属性：`10001110 00000000`

偏移量：`00000000 00000000 00000000 00000000`

选择子：`00000000 00001000`



`0x8e0000080082`

`00000000 00000000 10001110 00000000 00000000 00001000 00000000 10000010`

属性：`10001110 00000000`

偏移量：`00000000 00000000 00000000 10000010`

选择子：`00000000 00001000`



```shell
gdtr:base=0x000000000002013f, limit=0x67
idtr:base=0x0000000000020ae0, limit=0x7f7
<bochs:19> xp /1gx 0x20147
[bochs]:
0x0000000000020147 <bogus+       0>:	0xc09a0204800109
```



`00000000 11000000 10011010 00000010 00000100 10000000 00000001 00001001`



![image-20210403101229116](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/lab/image-20210403101229116.png)

段基址：`00000000 00000010 00000100 10000000`

20480h + 82h = 20502h

似乎发现了问题，IDT项的选择子有问题，具体说，是选择子的段基址有问题。选择子的段基址也没有问题，可能是我断点检查数据不仔细导致数据不正确。

## 知识点

### 大端法--小端法

下面以unsigned int value = 0x12345678为例，分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value

**Big-Endian: 低地址存放高位，如下：**

高地址
　　---------------
　　buf[3] (0x78) -- 低位
　　buf[2] (0x56)
　　buf[1] (0x34)
　　buf[0] (0x12) -- 高位
　　---------------
　　低地址

**Little-Endian: 低地址存放低位，如下：**

高地址
　　---------------
　　buf[3] (0x12) -- 高位
　　buf[2] (0x34)
　　buf[1] (0x56)
　　buf[0] (0x78) -- 低位
　　--------------

低地址

| 内存地址 | 小端模式存放内容 | 大端模式存放内容 |
| -------- | ---------------- | ---------------- |
| 0x4000   | 0x78             | 0x12             |
| 0x4001   | 0x56             | 0x34             |
| 0x4002   | 0x34             | 0x56             |
| 0x4003   | 0x12             | 0x78             |



