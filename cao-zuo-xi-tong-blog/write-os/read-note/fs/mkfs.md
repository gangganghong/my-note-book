# 编码建立文件系统

## 设备号

设备号由主设备号和次设备号组成。

根据主设备号找到驱动程序，根据次设备号找到逻辑分区号。

一个十六位的二进制数，高八位是主设备号，低八位是次设备号。

> 很苦恼。我不知道设备号在哪些地方会用到。这是因为，我不能总揽全局。
>
> 不管它。边写边改吧。

为啥要设备号？

1. 选择驱动。
2. 在任何一个逻辑分区建立文件系统，不使用硬编码。

能确定，设备号在存储分区信息时用到。

用一个数组存储硬盘的分区信息。如果有两块硬盘，这个数组就有两个元素。

每个元素的数据类型，是一个结构体。这个结构体有两个成员，一个用来存储主分区信息，另一个用来存储逻辑分区信息。

请注意，无论是哪块硬盘，存储主分区信息的数组，索引取值范围都是`[1,4]`。存储逻辑分区的信息的数组，索引范围也是如此。

上面这句话，歧义很大。请参考小结中的`2021-07-04 07:17`。在那个小结，我准确、全面阐述了上面这句话所要表达的意思。

> 想好了再写，写作文时需要如此。
>
> 借助写作来促进思考，不需要如此。写就是在想，是更高效地想。

又不知道该做什么了。

第一，存储硬盘的分区信息。

设备号起到了什么作用？

1. 提供硬盘编号。
2. 硬盘编号只在hd_info中发挥作用。
3. 次设备号在获取主分区的逻辑分区时发挥作用。

## 改造partition

当前，存储分区信息时，逻辑分区的的次设备号即hd_info的logical的索引没有正确反映逻辑分区在哪个主分区。

此次改造，要让logical的索引正确反映逻辑分区在哪个主分区。

怎么改造？

1. 根据次设备号计算硬盘号：DR_OF_DEV
2. 获取主分区的逻辑分区时，partition的第一个参数，应该是次设备号+主分区的分区号。
3. 获取硬盘的主分区时，partition的第一个参数，应该是次设备号。



```shell
00095370642e[HD    ] IO read(0x01f0) with drq == 0: last command was 00h
```

```c
#define DR_OF_DEV(device) device < NR_PRIM_MAX ? \
         device / NR_DEV_PER_HD:\
         (device-hd1a) / (NR_SUB_PART_PER_PRIM * NR_PRIM_PART_PER_HD)         
```

`DR_OF_DEV(0)`的结果竟然是1。费解。



打印存储的硬盘分区信息。

运行于上神的代码打印出来的结果：

```shell
(gdb) p hd_info
$1 = {{open_cnt = 1, primary = {{base = 0, size = 163296}, {base = 63, size = 20097}, {base = 20160, size = 143136}, {base = 0,
        size = 0}, {base = 0, size = 0}}, logical = {{base = 0, size = 0} <repeats 16 times>, {base = 20223, size = 40257}, {
        base = 60543, size = 30177}, {base = 90783, size = 42273}, {base = 133119, size = 28161}, {base = 161343, size = 1953}, {
        base = 0, size = 0} <repeats 43 times>}}}
(gdb)
```



运行我的代码打印出来的结果：

```shell
(gdb) p hd_info[0]
$3 = {open_cnt = 1, primary_part = {{base = 0, size = 0}, {base = 63, size = 20097}, {base = 20160, size = 143136}, {base = 0,
      size = 0}}, logical_part = {{base = 0, size = 0} <repeats 16 times>}}
```



两个差异：

1. primary的第0个元素不同。
   1. 为啥会这样？耗费了很多时间。
   2. 我明白了。
      1. primary_part的元素多于4个，假设是5个吧。
      2. 我们直接从primary_part[1]开始设置值，primary_part[0]是脏数据，不必理会它。
      3. primary_part[0]中的数据是什么，是随机的。
2. logica_part没有把后面的数据显示出来。把logical声明为更大的数组即可。

一个问题：

在partition函数中，`struct partition_table_entry partition_table[64];`语句会导致invalid opcode，而`struct partition_table_entry partition_table[5];`不会。

这和我的操作系统的内存分布有关。这是我的猜想。



## 小结

### 2021-07-03 08:38

又一次看懂了mkfs。并不是那么顺畅。有些语句，第一次看没有问题，第二次看，却觉得第一次理解有问题。

我仍然没有记住，我并没有记住。

看代码时，漫不经心，毫无压力，一点紧张感都没有。

还是要早点睡，不要再凌晨一点多睡觉了。

不要试图一次性写出所有代码，而应该一点点写代码。

耗时1小时41分。

### 2021-07-03 11:11

复述一次mkfs，再看一次mkfs。前者耗费主要时间，后者耗费的时间可以忽略。

想不起来mkfs，在纸上写简单的流程。

其实，到这种程序就可以写代码了。理解和记忆，是两件事情。

一旦写完了mkfs，文件系统的开发就开始了。

当初，loader那么难写，我不也写出来了吗？

### 2021-07-03 16:54

看task_fs，非最终版。并非逐行阅读代码，而是浏览。没有仔细看mkfs。

我已经看懂了mkfs，再看一次，也不能让我记住它的全部流程。

现在，我面临的问题：继续看其他代码还是自己实现mkfs。

继续看其他代码，我将仍然不能往前推进；自己实现mkfs，我又没能记住全部流程，在写的过程中，需要参考作者的代码。

两难。这种时候，我就不想干了。

若是在工作中，完全没有这种困扰，直接写代码就是了，管他记住了还是没有记住。

怎么才算是自己写操作系统？当我完成了《一个操作系统的实现》中的所有功能后，就不会有这种困扰了。

前阵子，我自己写出了获取硬盘分区信息的代码，那又如何？此刻，让我说出这些代码细节，我说不出来，忘记了。先记住整个代码流程，再写出代码，没必要，因为，迟早会忘记。

开始写代码吧。先记住，再写代码，这种错误的策略，让我严重延误开发操作系统的进度。

耗时21分。

### 2021-07-03 17:49

浏览hd_ioctl，查询作者的命名意图，是通用的还是他自己起的名字。

有点乱，找不到线头，不知从哪里下手写代码。

看到大学生写的操作系统代码，我质疑我写这个操作系统的作用几何。

比较烦，不想干了。

耗时50分。

### 2021-07-03 21:10

理解我十多天前写的hd.c中的代码。耗时44分。

荒唐啊，可笑啊。自己写的东西，需要花这么长时间才勉强找到线头。

一个收获：在C语言中，对一个数组，能直接从第16个元素开始赋值。

我想跳过对设备号的处理，可是，这样做，我仍然不知道怎么写代码。

那就花点时间，做完对设备号的处理。

### 2021-07-03 23:47

理解partition函数中的设备号。耗时2个34分。

我仍然没有理解。

在准备写这个小结之前，我又先看了一会公众号（无用资讯）。恶心，非纠正不可。

这个函数的所有代码，我之前是理解了的。

这一次，为什么耗费这么多时间没有理解？

状态不好。说了不要心算不要心算。

不能快速理解的内容，我一心算就分心、非常没有条理。

耗时这么多却没能理解，是因为我根本就没有进行清晰的思考。

有什么疑问，不写清楚也要确定疑问是什么。可我不知道我在想什么。

今天就到这里吧。这种习惯不改变，我熬夜把这个问题解决了，也毫无意义。

### 2021-07-04 07:17

理解partition中的设备号。看明白了。

我被什么问题困扰？

存储硬盘信息，使用一个数组。

还是用具体的代码来叙述更准确。

```c
// 第0块硬盘还是第1块硬盘
int drive = DRV_OF_DEV(device);
struct hd_info * hdi = &hd_info[drive];
PRIVATE struct hd_info  hd_info[1];
```

如果有两块硬盘，那么，`hd_info`应该有两个元素，数组应该声明为`PRIVATE struct hd_info  hd_info[2];`。

`int drive = DRV_OF_DEV(device);`中的`device`的取值是多少？

取值范围是`0~~9`或`x~~x+127`。

`drive`的取值是多少？只能是0或1。这是由宏`DRV_OF_DEV`决定的。

无论是`hd_info`的第0个元素还是第1个元素，它们的成员的索引都相同。

上面这句话是什么意思？

`hd_info[0].primary[dev_nr]`中，`dev_nr`的取值范围是`1~~4`。

`hd_info[0].logical[dev_nr]`中，`dev_nr`的取值范围可能是下面的一种：

1. `0~~15`。
2. `16~~31`。
3. `32~~47`。
4. `48~~63`。

`hd_info[1]`的两个成员的`dev_nr`的取值范围和`hd_info[0]`的取值范围相同。

困扰我的是什么？

我认为，`hd_info[1]`的两个成员的取值范围应该是下图中的`primary slave`标识出来的次设备号。

![image-20210704072204025](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/read-note/fs/image-20210704072204025.png)

可是，于上神的代码却并没有这样做。

他不这样做，有问题吗？没有问题。是我自己先看了图，觉得代码应该那样做。思维定势，害苦了我。

耗时51分。

### 2021-07-04 08:27

设备号在代码中的作用是啥？我凭空想象，想不出更多。

烦。不想干了。玩一会。

耗时29分。

### 2021-07-04 10:11

看partition，不顺利。

阻碍是什么？代入具体数值，计算结果不满足要求。

代入具体数值时，我在心算。也许，我心算结果错了。

耗时37分。

笔算，两三分钟，解决了问题。

### 2021-07-04 11:25

写改造partition的思路。耗时42分。

太慢了。要适度紧张一点。

### 2021-07-04 11:25

按照上一个小结中的思路改造partition写代码。耗时54分。

为啥慢？

1. 不熟。
2. 心算速度慢，思路非常不清晰。
   1. 回顾其他代码，例如，lba是什么，lba的基地址是不是主扩展分区的lba。
   2. 大部分时间，思考似乎停滞了。

### 2021-07-04 19:44

调试改造后的partition。耗时1个小时50分。

不怎么顺利。没有分心。

调试代码，没有心算问题那么容易分心。

时间消耗点：

1. 宏。`DR_OF_DEV(device)`。
   1. `#define NR_DEV_PER_HD   (NR_PRIM_PART_PER_HD + 1)`和`#define NR_DEV_PER_HD   NR_PRIM_PART_PER_HD + 1`是不一样的。
   2. 
2. hd_info[0]。
   1. 这是最大的时间消耗点，完全不应该在这个结果验证上耗费时间。
   2. 我做了什么？
      1. 修改存储分区表的数组。没办法，碰碰运气。试了四五分钟吧。
      2. 断点对比于上神的内核和我的内核。没看出问题。花了很长时间。
      3. 灵感来了。问题出在，我俩是直接对数组的第1个元素赋值，因此，数组的第0个元素有随机数据。
3. 想不起来我所做的每件事情。只有这两件大事。记录的粒度一定要细，一来能让自己保持清醒，二来能获得准确记录。

又耗时24分。