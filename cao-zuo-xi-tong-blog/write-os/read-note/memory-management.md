# 内存管理

## 进程复习

<img src="/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/read-note/image-20210605074719517.png" alt="image-20210605074719517" style="zoom:50%;" />

## do_fork

### v1

1. 在进程表数组中找一个空闲的进程表，作为新生的子进程的进程表。
2. 子进程需要进程表、堆栈、进程体、数据，如何准备？
3. 准备好进程后，怎么让子进程运行起来？

## 安装自己编写的应用程序

出现错误：

![image-20210608182333679](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/read-note/image-20210608182333679.png)

定位问题出在哪里。

### v1

分析untar，在第一个while的close设置断点，记录第几次“c"后出错，然后在出错前的那次c，单步执行。

1. 在1076行设置断点：b 0x1994
2. 打印了两个文件后，开始单步执行。
3. 在第一个while的close的第一条指令在 第 14761 行。
4. 在close的ret设置断点：b 0xc611
5. 关键指令
   1. 在打印出三个文件名后，要执行write指令。
   2. `1068     197a:       e8 31 ac 00 00          call   c5b0 <write>`
   3. 我怀疑，执行write指令后，擦除了其他指令，导致异常。
6. 分析第5点钟的关键指令。
   1. 在write中出错。

### v3

1. 在1076行设置断点：b 0x1994
2. 打印两个文件名后，在`1068     197a:       e8 31 ac 00 00          call   c5b0 <write>`设置断点。
3. b 0x197a
4. b 0xc5da
   1. 在 `14754     c5da:       e8 e9 fc ff ff          call   c2c8 <send_recv>`中出错。
   2. 这就麻烦了。这是个很复杂的函数。
   3. 进入C代码调试看看。

### v4

1. 在第一次while的close设置断点，打印了2个文件名后，在第二个while的write设置断点，开始单步调试。
2. 定位到在send_rec出了问题。

这个函数太复杂，继续在里面断点，只会进入一个黑洞。我放弃了这个尝试。

### v5

![image-20210610162847030](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/read-note/image-20210610162847030.png)

A表示，untar函数执行正确。

B表示，/echo 不正确。



## 小结

### 2021-06-05 07:48

GDT、进程表、LDT的关系被遗忘了一部分，想不起来，索性重看了部分。还好没有花太多时间找到资料。耗时20分。

时间耗费在回忆和找资料。另外，喝水、回忆往事。

### 2021-06-05 08:09

运行 /home/cg/yuyuan-os/osfs10/a，很顺利。耗时20分。

做的事：

1. 复制 bochs 配置文件。
2. 修改代码，让代码能够加-g后编译。

分心，想往事。

### 2021-06-05 08:31

看do_fork代码，连主流程都没有看明白。耗时20分。

什么叫没看明白主流程？

1. 不清楚每个步骤是在做什么。
2. 不清楚每个步骤存在的必要。

在哪里消耗了时间？指针的使用。我能熟练使用指针，但我不能通俗易懂地解释这个用法。心算指针示意图，花了一些时间。

代码细节不阻碍我理解主流程，暂时不去阅读它。先试试看明白主流程。

### 2021-06-05 09:03

看do_fork代码，没看懂，没看代码细节，发现我看不懂几个月前自己写的代码。耗时29分。

要不厌其烦地写最详细的注释。写代码的时候也许觉得那些注释没必要，等过一两个月就会感谢当初的自己。

我在做什么？看代码流程。

1. 找到一个空闲进程表。
2. 进程表中的LDT表，有两个表项，分别是cs、ds的描述符。cs段有个新名称，叫”Text Segment"。
3. 想不起来更多了。

### 2021-06-05 10:07

躺在沙发上看进程管理。耗时24分。

1. 内存分配，完全没有看明白，没耐心看代码。
2. do_fork
   1. 找到空闲进程表，作为子进程。
   2. 获取父进程（Init进程）的内存范围。
      1. 进程的内存范围，这是一个因陌生而神奇的概念。
      2. 进程的内存，是什么？
   3. 子进程由父进程派生，但是使用的内存和父进程不是同一片内存。
      1. 理解。每个进程都有独立的内存空间。
   4. 修改子进程的内存范围。
      1. 怎么修改？
   5. 通知文件系统处理父子进程的文件。
      1. 非常陌生。
   6. 向父子进程发生消息。
   7. 子进程的priority和父进程的priority相同吗？如果相同，是怎么复制的？

### 2021-06-05 11:21

全部时间消耗在理解下面的代码。耗时1小时5分钟，写笔记又耗费33分钟。

```c
// /Users/cg/data/code/os/yy-os/osfs10/a/mm/forkexit.c
/*****************************************************************************
 *                                do_fork
 *****************************************************************************/
/**
 * Perform the fork() syscall.
 * 
 * @return  Zero if success, otherwise -1.
 *****************************************************************************/
PUBLIC int do_fork()
{
	/* find a free slot in proc_table */
	struct proc* p = proc_table;
	int i;
	// 进程表数组中存在许多没有被使用的进程表吗？在哪里创建的空闲进程表？
	for (i = 0; i < NR_TASKS + NR_PROCS; i++,p++)
		if (p->p_flags == FREE_SLOT)
			break;

	int child_pid = i;
	// some code

	/* duplicate the process table */
	int pid = mm_msg.source;			// 父进程ID
	u16 child_ldt_sel = p->ldt_sel;		// 子进程的ldt_sel，ldt选择子。奇怪，子进程哪里来的选择子？在kernel/main.c的kernel_main中初始化的。
  // 这句的汇编代码太复杂，我看不懂。
	*p = proc_table[pid];				// 获取父进程，将p指向父进程，复制了父进程的进程表
	p->ldt_sel = child_ldt_sel;			// 
	p->p_parent = pid;
	sprintf(p->name, "%s_%d", proc_table[pid].name, child_pid);
	
  // some code

	return 0;
}
```



理解这句代码`*p = proc_table[pid];				// 获取父进程，将p指向父进程，复制了父进程的进程表`。

注释是我第一次看内存管理代码时写下的。第二次看，没有看到这些注释，又花了这么多时间才重新理解。这就叫做低效！

写的注释，尽快提交保存，在上一次的基础上看代码，我就能够从以前写的注释中收益。我这次看的代码版本和上一次不一样，所以，我没有看到上一次写的注释。

去年，我看k8s源码并写了详细注释。后来，因电脑硬盘空间不够，我删除了那份看过的源码。一段时间的努力化为乌有。理解起来本来就不容易，还因为不好的习惯随意丢弃努力的成果。

言归正传，回到这段代码中的难点。

`struct proc* p = proc_table;`，声明一个指针变量并且赋值。p的值是进程表数组的首个元素的内存地址。

`p++`，递增p的值，递增单位是4个字节。指针变量占据的内存空间都是4个字节。前提是，在32位CPU中。

`p++`会修改p的值，这完全不应该有疑问。我有个缺点，遇到难题时，常会在无疑处制造疑问。

`*p = proc_table[pid];	`。经过循环后，p的值是什么？是一个空闲进程表的内存地址D。`*p`是什么？它是内存地址为D的一块内存空间，是内存空间而不是内存地址。`*p = proc_table[pid];`的意思是，把`proc_table[pid]`这个数据放到内存地址为D的那块内存中。

> *p 究竟是啥意思？依靠不同上下文摸索指针的含义，毕竟是猜测。还是看得懂汇编更好。

经过这条语句后，内存地址为D的内存中的数据和内存地址为`&proc_table[pid]`的内存中的数据相同。然而，对内存地址为D中的数据的修改完全不会影响内存地址为`&proc_table[pid]`的内存中的数据。

为什么要这样理解？不知道。我根据别人写的代码运行结果来看，就是这样的。这是编译器认可的规则。

```shell
(gdb) p &proc_table[pid]
$15 = (struct proc *) 0x39c98 <proc_table+2040>
(gdb) s
54		*p = proc_table[pid];
(gdb) p p
$10 = (struct proc *) 0x3a2f8 <proc_table+3672>
(gdb) s
(gdb) p &proc_table[pid]
$15 = (struct proc *) 0x39c98 <proc_table+2040>
(gdb) p p
$18 = (struct proc *) 0x3a2f8 <proc_table+3672>
```

在运行`*p = proc_table[pid];`前后，p的值即内存地址不变，proc_table[pid]的内存地址也不变，而且，和p不同。

> 没有这句注释，只看上面的断点过程，我会看不懂。

`*p = proc_table[pid];`和`p = &proc_table[pid];`执行后，效果不同。

### 2021-06-05 11:21

提交代码，读do_fork中的文件处理，看凤凰网等无用资讯。耗时20分。

文件处理很简单，给FS进程发消息，通知它修改fd_cnt、i_cnt。只修改子进程，主进程的文件描述符怎么不修改？

不要投机取巧，每行代码，都看懂。

### 2021-06-05 16:41

理解do_fork中的`u16 child_ldt_sel = p->ldt_sel;`，耗时51分。

对了，我还看懂了`alloc_mem`，没啥神奇的。设置一个基础值，设置一个派生进程的内存值，第N个进程，它的内存的初始地址是：N * base_memory_address。

又在看起来不应该有疑问的地方产生了疑问。而且，去看之前的代码，又发现我看不懂许多代码。可怕而沮丧。

就这一条语句，有疑问，我能怎么办？只能盯着代码看，从现有的知识储备出发，期待灵感降临。

### 2021-06-05 17:15

读了free_mm这类函数，不知道啥意思。有点目标不明。耗时28分。

### 2021-06-05 18:00

读exit、wait。能看明白代码的直接功能，却不了解它们实现了什么功能。耗时27分。

看了一次的材料，比较短的材料，我并没有记得很清晰。如果费点劲回忆，我还是能回忆出不少内容。另外，我看得很悠闲。

我要求自己，读材料时读快些。

### 2021-06-05 20:08

读exit、wait。记不住流程，更理解不了这样做实现了什么功能。耗时22分钟。

### 2021-06-05 20:08

读exit、wait。记不住流程。理解不了。耗时35分钟。中途了看了一会其他视频。

### 2021-06-05 23:19

读exit、wait。没理解。耗时29分。中途看了其他无用资讯。

### 2021-06-06 09:57

读exit、wait。没理解。耗时1小时27分。中途看了其他无用资讯。非常散漫，分心想其他琐碎往事。要么不看，要看就聚精会神地看。

效率太低。

这么多时间，不能一点收获都没有。实在理解不了，就先记下来，锻炼一下记忆力也好。不能让时间流逝得毫无价值。

### 2021-06-06 12:16

读exit、wait。理解了很多，好像没有啥难点。即使理解了，仍然需要记忆。耗时10分钟。

代码比文字说明好懂。

### 2021-06-06 12:33

读exit、wait。快背诵下来了。耗时17分。热，键盘按键黏糊糊的。

### 2021-06-06 19:05

读exit、wait。谈不上理解，掌握这个知识点，只能使用记忆了。起初，我觉得没有理解，在没有理解前记忆，没有意义。现在，我理解了这两个函数能实现的功能，但觉得掌握这两个函数的方法仍然是需要记住它们。

### 2021-06-06 19:46

看下面的函数。理解不了。耗时39 + 20分。盯着代码看，分心非常严重。

```c
PRIVATE int fs_exit()
{
	int i;
	struct proc* p = &proc_table[fs_msg.PID];
	for (i = 0; i < NR_FILES; i++) {
		if (p->filp[i]) {
			/* release the inode */
      // 一个进程关闭，被它打开的文件的i_cn应该减少1。
			p->filp[i]->fd_inode->i_cnt--;
			/* release the file desc slot */
      // 一个文件描述符没有被任何进程共享
      // 不知道这句有什么必要。全部时间都耗费在这句。盯着看。心算。
			if (--p->filp[i]->fd_cnt == 0)
						p->filp[i]->fd_inode = 0;
			// 一个进程退出后，它的文件描述符指针表应该被清空。
      p->filp[i] = 0;
		}
	}
	return 0;
}
```



`p->filp[i]->fd_inode = 0;`是什么意思？把一个文件描述符和它关联的inode分离。

当一个文件描述符没有被任何进程共享时，就可以把这个文件描述符重置为原始状态。在原始状态，文件描述符指向的inode是0，也就是说，不指向任何inode。

`p->filp[i] = 0;`只是让`p->filp[i]`不指向任何文件描述符，并不改变任何描述符的数据。

一个文件描述符不被任何进程共享却仍然保持和某个inode的关联，会出现什么问题吗？不清楚。可能在使用这个文件描述符时，需要再次判断一下。另外，我并不知道多个进程共享文件描述符的场景。

### 2021-06-07 09:04

定位调用fs_exit的代码的位置。很简单，使用grep全文检索。耗时17分。

### 2021-06-07 09:44

为自己的操作系统编写应用程序：

1. 建立C运行时库。
2. 编写应用程序的main函数。
3. 编写_start函数。

能看懂3个事情，对一些细节有疑问。

耗时40分。分心太严重。安静地坐着学习，实在是一件幸福感很高的事情。

### 2021-06-07 11:21

运行 /home/cg/yuyuan-os/osfs10/c，非常顺利。耗时13分钟。

### 2021-06-07 12:07

看下面的命令。分心，怎么都没看明白，运行一次，全都明白了。中途看了高考新闻。可以不用关注，虽然是大事，我也经历过。如今，离我很遥远了，高考新闻对我也是无用资讯。媒体就是靠这些大事活着，高考啊，中考啊，开学啊，状元啊，等等。不必浪费大好光阴去看这些新闻。耗时34分。

```shell
[root@localhost c]# egrep -e '^ROOT_BASE' ./boot/include/load.inc | sed -e 's/.*0x//g'
4EFF
[root@localhost c]# egrep -e '^ROOT_BASE' ./boot/include/load.inc
ROOT_BASE		equ	0x4EFF
```

### 2021-06-07 12:28

看exec的实现。天书，看不懂。代码中有我以前的注释，现在再看，我一点印象都没有。要经常复习啊。耗时19分。

### 2021-06-07 18:34

```c
// /Users/cg/data/code/os/yy-os/osfs10/d/lib/exec.c
// PUBLIC int execv(const char *path, char * argv[])
// 有多少个参数
	while(*p++) {
		assert(stack_len + 2 * sizeof(char*) < PROC_ORIGIN_STACK);
		stack_len += sizeof(char*);
	}
```



这个循环为什么能够统计`char * argv[]`有多少个元素？用gdb断点调试，发现 *p 的值是固定的，从来没有等于空。

后来，我查看反汇编出来的代码，更加看不懂汇编代码。简单的或者我写的汇编代码，我能够看懂。可是，C语言反汇编之后的汇编代码，太难懂了。

再加上总是分心，耗时非常多，却无收获。

耗时1个小时29分。

截取了execv函数的汇编代码，如下：

```assembly
0000c7dd <execv>:
    c7dd:       55                      push   %ebp
    c7de:       89 e5                   mov    %esp,%ebp
    c7e0:       81 ec 48 04 00 00       sub    $0x448,%esp
    c7e6:       8b 45 0c                mov    0xc(%ebp),%eax					; 第二个参数 argv
    c7e9:       89 45 f4                mov    %eax,-0xc(%ebp)				; 第一个局部变量 **p
    c7ec:       c7 45 f0 00 00 00 00    movl   $0x0,-0x10(%ebp)				; 第二个局部变量
    c7f3:       eb 2f                   jmp    c824 <execv+0x47>
    c7f5:       8b 45 f0                mov    -0x10(%ebp),%eax
    c7f8:       83 c0 08                add    $0x8,%eax
    c7fb:       3d ff 03 00 00          cmp    $0x3ff,%eax
    c800:       76 19                   jbe    c81b <execv+0x3e>
    c802:       6a 49                   push   $0x49
    c804:       68 c4 ee 00 00          push   $0xeec4
    c809:       68 c4 ee 00 00          push   $0xeec4
    c80e:       68 e8 ee 00 00          push   $0xeee8
    c813:       e8 b5 fc ff ff          call   c4cd <assertion_failure>
    c818:       83 c4 10                add    $0x10,%esp
    c81b:       8b 45 f0                mov    -0x10(%ebp),%eax
    c81e:       83 c0 04                add    $0x4,%eax
    c821:       89 45 f0                mov    %eax,-0x10(%ebp)
    
    c824:       8b 45 f4                mov    -0xc(%ebp),%eax
    c827:       8d 50 04                lea    0x4(%eax),%edx
    c82a:       89 55 f4                mov    %edx,-0xc(%ebp)
    c82d:       8b 00                   mov    (%eax),%eax
    c82f:       85 c0                   test   %eax,%eax
    
    c831:       75 c2                   jne    c7f5 <execv+0x18>
```





### 2021-06-07 22:50

明白了下面的代码为什么能统计参数的个数。耗时14分钟。

```c
// /Users/cg/data/code/os/yy-os/osfs10/d/lib/exec.c
// PUBLIC int execv(const char *path, char * argv[])
// 有多少个参数
	while(*p++) {
		assert(stack_len + 2 * sizeof(char*) < PROC_ORIGIN_STACK);
		stack_len += sizeof(char*);
	}
```



执行`grep -rn "execl" ./*`，查询结果是：

`./kernel/main.c:258:		execl("/echo", "echo", "hello", "world", 0);`。

因为，最后一个参数是0。当循环变量是0的时候，就认为遍历参数结束了。

跑步的时候，我就想到了可能是这个情况，否则，只根据一个指向指针的指针，无论如何也不能结束循环。

之前，我为什么没有想到这点？因为，我孤立地看待这个函数，没有把它放到具体的上下文中。

耗费了大概1个多小时看反编译出来的汇编代码，想找到答案，失败了。我不能完全看懂那些汇编代码，只能看懂部分语句。

遇到看不懂的知识，不要心算，要积极笔算。

egrep -e '^ROOT_BASE' ./boot/include/load.inc | sed -e 's/.*0x//g'

egrep -e '^ROOT_BASE' ./boot/include/load.inc

### 2021-06-08 09:39

理解下面的函数。耗费时间2个小时42分。

```c
PUBLIC int execv(const char *path, char * argv[])
{
	// 书中图10.5 argv，是被调用程序echo中main函数所需的完整堆栈。我们这个execv函数提供的堆栈，只是argv部分的。
	// 它完成的，只是指针数组这部分。前面的参数3和后面的那些字符串，都不是这个函数完成的。
	// 字符串数组的二进制形式是：03450(即字符形式的\0)78240(\0)。这是我的猜测。
	char **p = argv;
	char arg_stack[PROC_ORIGIN_STACK];
	int stack_len = 0;

	// 有多少个参数
	while(*p++) {
		assert(stack_len + 2 * sizeof(char*) < PROC_ORIGIN_STACK);
		stack_len += sizeof(char*);
	}

	// 在哪里添加了参数数量在arg_stack？我没有看到啊。
	// 添加参数数量到数组中后，需要加一个0作为字符串的结束标志。
	// 上面的注释，是错误的。
	// 书上的说法，将指针数组的末尾赋零。原因，我不知道。但是，和书上的图能对应起来。
	// 之所以有这么一句，是为了在do_exec中判断参数个数时使用。遇到等于0的arg_stack成员，表示参数已经全部遍历结束了。
	*((int*)(&arg_stack[stack_len])) = 0;
	stack_len += sizeof(char*);

	char ** q = (char**)arg_stack;
	for (p = argv; *p != 0; p++) {
		// 这句，最难理解。
		// &arg_stack[stack_len] 是内存地址，*q 存储的是内存地址，初始值是arg_stack的初始地址。
		// 更具体，&arg_stack[stack_len] 是 第一个参数的内存地址、第二个参数的内存地址、第三个参数的内存地址。*q 的值依次是前者的内存地址，即 &arg_stack[stack_len] 的值。
		// 阻碍我理解这个函数的问题，先入为主，认为，这个函数构建的供被调用程序echo的main函数调用的栈，应该包含int argc参数。这是错误的。它只构建了包含char **argv的栈。受书中图影响。后来，
		// 我在do_exec中找到了int argc构建。
		// 这么细节的问题，我最终会忘记，面试的时候也无法跟别人说。那么，耗费这么多时间弄清楚它的价值是什么？
    // *q 是什么？只能依靠看各种语句总结出来的经验，*q是一个内存空间。在左边，是内存空间；在右边，是内存空间中的值。
		*q++ = &arg_stack[stack_len];

		assert(stack_len + strlen(*p) + 1 < PROC_ORIGIN_STACK);
		// *p是参数字符串，arg_stack[stack_len]是什么？是具体的值吗？对应于汇编中的eax，而&arg_stack[stack_len]是汇编中的[eax]。
		// 所以，这句，我的理解是，把参数字符串复制到&arg_stack[stack_len]这个内存地址（以这个地址开始的一块内存区域）
		// 上面的注释，我有点怀疑它们的正确性。我又认为，*p是个内存地址，把这个内存地址复制到&arg_stack[stack_len]开始的一块内存区域。
		// char * argv[] 是一个指针数组，即，是一块连续的内存区域，在这个区域内，每块内存里存放的是一个值，这个值也是一个内存地址，而这个内存地址的内存里，存放的是参数。
		// 若没有使用分页机制等内存管理机制，可以文件或内存中查看二进制数据，验证上面的推测。
		strcpy(&arg_stack[stack_len], *p);
		// 这块内存的长度
		stack_len += strlen(*p);
		// 由于存储的是字符串，需要在末尾加0，内存长度也要加1个单位，即加1个字节。
		// 上面的注释不正确，存储的是内存地址。不知道为啥要加0。
		// 我写代码的时候，很难写出这句。我不觉得有必要写这句。
		// 我不理解，strcpy(&arg_stack[stack_len], *p) 用 &，这里用arg_stack[stack_len]，后面能不能也用 &arg_stack[stack_len]。
		// 仍不失很理解啊。两者都是给某个内存地址的内存赋值。这是正确的废话。赋值，当然是将数据放到某片内存中。前者，是函数要求那个参数是一个内存地址，而后者，要求直接对内存中的数据进行操作。
		// 就这样。
		// 为啥要加个0，我仍然不明白。存疑存疑！
		arg_stack[stack_len] = 0;
		stack_len++;
	}

	MESSAGE msg;
	msg.type	= EXEC;
	msg.PATHNAME	= (void*)path;
	msg.NAME_LEN	= strlen(path);
	msg.BUF		= (void*)arg_stack;
	msg.BUF_LEN	= stack_len;

	send_recv(BOTH, TASK_MM, &msg);
	assert(msg.type == SYSCALL_RET);

	return msg.RETVAL;
}
```

我怎么理解？

1. 盯着代码看。

2. 用gdb调试。

3. 调试汇编代码。失败。不能运行到断点。

4. 看汇编代码。看不出来什么。

5. 把疑点抽离到简单的代码中用gdb断点。

   1. ```c
      #include <string.h>
      #include <stdio.h>
      
      int main(void){
              char *h = "hello";
              char *hi = "hi";
              char *world = "world";
              // char **t = {h, hi, world};		// 错误写法
              char * t[3] = {h, hi, world};
              int len = strlen(*t);
              char *str = "";
              strcpy(str, *t);
              printf("a = %d\n", 5);
      
              return 0;
      }
      ```

   2. ```shell
      Breakpoint 2, main () at strcmp-demo.c:17
      17		char *h = "hello";
      (gdb) s
      18		char *hi = "hi";
      (gdb) s
      19		char *world = "world";
      (gdb) s
      21		char * t[3] = {h, hi, world};
      (gdb) s
      22		int len = strlen(*t);
      (gdb) p *t
      $1 = 0x400898 "hello"
      22		int len = strlen(*t);
      (gdb) p len
      $3 = 0
      (gdb) s
      23		char *str = "";
      (gdb) p len
      $4 = 5
      (gdb) ptype *t
      type = char *
      ```

   3. *t是内存地址，但是`strlen(*t)`是内存地址执行的内存中的数据的长度。这是strlen自身的实现方法决定的。

   为什么会这么慢？

   1. 对C语言的掌握程度不够。
   2. 想看汇编代码理解C语言。目前，我的汇编阅读能力没有达到能阅读并理解C代码反汇编出来的汇编代码的水平。
   3. 读汇编代码不如通过举例子的形式来掌握C语言的使用规则。

遇到难题，一定要集中精神多问自己问题，防止自己分神。我总是在遇到难题时分神。

如此优哉游哉地解决难题，若是在考试中，可能会考出一个惨不忍睹的分数。



```assembly
		c861:       8b 45 ec                mov    -0x14(%ebp),%eax
    c864:       8d 50 04                lea    0x4(%eax),%edx
    c867:       89 55 ec                mov    %edx,-0x14(%ebp)
    c86a:       8d 8d ec fb ff ff       lea    -0x414(%ebp),%ecx
    c870:       8b 55 f0                mov    -0x10(%ebp),%edx
    c873:       01 ca                   add    %ecx,%edx
    c875:       89 10                   mov    %edx,(%eax)
    c877:       8b 45 f4                mov    -0xc(%ebp),%eax
    c87a:       8b 00                   mov    (%eax),%eax
    c87c:       83 ec 0c                sub    $0xc,%esp
    c87f:       50                      push   %eax
    c880:       e8 1d fa ff ff          call   c2a2 <strlen>
    c885:       83 c4 10                add    $0x10,%esp
    c888:       89 c2                   mov    %eax,%edx
    c88a:       8b 45 f0                mov    -0x10(%ebp),%eax
    c88d:       01 d0                   add    %edx,%eax
    c88f:       3d fe 03 00 00          cmp    $0x3fe,%eax
    c894:       7e 19                   jle    c8af <execv+0xd2>
    c896:       6a 60                   push   $0x60
    c898:       68 c4 ee 00 00          push   $0xeec4
    c89d:       68 c4 ee 00 00          push   $0xeec4
    c8a2:       68 1c ef 00 00          push   $0xef1c
    c8a7:       e8 21 fc ff ff          call   c4cd <assertion_failure>
    c8ac:       83 c4 10                add    $0x10,%esp
    c8af:       8b 45 f4                mov    -0xc(%ebp),%eax
    c8b2:       8b 00                   mov    (%eax),%eax
    c8b4:       8d 8d ec fb ff ff       lea    -0x414(%ebp),%ecx
    c8ba:       8b 55 f0                mov    -0x10(%ebp),%edx
    c8bd:       01 ca                   add    %ecx,%edx
    c8bf:       83 ec 08                sub    $0x8,%esp
    c8c2:       50                      push   %eax
    c8c3:       52                      push   %edx
    c8c4:       e8 c1 f9 ff ff          call   c28a <strcpy>
    c8c9:       83 c4 10                add    $0x10,%esp
    c8cc:       8b 45 f4                mov    -0xc(%ebp),%eax
    c8cf:       8b 00                   mov    (%eax),%eax
    c8d1:       83 ec 0c                sub    $0xc,%esp
    c8d4:       50                      push   %eax
    c8d5:       e8 c8 f9 ff ff          call   c2a2 <strlen>
    c8da:       83 c4 10                add    $0x10,%esp
    c8dd:       01 45 f0                add    %eax,-0x10(%ebp)
    c8e0:       8d 95 ec fb ff ff       lea    -0x414(%ebp),%edx
    c8e6:       8b 45 f0                mov    -0x10(%ebp),%eax
    c8e9:       01 d0                   add    %edx,%eax
    c8eb:       c6 00 00                movb   $0x0,(%eax)
    c8ee:       83 45 f0 01             addl   $0x1,-0x10(%ebp)
    c8f2:       83 45 f4 04             addl   $0x4,-0xc(%ebp)
    c8f6:       8b 45 f4                mov    -0xc(%ebp),%eax
    c8f9:       8b 00                   mov    (%eax),%eax
    c8fb:       85 c0                   test   %eax,%eax
    c8fd:       0f 85 5e ff ff ff       jne    c861 <execv+0x84>
```

### 2021-06-08 16:40

修复执行自己安装的应用程序，失败了。耗时2小时6分钟。

我做了什么？

1. 阅读do_exec的字面功能，却不知道为何如此写代码就能执行自己写的应用，例如echo。
2. 运行代码，遇到错误。
   1. 我想在全部代码能够正常运行之后再读懂每行代码。
   2. 很久才发现错误出现在哪里，grep搜索关键词无效（原因未知），后来，根据错误信息直接定位到了错误处。
   3. 断点，仍理不清执行流程。
   4. 执行do_exec时，中途会执行open，错误就出现在open中。

这又是一个棘手的问题，我还是在玩黑盒子：

1. 没有去理解comand中的脚本的含义。
2. 依靠断点看结果，没有思考。每次运行后，无明显思考。

现在的问题是：

```c
assert((pcaller->filp[fd] >= &f_desc_table[0]) && (pcaller->filp[fd] < &f_desc_table[NR_FILE_DESC]));
```

时间耗费在哪里？一次次重复执行代码。呵呵，又没有修改，每次执行的结果一定是一样的。不要再做这样的蠢事了。

### 2021-06-08 18:22

运行安装了自己的应用程序的操作系统，又失败了，错误信息如下：

![image-20210608182333679](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/read-note/image-20210608182333679.png)

不再继续往下执行。耗时10分。中途，看了许多其他无用资讯。此种行为，应该受到最严厉的自责！要么学习，要么干脆不学习。不要一边学一边看无用资讯。

在command中使用`make install`后，离成功进了一步。

仍然在玩黑盒子。耗费了这么多时间，连安装应用程序的代码都没有看懂。

在inst.tar中，必须有三个文件，否则，会出现上一个小结中的错误。原因未知。

### 2021-06-10 09:15

运行d版，错误和前一个小结中的错误一样。耗时36分。

我仍然在玩黑盒子。小小修改，反复运行，不理解解压的代码 untar 函数。

### 2021-06-10 09:58

运行d版，错误和前一个小结中的错误一样。耗时41分。仍然没头绪，看无用资讯。

### 2021-06-10 12:24

运行d版，错误和前一个小结中的错误一样。耗时2个小时24分。无头绪。

```shell
[root@localhost d]# xxd -u -a -g 1 -c 16 -s 0xA01800 -l 512 80m.img
00a01800: 01 00 00 00 2E 00 00 00 00 00 00 00 00 00 00 00  ................
00a01810: 02 00 00 00 64 65 76 5F 74 74 79 30 00 00 00 00  ....dev_tty0....
00a01820: 03 00 00 00 64 65 76 5F 74 74 79 31 00 00 00 00  ....dev_tty1....
00a01830: 04 00 00 00 64 65 76 5F 74 74 79 32 00 00 00 00  ....dev_tty2....
00a01840: 05 00 00 00 63 6D 64 2E 74 61 72 00 00 00 00 00  ....cmd.tar.....
00a01850: 06 00 00 00 6B 65 72 6E 65 6C 2E 62 69 6E 00 00  ....kernel.bin..
00a01860: 07 00 00 00 65 63 68 6F 00 00 00 00 00 00 00 00  ....echo........
00a01870: 08 00 00 00 70 77 64 00 00 00 00 00 00 00 00 00  ....pwd.........
00a01880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
*
00a019f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
```

inodes：0x9E1800。

我做了什么？不记得我做过的详细内容，因为，我有什么念头，就试一下。大部分时间，我在运行命令。手很累，大脑不累。

1. 用xxd查看command中的inst.tar。这有啥好查看的？它就是一个打包后的文件，里面的格式当然是没问题的。
2. 玩黑盒子。修改一下boot/include/loader.inc中的内存分布配置，然后运行代码，希望看到奇迹出现。
3. 理解untar。在这里耗费了最多时间。为啥？
   1. 我躺在床上看代码。
   2. 理解不了，分神。
   3. 理解不了知识点。tar文件中，每个文件的文件头的大小是512字节，可是在于上神的代码中，表示文件头的C语言结构`struct posix_tar_header`却只有510个字节。怎么理解？
4. 在汇编代码中断点。
   1. 在untar函数中的第一个while中的close设置断点。打印出pwd后，单步调试。
   2. ret。我以为是返回cs:ip。可我查看到的数据不是这样的，执行时，却返回了正确的指令。这句话写得不好。过一段时间后，我会看不懂。
   3. 错误出现在第三次调用close后。

调试方向，应该是在汇编代码中调试。

先想再调试。调试能力提高了，编程能力将会跃升一个层次。

### 2021-06-10 21:17

解决上一个小结中的错误。这一次，我修复了错误。耗时2个小时。在这两个小时之前，我还调试过，没有记录。

我做了什么？

1. 极度沮丧之后，再次鼓起勇气！老子偏不信这个邪！我就不信我找不出错误！
2. 一边在纸上记录执行流程，一边想好应该在哪里设置断点。
3. 受益于第二个步骤，我发现了，不是open、也不是read直接导致assert错误，而是printf中的write(1,其他参数)导致错误。
4. write(1)---->do_rdwt中，pcaller->filp[1]是0。
5. 由于是从write(1)到do_rdwt，我联想到，在其他进程例如MM进程中，并没有打开终端，所以，pcaller->filp[1]是0x0。
6. 我又追踪了几次pcaller的变化。可惜，我没有看明白IPC的消息中的source是如何赋值、如何变化的。pcaller和source关系很大。所以，我也没有看明白pcaller是怎么变化的。
7. 我在MM进程中打开终端文件，再测试，能正常运行了。非常非常高兴。
8. 再次证明，不要怕困难，困难一定会在我持续不断的努力下被克服。一路走来，我在绝望之时解决了一个又一个困难。

遗留问题：

1. 当cmd.tar文件中包含kernel.bin时，运行不正常。现象是：打印三个文件后就卡住了。

为啥会这么慢？

1. 做了很多无用功，玩黑盒子。
   1. 出现了 invalid inode，我以为出现了invalid opcode，深入汇编代码调试。不要贸然进入汇编代码调试。我还没有熟练掌握汇编，进入反汇编出的的汇编代码，会深陷泥沼不能自拔。
   2. 断点调试C代码，想找出错误代码在哪里。
      1. 各种进程通过IPC跳来跳去，复杂度很大。刚开始调试，不知道在哪里设置断点，说是断点调试，其实我在单步调试。
      2. 单步调试非常非常耗费时间，很容易把我弄晕，基本没啥用。
      3. 调了几次，我知道了怎么在关键位置设置断点，逐步缩小出错代码的范围。
      4. 也许是因为我调试的时候没有思考，先设置个断点，运行到那里，然后再想想看，在哪里设置断点。
      5. 也许是因为我很粗心。
      6. 在C代码中断点调试，我又失败了，收获了很多很多沮丧。
   3. 不甘心。要想写完操作系统，这是绕不过去的坎。我先用纸和笔记录执行过程，然后设计好关键断点。这个方法，让我的调试获得很多有用信息，很细致，定位到了正确的出错代码，然后，慢慢发现了问题。

经验。

1. 根本不应该耗费了一两天的时间。这个问题，没有难理解的算法，只是因为IPC编织了网络，把问题隐藏起来了。使用二分法就能逐步缩小范围。真的不应该花这么多时间。
2. 有多个错误。内存分布和应用的大小。
3. 忘记了。

看看自己的应用程序的执行效果吧。

![image-20210610214029285](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/read-note/image-20210610214029285.png)



### 2021-06-11 09:24

运行 /home/cg/yuyuan-os/osfs10/e ，看shell效果。成功。耗时13分钟。复制粘贴，不费吹灰之力。

### 2021-06-11 09:48

理解了实现shell的主干代码，不理解读取参数的细节。耗时21分钟。

疑点：

1. shell的父进程使用了wait，却没有看到子进程使用exit。

   1. > 在start.asm中调用了exit。(2021-06-17 10:06 补充)

2. 没明白读取参数的C代码。C语言基础不好。

### 2021-06-11 10:14

```c
void shabby_shell(const char * tty_name)
{
	int fd_stdin  = open(tty_name, O_RDWR);
	assert(fd_stdin  == 0);
	int fd_stdout = open(tty_name, O_RDWR);
	assert(fd_stdout == 1);

	char rdbuf[128];

	while (1) {
		write(1, "$ ", 2);
		int r = read(0, rdbuf, 70);
		rdbuf[r] = 0;

		int argc = 0;
		char * argv[PROC_ORIGIN_STACK];
		char * p = rdbuf;
		char * s;
		int word = 0;
		char ch;
		do {
			ch = *p;
			if (*p != ' ' && *p != 0 && !word) {
				s = p;
				word = 1;
			}
			if ((*p == ' ' || *p == 0) && word) {
				word = 0;
				argv[argc++] = s;
				*p = 0;
			}
			p++;
		} while(ch);
		argv[argc] = 0;
		
    // some code
}
```



看了很久这段代码，理解不了。耗费25分钟。我盯着代码看，想用我现有的指针使用经验理解代码，理解不了。我决定，把代码抽出来，用断点调试帮助理解。

```c
do {
			ch = *p;
			if (*p != ' ' && *p != 0 && !word) {
				s = p;
				word = 1;
			}
			if ((*p == ' ' || *p == 0) && word) {
				word = 0;
				argv[argc++] = s;
				*p = 0;
			}
			p++;
		} while(ch);
```

断点调试后，理解了。像这个样子，怎么行啊？又耗时21分钟。

至此，我理解了内存管理和文件系统的主要流程。这意味着，我掌握了《一个操作系统的实现》的主要知识点。

剩余工作，有两个：

1. 彻底理解文件系统和内存管理代码的每个细节。
2. 自己写代码实现文件系统和内存管理。

### 2021-06-17 08:41

看`*p = proc_table[pid];`对应的汇编代码。耗时30分。

放弃了。

我做了什么？

1. 看汇编代码，无法定位这句C代码对应的汇编代码是哪些。定位到`call   c441 <sprintf>`上面，但那些汇编语句，我识别不了。

2. 在第1个步骤，盯着看了很久，无法识别。我决定，在`*p = proc_table[pid];`的前后加上容易识别的C代码。像下面这样：

3. ```c
   int test_flag_start = 5;
   *p = proc_table[pid];
   int test_flag_end = 55;
   ```

4. 对应的汇编代码，

5. ![image-20210617085042168](/Users/cg/Documents/gitbook/my-note-book/cao-zuo-xi-tong-blog/write-os/read-note/image-20210617085042168.png)

6. 仍然太复杂。我不能识别。放弃。

7. ```c
   char *str = "he";
   *str = "A";
   ```

8. 已经在这个问题上耗费了太多时间。又浪费了30分钟却无收获，永久搁置吧。

   1. 这30分，没有记忆知识。
   2. 没有思考。
   3. 盯着不认识的代码心算。
   4. 总结：徒劳！

### 2021-06-17 09:02

打脸自己！我决定，再花点时间弄明白上一个小结中的问题。耗时43分。能看懂语法，但理解不了它们和C代码的对应关系。

弄懂`imul`、`rep`两个指令，就能看懂这段代码。

```c
    6d14:       c7 45 d0 05 00 00 00    movl   $0x5,-0x30(%ebp)
    6d1b:       8b 45 e4                mov    -0x1c(%ebp),%eax
    6d1e:       8b 55 d8                mov    -0x28(%ebp),%edx
    6d21:       69 d2 98 01 00 00       imul   $0x198,%edx,%edx
    6d27:       8d 8a a0 a4 03 00       lea    0x3a4a0(%edx),%ecx
    6d2d:       89 c2                   mov    %eax,%edx
    6d2f:       89 cb                   mov    %ecx,%ebx
    6d31:       b8 66 00 00 00          mov    $0x66,%eax
    6d36:       89 d7                   mov    %edx,%edi
    6d38:       89 de                   mov    %ebx,%esi
    6d3a:       89 c1                   mov    %eax,%ecx
    6d3c:       f3 a5                   rep movsl %ds:(%esi),%es:(%edi)
    6d3e:       c7 45 cc 37 00 00 00    movl   $0x37,-0x34(%ebp)
```

1. `rep movsl %ds:(%esi),%es:(%edi)`，movsb指令用于把字节从ds:si 搬到es:di；rep是repeat的意思，rep movsb 就是多次搬运。搬运前先把字符串的长度存在cx寄存器中，然后重复的次数就是cx寄存器所存数据的值。
2. `imul   $0x198,%edx,%edx`
   1. `imul`，带符号整数乘法。
   2. `mul`，无符号整数乘法。
   3. 这句的意思是：把`0x198`和`edx`中的数据相乘，把乘积存储到`edx`中。
3. 关键差异
   1. `rep movsl %ds:(%esi),%es:(%edi)`
   2. `movb   $0x41,(%eax)`
   3. 这两句有差异吗？我认为，无差异啊。
   4. 根据编译器执行结果看，应该有差异。
      1. `movb   $0x41,(%eax)`，`(%eax)`是指内存地址是X的内存空间的数据，是数据。
      2. `rep movsl %ds:(%esi),%es:(%edi)`，`%ds:(%esi)`、`%es:(%edi)`都是内存地址。
      3. 为什么要这样理解？一种规定吧。只是我觉得这两种汇编的形式很相似，所以，我觉得它们执行的操作相同，其实，可能不同。

这个问题，就到处为止吧。还有那么多重要内容需要去掌握。

### 2021-06-17 10:08

把本笔记复习了一次。耗时31分钟。

我做了什么？

1. 浏览笔记；大部分能看懂；详细的思考过程，不是很懂。
2. 在`char  *str="hello"; *str = 'A';`这个问题耗费了最多时间，仍没弄明白，还是只能依靠经验去合理猜想。有收获：
   1. `imul`
   2. `rep movsb`。

本笔记内容少，间隔时间短，很多东西，我还记得。

复习，浪费了这么多时间。不复习，一个月后再看，那将不是复习，而是重学。

https://kk.org/thetechnium/68-bits-of-unsolicited-advice/



使用brew查找相关解压命令

brew search 7z

brew install p7zip

解压

7z e filename.7z		// 会解压到根目录，不方便

7za x filename.7z



修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成。如：

    (gdb) ***\*print x=4\****



1、承担全公司统一化底层分布式存储平台的设计和研发工作，这是类似阿里盘古的纯自研系统；
2、面向整个快手产品和业务、容器云、CDN以及其他技术团队交付和提供EB级别、强一致、超高性能、超低延迟、高可用、高可靠、功能完备、运维友好、业界领先的分布式文件存储、块存储和对象存储、分布式Log等存储服务；
3、针对量级不断发展的快手图片、短/长视频、压缩加密、算法处理、安全等业务域，设计和研发、优化并解决相关领域内的存储侧痛点，根据业务需求和特点进行存储优化，综合提升存储性能、成本和稳定性；
4、持续推动公司存储技术栈的优化和演进，推动存储新趋势和技术在快手落地，不断进行架构升级和演进。
职位要求：
1、本科及以上学历，计算机科学与技术、软件工程或相关专业方向；
2、熟练掌握 C/C++/Golang，有扎实的计算机基础，对数据结构、算法基础有扎实掌握，对计算机体系结构、操作系统、计算机网络、文件系统、IO、存储设备有深刻理解；
3、掌握分布式系统基础理论/协议/paper、熟悉业内经典分布式存储系统，有大规模分布式存储平台、云厂商云存储研发经验者优先、有开源存储比如Ceph/HDFS/etcd/KV/nosql/glusterFS/SeaweedFS等系统开发经验者优先；
4、熟悉Linux内核以及底层存储相关经验优先，有01自研分布式存储系统经验者优先，或熟悉块存储、文件存储、对象存储中的一种或多种；
5、熟悉SPDK/NVMe-OF/RDMA等用户态IO技术者优先；
5、对技术充满热情，有较强的责任心和抗压能力，有较好的沟通能力，能快速融入团队，有较强的学习能力，能快速掌握最前沿的技术。
职位诱惑：
我们是一支非常非常 nice 的存储技术团队，虽然我们的存储平台起步较晚，但是我们站在前人巨人的肩膀上，博取众家之长，我们坚信我们能做得更好！欢迎各位牛人、大咖加入！！！职位开放，薪资开放，成长空间更加开放！
PS：我们还有漂亮的存储服务端研发 MM 哦！！



职位描述：
1、负责分布式存储系统研发及性能优化工作；
2、结合业务特点和需求，有针对性地优化性能和解决业务线需求；
3、负责分布式数据存储等基础技术研究 。
任职要求：
1、熟练掌握至少一种下列编程语言：C/C++、Java、Python、Go；
2、熟悉数据结构、算法设计；
3、熟悉存储设备、文件系统、Linux操作系统原理；
4、有钻研精神，学习能力强，具有良好的沟通能力和团队协作精神；
5、有大规模分布式系统研发及实施经验者优先；
6、熟悉分布式系统理论优先；
7、有业界分布式系统经验，包括Ceph/S3/GFS/BigTable/Hbase/Hadoop/HDFS优先。



职位职责与要求
1、负责自研OLAP数据库产品的内核开发
2、希望你有分布式数据库/分布式文件系统/Postgresql内核开发的经验
3、了解主流OLAP产品的实现
4、了解Hadoop生态的OLAP引擎
5、开发语言主要是C，也会用到Java，python等其他语言。
6、选择一门擅长的语言来参加面试，用来考察代码能力和算法能力



### 职位描述

工作职责：
\1. 参与大规模AI容器云核心模块设计、开发、优化、交付
\2. 核心功能落地并保障功能稳定性
\3. 分布式场景下定位和排查故障，需要深入到分布式系统组件以及操作系统内核
\4. 前沿技术探索并持续将有价值的部分实践至真实场景：包括但不限于云原生社区持续出现的新的主流及成熟技术
任职资格：
\1. 精通至少一种：c/go/c++
\2. 擅长系统性能瓶颈以及故障定位，对操作系统、网络、数据结构、编译等专业知识有比较系统的学习和认识
\3. 肯深入、耐心研究源码
\4. 对工作有热情、对产品有责任心、有团队协作能力
\5. 有源码级实践linux内核/kubernetes生态系统者优先
注：如果对口的话，工作地点在多个一线城市都支持
同时也欢迎对应场景的产品经理岗位全职或者实习生联系我！



工作职责：
1、负责结合不同业务特点对linux内核进行性能调优
2、负责按照不同业务服务特点定制Linux内核，结合业务需求开发内核新功能
3、内核新技术的研究和应用
4、参与Kubernetes/Docker的运维支持、性能调优、监控、故障诊断等工作，并赋能业务
岗位职责：
1、计算机本科及以上学历，5年以上系统内核相关开发经验
2、精通linux内核，通读内核中的主要模块(调度器、内存管理、中断、存储、文件系统、TCP/IP, I/O，内存管理)之一的源代码
3、精通Linux平台上的网络编程，C语言编程，多进程多线程编程等
4、熟悉KVM、LXC、Docker等虚拟化相关技术
5、了解主流内核&资源隔离技术(cgroup,namespace)的实现，熟悉隔离技术源代码
6、优异的分析问题和解决问题的能力，良好的逻辑思考能力，和追求技术深度的热情
7、优先云厂商公司背景如华为，阿里，金山，腾讯等