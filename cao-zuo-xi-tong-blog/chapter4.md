# 让操作系统走进保护模式

## FAT12

FAT12是一个DOS时代的文件系统。

文件系统，是一种提供在磁盘等存储设备上提供数据读写功能的软件，自身也需要存储在存储设备上。

FAT12的结构是：引导扇区、2个FAT区域、根目录、数据区。

引导扇区也是一个扇区，所以，它的大小是512字节。引导扇区是整个软盘的第0号扇区。

一个FAT结构的大小是9个扇区，2个FAT结构所占空间是18个扇区。2个FAT结构的内容相同，互为对方的冗余、副本。

根目录区位于第二个FAT表之后，初始位置是19号扇区，第20个扇区。根目录区由若干个目录条目区（Directory Entry)组成，条目最多有BPB_RootEntCnt个。由于根目录区的大小是依赖BPB_RootEntCnt的，所以长度不固定。

根目录的每个条目占用32字节。根目录区条目的格式包含下列内容：文件名8字节、扩展名3字节，此条目对应的开始簇号，文件大小，文件属性，最后一次写入时间，最后一次写入日期，保留位。

数据区的第一个簇号是2，不是0或1。若目标文件的开始簇号是2，那么，此文件的数据开始于数据区的第一个簇。

在软盘中查找文件的方法是，遍历根目录，检查每个根目录区的每个条目的文件名是不是目标文件名，若是，这个根目录区条目就是要找的文件的根目录区条目，此根目录区条目中的开始簇号就是目标文件的第一个簇号X。在FAT表中找到第X个条目。

可以用xxd查看存储在FAT12系统中的数据。

引导扇区中的结构成员分为两类：前缀为BS和前缀为BPB。

BPB的全称是BIOS Parameter Block。

数据区的第一个扇区在哪里？需要计算出根目录区占用多少个扇区。假设根目录占用扇区RootDirSectors个，计算公式如下：

RootDirSectors = (BPB_RootEntCnt * 32 + 每个扇区占用的大小-1) / 每个扇区占用的大小。

这么怪异而不直观的公式，原因是，当根目录占用扇区不足一个扇区时，根目录扇区占用的扇区数应该是1；根目录占用扇区大于一个扇区而不足两个扇区时，根目录扇区占用的扇区数应该是2。理解这个公式，都让我费了点功夫。

每个FAT项占用12个字节，包括一个字节和另一个字节的一半。这意味着，一个FAT项可能会跨域两个扇区。

每12位称为一个FAT项，第0个、第1个FAT项从来不使用，从第2个FAT项开始使用。

FAT项的值代表文件的下一个簇号。如果值大于等于0xFF8，表示当前簇是文件的最后一个簇。如果值是0xFF7，表示当前簇是一个坏簇。

一个簇只有一个扇区，所以，簇号即扇区号。FAT项的值表示的是数据区的簇号，计算这个簇号在磁盘中的位置时，需要加上前面的19个扇区。

## DOS可以识别的引导盘

我要开发的操作系统和DOS有什么关系？

什么样的引导盘才能让DOS可以识别？

引导扇区加上BPB头等信息才能让引导盘被DOS识别，同时才能被Linux识别。

BPB头等信息分为两大类，分别是前缀为BPB_和前缀为BS_的数据。

书上没有写清楚为啥有BPB头等信息就可以被DOS和Linux识别。

第一条指令是跳转指令，第二条是让CPU空转的指令，如下：

```assembly
jmp	LABEL_START		; Start
nop
```



BPB头等数据不需要在软盘的最开始位置吗？

## 一个最简单的loader

初始内存地址是 0x100，使用 `orgin 0100h` 完成。

在屏幕上打印字符 L，方法是往显存写入 L，指令是 `mov al 'L'   mov [gs:(80*0+39)*2], al` 。

然后，是一个死循环，指令是 `jmp $` 。

把这个loader编译成 COM 文件，可以在 FreeDos 中直接运行。注意，不要使用 DOSBox，使用很不方便。使用 bochs 中的 FreeDos，很方便。我曾经成功使用过，不过，可能没写文档，也可能不知道把文档放到哪里了。再使用它时，一定要写准确的文档。

## 加载loader入内存

### 公式

能使用的内存有多少？足够加载loader吗？

实模式下，能使用的最大内存是1M。软盘容量是1.44M。loader最大是1M吗？不是，必须小于1M。那么，loader最大是多少？

loader是怎么到软盘上的？

复制到软盘上的。用几个linux命令复制到软盘上的。

如何在软盘上找到loader？

使用BIOS中断 `int 13h`。它像高级语言中的函数，需按要求提供参数给它。我之前使用过BIOS中 `int 15h` 来获取内存。

还是书本上的讲解能抓住重点。`int 13h` 需要的参数是柱面号、磁头号、当前柱面上的初始扇区号，而不是软盘的0号扇区。

一个软盘有2个磁头，每个盘面有80个磁道，每个磁道有18个扇区，每个扇区有512字节，所以，一个软盘的大小是：
$$
2 * 80 * 18 * 512 = 1440 byte
$$
1.44M，是个估算值。

磁头号、柱面号、起始扇区号是怎么计算出来的？已知条件是扇区号，这个扇区号是在整个软盘中的扇区号。我不明白，这个扇区号是怎么得到的。

在已知整个软盘中的扇区号的前提下，计算步骤如下：

1. 扇区号除以每个磁道包含的扇区的数量，商是Q，余数是Y。

2. 柱面号 = Q >> 1。

   1. 对此，我有疑问。

   2. Q是磁道数，每个柱面有2个磁道，一共有多少个柱面呢？是磁道的一半。

   3. 对这个结果，我本无异议。可是，代入具体数据，却发现计算结果与正确结果有差异。

      1. 当Q = 0时，柱面号是0。
      2. 当Q = 1时，柱面号是0。
      3. 当Q = 2时，柱面号是1。
      4. 当Q = 3时，柱面号是1。
      5. 当 Q = 4时，柱面号是2。
      6. 当 Q = 5 时，柱面号是2。
      7. 当 Q=6时，柱面号是3。

   4. 柱面的初始编号是0还是1？如果是0，上面的例子反倒证明

   5. $$
      柱面号 = Q / 2
      $$

      是正确的。若柱面的初始编号是1，那么，计算柱面号的公司应该修改为：
      $$
      柱面号 = （Q / 2) + 1
      $$

3. 磁头号 = Q & 1。
   1. 又不理解。
   2. 磁头号要么是0，要么是1。用具体数据来理解吧。
      1. Q = 0，0 & 1 = 0。磁头号是0，即扇区在第0盘面。
      2. Q = 1,  1 & 1 = 1。磁头号是1，即扇区在第1盘面。
      3. Q = 2, 2 & 1 = 10b & 1 = 0。
      4. Q = 3, 3 & 1 = 11b & 1 = 1。
   3. 这个公式，计算出来的结果，是正确的。可是，不看这本书，我不可能推导出这个公式。这个公式是怎么想出来的？
   4. 判断磁道的序号（从1开始，第N个磁道）的最低位是否为1就能判断这个磁道在哪个盘面，为什么？
   5. 这和操作系统的任何领域知识无关，只是个应该很容易的数学计算而已。我却花了很多时间不能推导出来。

计算磁头号的方法

https://blog.csdn.net/jj9876jj/article/details/5252329?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&spm=1001.2101.3001.4242

不必使用这么复杂的方法。

有两个磁头，意味着同一个编号的磁道有两道。扇区号 / 每个磁道包含的扇区的数量 = 该扇区在第多少个磁道 C。第奇数个磁道在1磁头，第偶数个磁道在0磁头（序号初始值是0）。怎么会有这么个结论？归纳法。

1. 第0个磁道，在0磁头。
2. 第1个磁道，在1磁头。
3. 第2个磁道，在0磁头。
4. 第3个磁道，在第1磁头。

只需要判断C是偶数还是奇数就能知道该扇区所在的磁头数。而检查一个数是奇数还是偶数的方法是：C & 1 。它的结果是0，偶数；它的结果是1，奇数。若要问为什么？这是常识。

若有三个磁头，磁道数 = C / 3。余数是磁头号。

这么一个简单的问题，花费了2个多小时。没有明确的思考思路。找到了网上的复杂的做数学题的计算方法，没看懂。但我突然明白了如何理解作者这个计算公式。

起始扇区号怎么计算？

这里的起始扇区号是指在A柱面C磁头的起始扇区号。起始扇区号 = 余数 + 1。为啥要加1？因为各磁道内的扇区编号的起始编号是1。余数是在磁道内的偏移量。当偏移量是0时，扇区号是1；当偏移量是1时，扇区号是2。

### 代码

### int 13h

代码中的难点，是对 `div` 指令的使用。

| 被除数  | 除数     | 商   | 余数 |
| ------- | -------- | ---- | ---- |
| ax      | reg/mm8  | AL   | Ah   |
| Dx:ax   | reg/mm16 | ax   | Dx   |
| Edx:eax | reg/mm32 | eax  | edx  |



`int 13h` 中断，参数如此套路化，我自己写，也只能写出一个一模一样的。调用参数如此多，不花点时间，我哪里能记得住呢？怎么才叫自己写？

使用 `int 13h`，首先要复位软驱，需提供的参数是：ah = 00h，dl=驱动器号（0表示A盘），代码是：

```assembly
xor	ah, ah	; `.
xor	dl, dl	;  |  软驱复位
int	13h	; /
```



注意咯。`int 13h` 因参数不同，具有不同的功能，一个是软驱复位，一个是读取软盘。

读取软盘需要的参数是：

| 寄存器 |                             参数解释 |
| ------ | -----------------------------------: |
| ch     |                               柱面号 |
| cl     | 起始扇区号，在A柱面B磁头的起始扇区号 |
| dh     |                               磁头号 |
| dl     |                             驱动器号 |
| ah     |                          02h，读数据 |
| al     |                           要读扇区数 |

将表格中的寄存器赋值后，使用 `int 13h`，就能将数据读入 es:bx 指向的缓存区。

这个参数，多难记啊。

怎么使用FAT项查找文件呢？

需要使用FAT项中的两项数据，文件名F和文件在数据区的第一块数据对应的编号N。

N有两层含义，一是FAT项在FAT中的编号，二是在数据区的簇编号。FAT项的编号的初始值是0，第零个和第一个是不使用的，从第二个开始使用。当一个文件的第一个簇号是2的时候，它在FAT中的第一个FAT项的编号是2（编号0、1的FAT项不使用），第一块数据在数据区的第一扇区（一个簇只有一个扇区）。若编号为2的FAT项的值是8，则第二块数据在数据区的第（8-2）扇区。

7654 | 3210(byte1)  7654|3210(byte2)  7654|3210(byte3)

7654|3210(byte5)  7654|3210(byte4)  7654|3210(byte3)   7654|3210(byte2)    7654 | 3210(byte1) 

ax = 4

4 * 3 = 12，12 / 2 = 6

5 *3 = 15， 15 / 2 = 7

2*3 = 6

3*3=9

一个FAT项占用1.5字节，2个FAT项占用3字节，3个FAT项占用4.5个字节，4个FAT项占用6字节，5个FAT项占用7.5字节。

FAT项编号乘以3，结果，没有啥特殊含义啊。

编号是3，乘以3，等于9。9这个数字，如何理解？编号为9的FAT项吗？

3-->4.5

2--->3

4--->6

FAT项编号是什么？

编号为0的FAT项，在FAT中的偏移量是0字节。在FAT中的偏移量（单位是扇区）是0个扇区。

编号为1的FAT项，在FAT中的偏移量是12位（1个字节 + 0.5个字节）。在FAT中的偏移量（单位是扇区）是0个扇区。

​	1. 1 * 3 / 2，商是1，余数是1。在扇区的偏移量（单位是字节）是1个字节。

编号为2的FAT项，在FAT中的偏移量是24位（3个字节）。在FAT中的偏移量（单位是扇区）是0个扇区。

5							4							 3						 2							1						0

|--------------------|--------------------|--------------------|--------------------|--------------------|

	1. 2 * 3/2，商是3，余数是0。
 	2. 3 / BytesPerSector = 0...3。在扇区的偏移量（单位是字节）是3个字节。

编号为3的FAT项，在FAT中的偏移量是36位（4个字节 + 0.5个字节）。在FAT中的偏移量（单位是扇区）是0个扇区。

根据FAT项编号获取FAT项内容，有两大难点：

1. 把FAT项编号换算成FAT项在FAT内的扇区偏移量和在扇区内的字节偏移量。
   1. 先乘以3，再除以2，怎么理解？
      1. 把FAT项编号换算成字节数。
      2. 没啥好方法。就这么理解。一个FAT项1.5个字节，编号为X的FAT项的偏移量是X * 1.5个字节。由于汇编语言不能直接完成这个运算，所以，只能转化为先乘以3再除以2。
      3. 先乘以3再除以2，商是字节数，余数是不足1字节的bit位的数量。
         1. 商是字节数，能在下面的运算（计算扇区偏移量时使用）。
         2. bit的数量，作用只是判断，FAT项的偏移量是不是刚好是1字节的整数倍。这决定了编号为X的FAT项所占用的内存是不是刚好在若干个完整的字节内。
            1. 若不在完整的字节内，从字节偏移位置，获取16位内存区域的数据，其中这16位内存区域的数据中，前4位是属于(X-1)编号的FAT项。所以，有指令 `shr ax, 4`。这是画图（就是打草稿）使用具体例子来理解的。要我自己想出来，很不容易啊。别人写出来，我都理解了这么久。
            2. 若在完整的字节内，直接获取16位内存区域的低12位的数据，那就是编号为X的FAT项的值。
2. 获得第一步数据后，根据在扇区内的字节偏移量的值的特征获取FAT项的值。



GetFATEntry

怎么理解这个函数？

它的参数是：FATEntry编号X，即在FAT区域内的偏移量。

它的返回值是：编号为X的FATEntry的那块内存区域。

首先，检查编号为X的FATEntry的字节偏移量是否占用整数个字节。

	1. 是，直接从偏移字节开始，获取1个字的内存，这个字的低12位就是目标内存区域。
 	2. 不是，从偏移字节开始，获取1个字的内存，这字的高12位就是目标内存区域。低4位是编号X-1的FATEntry的高4位。

难点是，如何检查编号为X的FATEntry的偏移量是否占用整数个字节。

一个FATEntry占用12位，即1.5个字节，FATEntry的编号乘以1.5的结果，看它们是不是整数个字节。

1. 若是整数，占用整数个字节。
2. 若不是整数，占用的不是整数个字节。

汇编语言不支持直接乘以1.5，于是，采用等效方法：先乘以3，再除以2。检查结果是不是整数。

	1. 余数不是0，不是整数。
 	2. 余数是0，是整数。

这是根据作者的代码反推出来的理解。对我而言，也不是顺其自然的。

耗费时间8个小时左右，才彻底理解了。

理解过程分为两个阶段：

一、毫无头绪，不知道为啥需要乘以3，然后再除以2。只是盯着代码看，毫无思路。

二、搜索资料，仅仅找到两篇资料。

https://www.ituring.com.cn/book/tupubarticle/26325

https://blog.csdn.net/robbie1314/article/details/5765117

这本书的内容，真的不热门。从网络资料这么少就能看出来。

资料解释得也不好。回头来看，这句话其实说出了关键点：

> 因为每个FAT表项占1.5 B，所以将FAT表项乘以3除以2（扩大1.5倍）

我开始把“乘以3再除以2”理解为计算X个FATEntry占用多少个字节。

剩下的问题是：

一、乘以3再除以2，究竟是如何产生这种运算的。

二、第一个问题中的运算的商，除以每个扇区包含的字节数，如何理解。

	1. 我一直把这个商理解为FATEntry的编号。经过第一个问题中的运算后，商是在扇区偏移量。
 	2. FAT项占用整数个字节问题。通过画图、用具体例子来理解的。34 * 57 等于多少，以前做数学题我都需要使用笔算，为啥在编程中理解问题要用心算呢？我的心算效率很低，遇到难题，容易分心，思路非常不连贯。要多用笔算。

三、es:bx，总感觉不怎么理解。通过读取软盘，包含FAT项的两个扇区被读取到了[es:bx]为初始位置的内存区域。

​	1. bx会增加吗？

