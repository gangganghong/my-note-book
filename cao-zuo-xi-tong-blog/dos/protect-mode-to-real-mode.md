# 从保护模式返回实模式

这个demo，从实模式进入保护模式，再从保护模式返回实模式，就结束了。其他的一切，都是完成两种模式切换的条件。

啥也不说，先把于上神的代码复述一次。

用宏`Descriptor`创建全局描述符：

1. 16位段的描述符`LABEL_DESC_16`，在实模式下使用。
2. 32位段的描述符`LABEL_DESC_32`，在保护模式下使用。
3. 视频段的描述符`LABEL_DESC_VIDEO`，在保护模式下使用。
4. 第一个描述符`LABEL_GDT`。

在实模式下能使用描述符吗？

描述符已经彻底掌握，我打算直接复制粘贴原来的代码。没必要在已经掌握的知识点、而且以后极少用到的知识点上耗费时间。

再创建GdtPtr。它存储GDT的内存地址。很简单，直接写出来。

```assembly
BaseOfLoaderPhysicalAddress	equ	08000h
GdtLen	equ	$ - LABLE_GDT
GdtPtr
	dw	GdtLen - 1
  dd	BaseOfLoaderPhysicalAddress + LABEL_GDT
```

使用`lgdt [GdtPtr]`把这个结构加载到专门存储GDT内存地址的寄存器`gdtr`中。

创建选择子。

```assembly
SELECTOR_16	equ	LABEL_DESC_16 - LABEL_GDT
SELECTOR_32	equ	LABEL_DESC_32 - LABEL_GDT
SELECTOR_VIDEO	equ	LABEL_DESC_VIDEO - LABEL_GDT
```

安装描述符。例如，安装实模式下的代码段的描述符。

```assembly
[SECTION .16]
ALIGN 16
[BITS 16]

;获取段的基地址，计算方法是，段地址*16 + 偏移量。因为，段的基地址就是这个段的初始内存地址，即在整个内存中的内存偏移量。
mov eax, cs
shl eax, 4
add eax, LABEL_16
mov [LABEL_DESC_16+2],ax
shr eax, 16
mov [LABEL_DESC_16+4], al
mov [LABEL_DESC_16+7], ah

LABEL_16:
	mov ax, 0xb800
	mov gs, ax
	mov al, 'A'
	mov ah, 0Fh
	mov [gs:(80 * 20 + 20) * 2], ax
```

安装好描述符后，按下面的流程进入保护模式。

```assembly
;加载GDT
llgdt [GdtPtr]
;关闭中断
cli
;打开A20
in ax, 92h
or ax, 10b
out 92h, ax
;把cr0的PE位设置为1
mov ax, cr0
or ax, 1
mov cr0, ax
;跳入保护模式
jmp dword SELECTOR_32:0
```

进入保护模式后，返回实模式。

`cr0`、中断这些，在`SECTION .32`完成还是在`SECTION .16`完成？

回到实模式，用一句跳转语句完成，和进入保护模式时一样。

跳转目标是哪个段？是一个`SECTION .16`，这没有争议。是跳转到更新描述符的那个`SECTION .16` A还是新建的`SECTION .16` B?

第一种情况，跳转到A。

```assembly
[SECTION .32]
ALIGN 32
[BITS 32]

LABEL_32:
	; 设置段寄存器
	mov ax, SELECTOR_32
	mov ds, ax
	mov es, ax
	mov ss, ax
	mov fs, ax
	
	mov gs, SELECTOR_VIDEO
	
	mov ax, (80 * 20 + 22)*2
	mov esi, ax
	mov al, 'B'
	mov ah, 0Fh
	mov [gs:esi], ax
	
	;返回实模式
```

整体布局：

1. 第一个`[SECTION .16]`没有描述符。它完成的功能：
   1. 更新所有描述符的段基址部分。
   2. 进入保护模式。
2. `[SECTION .32]`，只有一个。它完成的功能：
   1. 更新段寄存器。
   2. 打印一个字符。
   3. 跳入另一个段内，这个段返回实际模式。
3. 第二个`[SECTION .16]`。它完成的功能：
   1. 更新段寄存器。这是切换模式所必须的。

上面的阐述方法不好。还是按代码的执行流程阐述更好。

1. 第1个段SegA。

   1. 安装描述符。
   2. 加载GDT的内存地址。
   3. 关闭中断。
   4. 打开A20。
   5. 打开cr0的PE位。
   6. 跳转到保护模式下的SegB，同时更新了段寄存器cs的值。

2. 第2个段SegB。

   1. 更新段寄存器。
   2. 打印一个字符。
   3. 跳转到段SegC。

3. 第3个段SegC。

   1. 更新段寄存器ds、es、fs、ss。

   2. 关闭cr0的PE位。

   3. 跳转到SegA。

      1. 实现跳转的方法，是重点，也是难点。

      2. 指令是`jmp 0:LABEL_ENTRY`。

      3. 此时的寻址方式已经使用实模式的寻址方式。这条语句为什么能跳转到SegA呢？

         1. 执行到`jmp 0:LABEL_ENTRY`时，实际的指令已经不是在代码中看到的这条段基址是0的语句。

         2. 在SegA中的`mov [LABEL_GO_BACK_TO_REAL+3], ax`已经把`jmp 0:LABEL_ENTRY`中的段基址修改为SegA的段基址。

            1. 为什么这么说？

            2. 实模式下，长跳转指令示意图是：

               1. | 指令（BYTE 0) | 偏移量(BYTE 1\|BYTE2) | 段基址(BYTE3\|BYTE4) |
                  | ------------- | --------------------- | -------------------- |
                  | Jmp           | LABEL_ENTRY           | 0                    |

                  修改第3个字节、第4个字节的值为ax，而ax的值又是SegA的基地址。

      4. 为什么使用这么怪异的方式跳转呢？

         1. 不使用这种方式，还有哪些方式能使用？条件是在SegC中，已经进入实模式，选择子已经不能使用。
            1. `jmp 选择子：偏移量`。不能使用。
            2. `jmp 段基址：偏移量`。能使用。
            3. 当前，第二种方式是唯一能实现长跳转（不同的段之间跳转）的方式。

      5. 为什么不直接在SegB跳回SegA？

         1. 要回答这个问题，先弄清楚跳回SegA必须做哪些事，再看这些事能不能在SegB做。
         2. 必做的事情：
            1. 关闭cr0的PE位。能做。
            2. 用实模式下的内存寻址方式实现长跳转。
               1. 在能获取SegA的代码段的地址SegACS的时候，修改跳转语句中的段地址。只有在SegA才能获取SegACS。
               2. 进入SegB后，想获取SegACS，只能在SegA中把SegACS存储到某个寄存器中。
                  1. 不知道段地址能否被存储到其他非段寄存器中。能。
               3. 在保护模式下跳入SegA后，SegA的cs被更新为SelectorNormal（SegA的选择子）。

### 问题

怎么从实模式进入保护模式？

1. 创建好GDT。
2. 创建好GdtPtr，保存GDT的物理地址和GDT中的字节限制（初始值是0，最大值是GDT的长度减1）。
3. 把GdtPtr放入专用寄存器`gdtr`，`lgdt [GdtPtr]`。
4. 关闭中断，`cli`。
5. 打开`A20`。
6. 打开`cr0`的PE位。
7. 跳入保护模式，`jmp dword 32位段代码段选择子:偏移量`。

执行``jmp dword 32位段代码段选择子:偏移量`时，已经是在保护模式下，但代码是在16位模式下编译的，使用`dword`使得操作数大于16位时不会被截取为16位。

`dword`会使`jmp dword 32位段代码段选择子:偏移量`这条语句在16位代码下加上反转前缀`0x66`。有了这个前缀，操作数`偏移量`会被扩展为32位。这是作者的猜测。未经证实。

从实模式进入保护模式的流程，是一个比较固定的模板，除了那句跳转语句，作者也没有其他疑问。没有什么好纠结的。

那么，怎么从保护模式切换到实模式？

1. 先从保护模式下的32位代码进入保护模式下的16位代码。
2. 在保护模式下的16位代码段设置ds、es、fs、gs、ss的值是normalSelector选择子（一个符合实模式要求的选择子）。
3. 关闭cr0的pe位。
4. 跳回实模式下的16位代码段。
   1. 使用直接修改内存中指令”段基址：偏移量“中的”段基址“的方式实现的。段基址是实模式下的16位代码段的段基址，P。
   2. 不直接修改内存中的指令，能不能跳回到目标代码段？
      1. 能。不过，只能在实模式下的16位代码段中把P保存到某个寄存器或栈中。然后，在保护模式下的32位代码段中再取出来。
      2. 32位代码中，不能使用那个存储了P的寄存器。
      3. 32位代码中，不能切换栈空间，或者，需要将栈空间切换回16位代码段。
      4. 这一系列操作，想想都麻烦，不使用比较好。
      5. 就是说，直接修改内存中的指令，不是唯一方法，却是简单不容易出错的方法，只不过，我理解起来有点困难。
   3. 在实模式下，`jmp SegAddress:Offset`不会修改CS段描述符高速缓冲寄存器中的值。
      1. 为什么？CPU就是这样的，我没有读到相关资料。我的猜想是：
         1. 实模式下，段界限都是64K，CS对应的段描述高速缓冲寄存器之外的缓存寄存器中的段属性都是可读可写的，CS对应的段描述高速缓冲寄存器中的段属性是可执行的，特权级都是相同的，实际上，没有特权级。
         2. 简言之，数据段是可读可写的，代码段是可执行的，段界限都是64K。
         3. 在进入实际模式前，段描述符的高速缓存寄存器中就应该符合上面的要求，而不是进入实模式后才设置缓存寄存器中的值，因为，在进入实际模式时，会先检查这些缓冲寄存器中的值，若不满足要求，不能进入实模式（异常、错误、中断等）。
         4. 上面是我的猜想，能自圆其说，没有资料佐证，没有用运行代码去证实。
   4. 进入实模式前，也就是在保护模式下，需要设置实模式对数据段的要求、对代码段的要求。
      1. 实现数据段的要求，用`mov ds, 选择子`。
      2. 实现代码段的要求，需要更新CS中的值（同时更新CS对应的缓冲寄存器中的值）。
         1. CS的值只能用`jmp`、`retf`、`call`等实现。

不能从保护模式下的32位代码段直接返回实际模式，为什么？

用反证法。

第一种，在32位代码中，

1. 关闭cr0的PE位。我猜想，执行这个操作后，马上就会报错。理由如下：
   1. 进入实模式前，CS段描述符的高速缓冲寄存器的值仍是保护模式下的值，不能符合进入实模式对缓冲寄存器中的值的要求。
2. 直接使用`jmp 16位代码段段基址：16位代码段偏移量`跳回16位代码段。

第二种，

1. 在32位代码中，直接使用`jmp 16位代码段段基址：16位代码段偏移量`跳回16位代码段。
   1. 更正上面的跳转语句为`jmp 16位代码段选择子：16位代码段偏移量`。这才是保护模式下的内存寻址方式。
   2. 执行上面的语句后，CS和CS对应的高速缓冲寄存器中的值C被更新。但是，C仍然是保护模式下的值，仍然不符合实模式的要求。
2. 在16位代码段中，关闭cr0的PE位。
   1. 关闭cr0的PE位后，进入实模式。
   2. 紧接着，检查段描述符高速缓冲寄存器中的值。由于缓冲寄存器中的值仍然是保护模式下的值，不符合实模式的要求。
   3. 上面两个步骤的顺序是不是这样，我不知道。无论哪个顺序，都不能进入正常实模式。

上面两种情况，实际上是同一种情况，在关闭cr0的PE前，CS段描述符高速缓冲寄存器中的值都是保护模式下的。

第二种情况比较有迷惑性。补充对它的限定条件：16位代码段是进入保护模式的那个16位代码段，而不是其他段属性不同的16位代码段。

 1. 不能使用选择子进入在进入保护模式前的代码。

     	1. 为什么不能？
          	1. 给进入保护模式前的代码也设置一个段描述符。
          	2. 这已经乱套了。CPU在实模式下，根本没有”段描述符“这个概念，没有这个东西，CS:IP中，不用到段描述符。
          	3. 所以，不能。
          	4. 实模式下不用段描述符，可保护模式下用啊。我在保护模式下用段描述符直接跳回到16位代码段。理论上没有问题啊。
          	5. 不能自圆其说了。

    

## 正确的结论

上面的思考过程，有不少问题。下面的回答，是正确的。

为什么不能在保护模式下的32位代码段返回实模式下的16位代码段？

为什么在保护模式下的32位代码段返回实模式下的16位代码段必须通过一个中间代码段（保护模式下的16位代码段）？

上面两个问题实际是一个问题。

存储段描述符的寄存器，例如`ds、cs、es、fs、ss`，存在对应的高速缓冲寄存器，称这批高速缓冲寄存器为R。实模式下，R有特定值。实模式和保护模式下，R的值不相同。从保护模式切换到实模式，必须先修改R中的值，把R的值从保护模式下的值修改成实模式下的值。

从保护模式切换到实模式的临界操作是设置cr0的PE位的值为0，称呼这个操作是O。由于实模式对R的要求，需要在O之前修改R的值，让R的值符合实模式的要求。R中除`cs`对应的高速缓冲寄存器（称这个寄存器是R-CS)外，都能用`mov`修改。修改`R-CS`只能用`jmp`、`call`、`iretf`。当前，最可能使用的是`jmp`。称这个修改操作是C。C的目的是，把`R-CS`修改为实模式的要求：16位。

分两种情况。

第一种，C在O之前，即C在保护模式下。执行C后，进入保护模式下的16位代码。此时，执行O，是在保护模式下的16位代码，即，在16位代码下切换到实模式。

第二种，C在O之后，即C在实模式下。会报错。因为，`R-CS`的值仍是保护模式下32位代码的。

对上面两种情况的分析，当然是正确的，可是，这根本不是在回答开头的问题啊。

再论证，为什么在保护模式的32位代码段切换到实模式下的16位代码段必须经过一个中间的保护模式下的16位代码段。

只有两种情况，经过中间代码段，不经过中间代码段。

分析不经过中间代码段这种情况。

在保护模式下的32位代码，执行O操作。此时，`R-CS`的值仍然是保护模式下的值，不符合实模式的要求，进入实模式失败。

那么，在执行O操作前，先执行C修改`R-CS`的值，那么，进入了保护模式下的16位代码段。此时，实质仍然是，经过了中间代码段。

证明了”不经过中间代码段“行不通，那么，自然只剩下”经过中间代码段“这种情况了。

开头的两个问题，已经被回答了。



```shell
Next at t=14487468
(0) [0x00000009045c] 0018:0000000000000002 (unk. ctxt): mov ds, ax                ; 8ed8
<bochs:5> s
00014487468e[CPU0  ] load_seg_reg(DS, 0x0018): not data or readable code
00014487468e[CPU0  ] interrupt(): gate descriptor is not valid sys seg (vector=0x0d)
00014487468e[CPU0  ] interrupt(): gate descriptor is not valid sys seg (vector=0x08)
00014487468i[CPU0  ] CPU is in protected mode (active)
00014487468i[CPU0  ] CS.mode = 16 bit
00014487468i[CPU0  ] SS.mode = 32 bit
```





## 好资料

从保护模式返回实模式

https://blog.51cto.com/13475106/2456581

https://blog.csdn.net/hackooo/article/details/45582103

http://blog.chinaunix.net/uid-22683402-id-1771401.html



```assembly
; 宏 ------------------------------------------------------------------------------------------------------
;
; 描述符
; usage: Descriptor Base, Limit, Attr
;        Base:  dd
;        Limit: dd (low 20 bits available)
;        Attr:  dw (lower 4 bits of higher byte are always 0)
%macro Descriptor 3
        dw      %2 & 0FFFFh                             ; 段界限1
        dw      %1 & 0FFFFh                             ; 段基址1
        db      (%1 >> 16) & 0FFh                       ; 段基址2
        dw      ((%2 >> 8) & 0F00h) | (%3 & 0F0FFh)     ; 属性1 + 段界限2 + 属性2
        db      (%1 >> 24) & 0FFh                       ; 段基址3
%endmacro ; 共 8 字节

LABLE_GDT_VIDEO: Descriptor     0b8000h,                0ffffh,          0c9ah
```

​	

```shell
[root@localhost v5]# xxd -u -a -g 1 -c 16 t2.bin
00000000: FF FF 00 80 0B 9A 00 00                          ........
[root@localhost v5]# xxd -b t2.bin
00000000: 11111111 11111111 00000000 10000000 00001011 10011010  ......
00000006: 00000000 00000000                                      ..
[root@localhost v5]# xxd t2.bin
00000000: ffff 0080 0b9a 0000                      ........
[root@localhost v5]#
```



一个大发现啊！以前的理解，都是错误的。

## 再理解段描述符

什么叫小端法？

低位放在内存地址小的内存，高位放在内存地址高的内存。一个十六进数字，`A9B7h`，按照小端法，二进制数据是：`B7 A9`，在内存中也是如此。

```assembly
; 宏 ------------------------------------------------------------------------------------------------------
;
; 描述符
; usage: Descriptor Base, Limit, Attr
;        Base:  dd
;        Limit: dd (low 20 bits available)
;        Attr:  dw (lower 4 bits of higher byte are always 0)
%macro Descriptor 3
        dw      %2 & 0FFFFh                             ; 段界限1
        dw      %1 & 0FFFFh                             ; 段基址1
        db      (%1 >> 16) & 0FFh                       ; 段基址2
        dw      ((%2 >> 8) & 0F00h) | (%3 & 0F0FFh)     ; 属性1 + 段界限2 + 属性2
        db      (%1 >> 24) & 0FFh                       ; 段基址3
%endmacro ; 共 8 字节

LABLE_GDT_VIDEO: Descriptor     0b8000h,                0ffffh,          0c9ah
```

​	

```shell
[root@localhost v5]# xxd -u -a -g 1 -c 16 t2.bin
00000000: FF FF 00 80 0B 9A 00 00                          ........
[root@localhost v5]# xxd -b t2.bin
00000000: 11111111 11111111 00000000 10000000 00001011 10011010  ......
00000006: 00000000 00000000                                      ..
[root@localhost v5]# xxd t2.bin
00000000: ffff 0080 0b9a 0000                      ........
[root@localhost v5]#
```

用上面的宏计算出来的段描述符的二进制数据是R

```shell
[root@localhost v5]# xxd -u -a -g 1 -c 16 t2.bin
00000000: FF FF 00 80 0B 9A 00 00 
```

R是正确的吗？

人工计算一次段属性，结果是R1。

1. `%2`的前2个字节，是R1的低16位，`ff ff`。
2. `%1`的前2个字节，是R1的第16~31位，`00 80`。
3. `%1`的第3个字节，是R1的第32~39位，`0b`。
4. `%3`的前1个字节，是R1的第40~41位，`9a`。
5. `%3`的最高四位，和`%2`的最高四位，组成一个字节M，前者在后面，即`段界限的最高四位----段属性的最高四位`。
   1. 为什么不是`段属性的最高四位----段界限的最高四位`？因为：
      1. M的下一个字节是`%1`的最后一个字节L。这是按小端法排列的二进制数据。
      2. 更具体地，和L相邻的那个bit是段属性中的`G`位。段描述符就是这样定义的。
      3. 如果`段属性的最高四位----段界限的最高四位`，无法满足”和L相邻的那个bit是段属性中的`G`位“这个要求。
      4. 综合小端法和段属性的定义，必须是：`段界限的最高四位----段属性的最高四位`。
      5. 可是，宏的定义中，明明是：`段属性的最高四位----段界限的最高四位`。而且，这个宏通过了测试。
   2. `%3`的最高四位是`00001100b(ch)`的高四位`0000`（它只是半个字节），`%2`的最高四位是`0000`，M是`00`。
6. `%1`的最高位字节是`00`。
7. 依次排列上面6步计算出来的结果：`ff ff 00 80 0b 9a 00 00`。

十六进数对字母大小写不敏感，R1 和 R2 相等。R是正确的，用上面的宏计算出来的段描述符是符合段描述符定义的。

其实，有一个简单的粗略检查这个宏是否正确，看2个结合点：

1. 第一个结合点，段描述符的第5个字节（段基址的第3个字节）的下一个字节是不是段描述符属性的第1个字节。
2. 第二个结合点，
   1. 段描述符的第7个字节B的下一个字节是不是段描述符的基地址的第4个字节。
   2. 还不够。B的最后四个BIT是不是段属性。
   3. 唉！又不能自圆其说了。

## 疑问

段描述符，不能自圆其说。





## 博客---保护模式和实模式之间的切换

实模式和保护模式是32位CPU的两种工作模式。32位CPU工作在实模式下的时候，并没有变成16位CPU，就像中学生做小学题目的时候并没有变成小学生一样。现代CPU是64位的，工作模式叫做长模式。

### 从实模式进入保护模式

流程如下：

1. 创建好GDT。
2. 创建好GdtPtr，保存GDT的物理地址和GDT中的字节限制（初始值是0，最大值是GDT的长度减1）。
3. 把GdtPtr放入专用寄存器`gdtr`，`lgdt [GdtPtr]`。
4. 关闭中断，`cli`。
5. 打开`A20`。
6. 打开`cr0`的PE位。
7. 跳入保护模式，`jmp dword 32位段代码段选择子:偏移量`。

执行`jmp dword 32位段代码段选择子:偏移量`时，已经是在保护模式下，但代码是在16位模式下编译的，使用`dword`使得操作数大于16位时不会被截取为16位。

`dword`会使`jmp dword 32位段代码段选择子:偏移量`这条语句在16位代码下加上反转前缀`0x66`。有了这个前缀，操作数`偏移量`会被扩展为32位。这是作者的猜测。未经证实。

从实模式进入保护模式的流程，是一个比较固定的模板，除了那句跳转语句，作者也没有其他疑问。没有什么好纠结的。

### 从保护模式切换到实模式

流程如下：

1. 先从保护模式下的32位代码进入保护模式下的16位代码。
2. 在保护模式下的16位代码段设置ds、es、fs、gs、ss的值是normalSelector选择子（一个符合实模式要求的选择子）。
3. 关闭cr0的pe位。
4. 跳回实模式下的16位代码段。

#### 两个问题

为什么不能在保护模式下的32位代码段返回实模式下的16位代码段？

为什么在保护模式下的32位代码段返回实模式下的16位代码段必须通过一个中间代码段（保护模式下的16位代码段）？

上面两个问题实际是一个问题。

存储段描述符的寄存器，例如`ds、cs、es、fs、ss`，存在对应的高速缓冲寄存器，称这批高速缓冲寄存器为R。实模式下，R有特定值。实模式和保护模式下，R的值不相同。从保护模式切换到实模式，必须先修改R中的值，把R的值从保护模式下的值修改成实模式下的值。

从保护模式切换到实模式的临界操作是设置cr0的PE位的值为0，称呼这个操作是O。由于实模式对R的要求，需要在O之前修改R的值，让R的值符合实模式的要求。R中除`cs`对应的高速缓冲寄存器（称这个寄存器是R-CS)外，都能用`mov`修改。修改`R-CS`只能用`jmp`、`call`、`iretf`。当前，最可能使用的是`jmp`。称这个修改操作是C。C的目的是，把`R-CS`修改为实模式的要求：16位。

分两种情况。

第一种，C在O之前，即C在保护模式下。执行C后，进入保护模式下的16位代码。此时，执行O，是在保护模式下的16位代码，即，在16位代码下切换到实模式。

第二种，C在O之后，即C在实模式下。会报错。因为，`R-CS`的值仍是保护模式下32位代码的。

对上面两种情况的分析，当然是正确的，可是，这根本不是在回答开头的问题啊。

再论证，为什么在保护模式的32位代码段切换到实模式下的16位代码段必须经过一个中间的保护模式下的16位代码段。

只有两种情况，经过中间代码段，不经过中间代码段。

分析不经过中间代码段这种情况。

在保护模式下的32位代码，执行O操作。此时，`R-CS`的值仍然是保护模式下的值，不符合实模式的要求，进入实模式失败。

那么，在执行O操作前，先执行C修改`R-CS`的值，那么，进入了保护模式下的16位代码段。此时，实质仍然是，经过了中间代码段。

证明了”不经过中间代码段“行不通，那么，自然只剩下”经过中间代码段“这种情况了。

开头的两个问题，已经被回答了。





