# 函数阅读笔记

## itoa

```c
PUBLIC char * itoa(char * str, int num)/* 数字前面的 0 不被显示出来, 比如 0000B800 被显示成 B800 */
{
	char *	p = str;
	char	ch;
	int	i;
	int	flag = FALSE;

	*p++ = '0';
	*p++ = 'x';

	if(num == 0){
		*p++ = '0';
	}
	else{	
		for(i=28;i>=0;i-=4){
			ch = (num >> i) & 0xF;
			if(flag || (ch > 0)){
				flag = TRUE;
				ch += '0';
				if(ch > '9'){
					ch += 7;
				}
				*p++ = ch;
			}
		}
	}

	*p = 0;

	return str;
}
```

功能是，把整型数字转换成字符串类型的十六进制数，数字前面的0不显示。

流程是：

1. 存储结果的是`str`，要被转换的数字是`num`。
2. 先在存储结果的字符串前面加上`0x`。
3. 依次获取`num`的第31位~第28位、第27位~第24位、第23位~第20位、第19位~第16位、第15位~第12位、第11位~第8位、第7位~第4位、第3位~第0位。
4. 也就是说，将`num`的二进制分成8组（每组四位，刚好32位）。
5. 将每组的值`value`加上字符`0`，结果是`asciiCode`。
6. 比较`asciiCode`和字符`9`，按下面的流程对`asciiCode`进行转换，然后得到`asciiCode`的字符形式`ch`。
   1. 比字符`9`小。字符`0~~9`正好和整型`0~~9`的字符形式一一对应，不需要转换。
   2. 比字符`9`大，将asciiCode加7
      1. 大于整型`9`的整型数字`10、11、12、13、14、15`（将这批数字记作`nums`）对应的字符应该是`A、B、C、D、E、F`。
      2. `nums+'0'`的结果并不是`A、B、C、D、E、F`。要让`nums`与`A、B、C、D、E、F`一一对应，需要将asciiCode加7。
      3. 这么一个简单的逻辑，要用文字叙述清楚，很不容易。甚至上面这段文字叙述得就不清楚。
   3. 这么叙述吧。
      1. 整型数字`0~~9`与字符`0~~9`的一一对应的差值是字符`0`的ascii码。
      2. 整数数字`10~~15`与字符`A~~F`一一对应的差值是字符`0`的ascii码加7。
      3. 非要问是怎么得出上面两个结论的，回答是：举例、观察、归纳。
7. 将`ch`拼接到`str`。
8. 最后一句`*p = 0;`是否有必要，无法心算。比较容易纠结这种corner case。

