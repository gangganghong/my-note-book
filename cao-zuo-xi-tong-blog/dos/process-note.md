# 操作系统---怎么实现一个进程--笔记

## 概念

进程具有独立的逻辑控制流和独立的地址空间。

进程是操作系统调度资源的最小单位。

进程是一个运行中的程序的实体。

## 例子

`Jim`在厨房里把鸡蛋、西红柿放到铁锅里做西红柿炒鸡蛋，他的小女儿突然哭起来。`Jim`停止做西红柿炒鸡蛋，跑过去哄小女儿。等小女儿不哭以后，他回到厨房继续做西红柿炒鸡蛋。

在这个故事中，`Jim`是CPU；做西红柿炒鸡蛋是进程；西红柿、鸡蛋和铁锅是进程使用的资源；从“做西红柿炒鸡蛋”到“哄小女儿”是进程切换。

## 进程的构成要素

回顾已经写过的在CPU中执行的那些程序，它们实际上就是进程。它们包含哪些构成元素呢？

1. 代码。程序不都是由代码组成的吗？这里的代码是指“可执行”的指令，例如`mov ax, 7`。
2. 数据。打印一个字符串“Hello,World"，而这个字符串需要提前定义好。这类字符串就是数据。
3. 堆栈。`push  ax    pop  ax`中的`push`的操作对象是一个堆栈。它是一段存储空间。

一个单独的进程只需要具备“代码、数据、堆栈‘三个基本要素就行。可我们的目标是让CPU执行多个进程，这就需要额外增加一个要素：进程调度。

进程调度的简化版是进程切换，不是让CPU一直执行同一个进程，而是让CPU执行A进程一段时间后再执行B进程。调度，是指切换的策略，不是简单地从A换成B。

## 进程调度

### 是什么

不讲述各种经典的调度算法。各种经典的操作系统书籍讲述得比我好很多。

我要讲述的是实现进程调度，一个最简单的进程切换是怎么实现的。

不会写代码切换进程，各种经典的调度算法永远都是理论。当然，你也可以单独用代码实现那些经典的调度算法。可是，那样怎么看都是一个”阉割版“的孤立的知识点。一旦学会怎么切换进程，想让切换变得更高效，只是一个”实现调度算法、再把它嵌入自己的操作系统“的过程。调度算法已经不是一个孤立的知识点，而是你的成品---一个简单的操作系统的一部分。

所以，进程调度，可以分为两个步骤去掌握。第一步，实现进程切换；第二步，更优雅、更高效地切换。本小节，只讲述第一步。

### 做什么

限定条件是：只有一个CPU。

我们要让CPU接连不断地运行A进程，然后运行B进程，再运行C进程。总之，让CPU在运行过程中运行各种不同的进程。

简化场景，CPU只有A进程和B进程需要运行；运行A进程一段时间后，然后停止运行A进程，转而运行B进程。

接下来，会发生什么呢？

停止运行B进程，又重新运行A进程。注意，”重新运行A进程“，不是完全从头开始运行A进程，而是”第一次A运行到哪里、第二次运行A的时候接着第一次运行的结果继续运行“，第二次需要”衔接“第一次。

举例来说，A进程在开始声明一个变量a并为a赋值5；CPU运行A，停止的时候，a的值变为7；当CPU从运行B转向运行A的时候，a的值应该是上一次停止A的时候保存的值。这就是”衔接“而不是”另起炉灶“。

一个进程停止后再运行，需要上次停止时的执行结果。这个执行结果就是进程运行过程中的一个快照。

#### PCB

存储进程执行中间结果的那个东西，有个术语，叫“进程控制表”（也叫“进程控制块”），英文缩写是`PCB`。

恢复运行一个进程需要什么，`PCB`中就应该包含什么。

#### 特权级切换

进程进程，涉及两个特权级：用户进程的特权级和进程调度程序的特权级。前者的特权级是1，设置成3也可以。后者的特权级一定是0。

~~进程切换的过程是两次特权级转移的过程：~~

进程切换，有两次特权级转移：

1. 用户进程失去CPU的控制权，调度程序取得CPU的控制权，特权级从1转移到0。
2. 调度程序失去CPU的控制权，用户进程取得CPU的控制权，特权级从0转移到1。

现实中，用户进程不会主动放弃CPU的控制权一直到它完成任务主动退出。操作系统也没有等待一个用户进程一直执行结束才运行其他进程。它利用时钟中断的契机调度进程。进程调度代码就在时钟中断例程中，处于特权级0。

时钟中断例程选择用户进程，使用`iretd`指令让CPU再次执行用户进程，回到特权级1。

简单地说，用户进程依赖时钟中断切换到时钟中断例程（特权级从1转移到0），时钟中断例程使用指令`iretd`返回到用户进程（特权级从0转移到1）。

#### 进程快照

##### 保存什么

进程被挂起时需要保存什么？

一个进程使用的资源是代码和数据。代码保存在内存中，数据保存在内存和寄存器中。这样划分不能完全反映实际情况。不过，可以确定的是，一个进程使用的资源存储在寄存器和内存中。每个进程使用的内存是独立的（A进程使用的内存空间不会被B进程读写数据），但与其他进程共用CPU。这意味着寄存器中的值可能会被其他进程改变。

被改变的数据就是需要被保存起来的，否则，被挂起的进程再恢复时不能在上一次执行的基础上“衔接”执行。全部寄存器中的数据都需要保存起来，在挂起进程时。

全部寄存器是哪些寄存器？

1. 段寄存器：`cs、ds、ss、es、fs、gs`。
2. 通用寄存器：`eax、ebx、ecx、edx`。
3. 其他：`ebp、esp、esi、edi、eip`。（不知道它们是哪一类寄存器。这不重要。）

##### 怎么保存

用`push`把需要保存的寄存器中的值逐个入栈。CPU提供了一个专门指令，`pushad`。

`pushad`指令所做的工作：

1. 依次将`eax、ecx、edx、ebx、esp、ebp、esi、edi`入栈。
2. 执行`esp-32`。
   1. 栈地址从高地址向低地址递减。
   2. `push eax`指令封装两条指令：
      1. `sub	esp, 4`。栈中的一个元素占用4个字节，新入栈元素要紧挨着当前栈顶元素的位置。
      2. `mov [esp], eax`。

我们保存寄存器的值，这样做：

1. 用`pushad`依次保存`eax、ecx、edx、ebx、esp、ebp、esi、edi`的值。
2. 再用`push`手工把`cs、ds、ss、fs、gs、eip`的值入栈。
   1. 如果使用`call`，会自动入栈`cs、eip`的值。
   2. 只需保证最后入栈的是`cs、eip`的值，其他的寄存器值的次序随意。

###### 疑问

`push eax`是对下面语句的封装。

```assembly
sub		esp,	4
mov		esp,	eax
```

假如一个栈的栈顶地址是`32`，空栈。

1. 第一次入栈数据D1，按照上面的分解语句操作，D1被存储初始地址为`32-4=28`的4个内存空间`28、27、26、25`。编号`32、31、30、29`的内存空间没有被使用。这怎么理解？

2. 第二次入栈数据D2，D2被存储在初始地址为`28-4=24`的4个内存空间`24、23、22、21`中，正好跳过`28、27、26、25`这4个内存空间，又无缝衔接。没有问题。

上面说的`push eax`操作的两条等价语句是权威书籍上讲的，我虽有上面第1点的疑问，仍只能暂时这样理解。

##### 怎么恢复

寄存器的值保存在栈中，恢复数据自然使用出栈指令`pop`。按照入栈顺序倒序出栈更新`cs、eip`外的寄存器。使用`iretd`依次出栈更新`cs、eip`中的值。	

## 意外收获

### push

`push ax`指令是对下列语句的封装：

1. `sub sp, 2`。
2. `mov [ss:sp], ax`。

`sp`指向的并不是某个刻度，例如厘米尺子上的`7cm`那个刻度，而是`7cm~8cm`这个`1cm`的长度。看下面的示意图。

| 1000Ah |      |                   |
| ------ | ---- | ----------------- |
| 1000Bh |      |                   |
| 1000Ch |      |                   |
| 1000Dh |      |                   |
| 1000Eh |      |                   |
| 1000Fh |      | <-----------ss:sp |

执行

```assembly
mov ax, 6622h
push	ax
```

堆栈示意图变成

| 1000Ah |      |                   |
| ------ | ---- | ----------------- |
| 1000Bh |      |                   |
| 1000Ch |      |                   |
| 1000Dh | 66   | <-----------ss:sp |
| 1000Eh | 22   |                   |
| 1000Fh |      |                   |

再执行

```assembly
mov ax, 7744h
push	ax
```

堆栈示意图变成

| 1000Ah |      |                   |
| ------ | ---- | ----------------- |
| 1000Bh | 77   | <-----------ss:sp |
| 1000Ch | 44   |                   |
| 1000Dh | 66   | 旧栈顶            |
| 1000Eh | 22   |                   |
| 1000Fh |      |                   |

注意，`ss:sp`指向的是单元格，这个单元格是栈顶。新入栈数据填充到旧栈顶单元格上面的两个新增的单元格。

假如，示意图中的堆栈是一个空栈，那么，`ss:sp`应该在下图中的位置。

| 1000Ah |      |                   |
| ------ | ---- | ----------------- |
| 1000Bh | 77   | <-----------ss:sp |
| 1000Ch | 44   |                   |
| 1000Dh | 66   | 旧栈顶            |
| 1000Eh | 22   |                   |
| 1000Fh |      |                   |
| 10011h |      | 空栈的栈顶        |