# 自己写操作系统笔记

要自己写操作系统了，我打算先写文章，弄清楚写一个操作系统的具体细节。

## 代码模块

一个最小的操作系统内核，包含boot、loader和kernel。

boot是从bios接手工作，读取loader的指令，并将控制权交给loader。loader读取kernel，并将控制权交给kernel。kernel就是操作系统，会一直运行。是一个while(1)循环。

为什么需要使用这种接力赛的方式呢？因为前期使用的内存空间有限，能够存储的指令有限，只能完成有限的工作。

为什么boot、loader能使用的内存空间有限？我不记得了。

boot的工作是从软盘中读取loader，然后跳转到loader。还有其他必须完成的工作吗？不记得了。

loader的工作是从软盘中读取kernel，然后跳转到kernel。不记得还有没有其他工作。

进入保护模式是在boot还是loader中完成？

### boot

boot一共有且只有512字节，结尾必需是魔数 `0x55AA`。

在boot中需要先进入保护模式吗？在实模式下，能使用的最大内存是多少？

实模式下，寄存器是16位，总线是20位，通过 ”段地址 * 16 + 偏移量“来表示内存地址，能表示的最大内存是1M，即2的20次方Byte的内存。

这种表示内存地址的方式，能表示的地址，能超过1M，可是受限于20位的总线，能表示的最大内存只能是1M，超过1M，就会回卷到重新从零开始，就如同用段地址+偏移量 与 1M 取模一样，值才是真正的内存地址。

在boot中需要初始化全局描述符吗？

要打印字符到屏幕，需要使用显存，因此，需要初始化全局描述符。

全局描述符，在boot或loader中初始化，都可以。

但boot的主要任务是将loader读取到内存，然后跳转到loader。

boot的内存初始地址是0X7C00，loader的内存初始化内存地址是多少？

最大的难题是，如何从fat12系统中读取loader。

对loader有大小限制吗？

#### gdt

gdt是全局描述符，共8个字节，64位，从0到63位。gdt的布局，杂乱无章，这是兼容早期情况造成的。

gdt中存储了段基址、段界限。还有一个需要特别注意的元素，是描述段界限的单位的。它决定着段界限的单位是4KB还是byte。

与gdt相关的一个概念是全局描述符选择子。全局描述符选择子是描述符在描述符表中的索引，和数组的索引类似。是的，不止一个全局描述符。所有全局描述符存组成一个全局描述符表。在这个表中，第一个元素是一个特别的全局描述符，可以叫它空全局描述符。因为它的段基址、段界限和段属性全都是0。全局描述符的选择子，就是这个全局描述符相对于空全局描述符的偏移量。这个偏移量的单位是8个字节，即64位。

全局表述符表相当于C语言中的数组，在内存中是一段连续的内存区域（没有开启分页等内存转换机制的情况下，在物理内存中也是一段连续的内存区域）。在汇编语言中，数组，写成一段代码紧挨着另一段代码，代码的前后顺序就是它们在内存中的排列顺序。

CPU提供了专门存储gdt的寄存器gdtr。将gdt加载到gdtr中使用lgdt。

我不记得gdt的结构（需要记住吗？有用吗？有用的话，我就像背英语单词一样记住它们）。

用汇编语言实现它的方式是，编写一个宏，有三个参数，分别是，段基址，段界限，段属性。

#### 从FAT12系统中读取loader

FAT12是一个文件系统，最大能存储多少数据？不知道。

在loader的开头，写上一串固定的指令。不确定。是在loader写上了固定的指令还是在boot写上了固定的指令。这些指令是FAT12的文件头？要弄清楚这些指令的准确术语，这是基本要求。所谓基本，是必须项，其他的可以没有，这个必须有。

很复杂。第一次看资料时，就没彻底看明白。现在，我更加没有多少印象。

FAT12的结构是，引导扇区、2个FAT、根目录区、数据区。2个FAT的内容相同，之所以用2个，是为了冗余。

在FAT12系统中查找loader的过程是这样的。

遍历根目录区，比较根目录区的文件名是不是loader。如果是，这个根目录就是目标根目录。

怎么遍历根目录呢？引导扇区占用1个扇区，2个FAT占用？个扇区，紧挨着第二个FAT所占用扇区的后面的那个扇区，就是根目录区的初始扇区。只需确定这个扇区是第几个扇区，就能确定根目录区的初始值了。

确定根目录区的初始值后，从中找出loader的第一个FAT项的序号。然后再从FAT表中找到第一个FAT项。FAT项一共有12位，低四位是下一个FAT项的序号，高八位是loader所占用的软盘的第一个簇（簇等同于扇区）。遍历FAT的终止条件是什么？

引导扇区的初始地址是0X7C00，引导扇区中存放的是什么？

第一个FAT的初始地址是 0X7C00 + 512。每个FAT项的大小是12个字节，假设loader的第一个FAT项的序号是2，那么，它的内存地址是

0X7C00 + 512 + 24。

一个FAT项可能会跨域两个扇区，因为一个FAT项占用12个字节。如果每个FAT项占用8个字节，那么，任何一个FAT项都不会跨越两个扇区。对“一个FAT项可能会跨域两个扇区”的情况，需要有处理方法。这种特殊情况，我是没想到的，作者提到的。他也给出了处理方法，我不记得了。

如何读取FAT项，是一块非常难啃的硬骨头。第一次看代码时，我就没看明白。刚才看代码，仍然不明白。先搁置吧。

### loader

loader完成的工作是，进入保护模式，把kernel读取到内存。先进入保护模式，再读取kernel到内存。因为，kernel的大小最终会超过1M。

#### 读取kernel

与读取loader使用同样的方法。没理解那个方法，本处也搁置从FAT12中读取kernel。

#### 进入保护模式

保护模式不同于之前的实模式。在总线只有20位的时代，CPU运行的模式就是实模式。在实模式下，给出的内存地址，是真实的物理内存地址。每条指令能够使用任意一块内存，拥有最高权限。一个程序的指令能修改另外一个程序的内存中的数据。

在保护模式下，段基址是选择子的偏移量。（不确定）。内存地址怎么计算？先找到GDT的选择子，然后根据选择子找到GDT，解析GDT计算出内存地址。没有启用分页模式时，这个内存地址，就是最终的内存地址。启用了分页模式后，这个内存地址是线性地址。

在保护模式下，指令能够访问的内存，只有它所在的段所在的内存地址，也就是全局描述符中的段基址和段偏移量指定的地址。每条指令都拥有独立的内存空间，不能访问其他段的内存地址。进入保护模式后，CPU的寄存器都升级为32位，总线也升级为32位，能访问的最大内存地址是2的32次方，即4GB。

保护模式保护的是，每个程序只能使用自己的内存空间，不能破坏其他程序的内存空间，例如，用户程序不能访问修改操作系统的内存空间。这为一个CPU并发运行多个不同的程序提供了条件。

怎么进入保护模式？

不复杂，有特定步骤。首先，打开A20。然后，改变某个寄存器的值。具体内容，我忘记了。是否需要能够默写出来？至少，能准确说出A20、某个寄存器的准确名称。

最后，是一个关键的跳转。这个跳转地址是kernel的入口，是个远跳转。为啥使用远跳转？因为是从一个段跳转到另外一个段吗？我觉得进入保护模式前和进入保护模式后，都在同一个段啊。或者，这样理解，语法而已，不必问为什么。知道了也没啥价值。

### kernel

## 操作系统功能

操作系统的四个基本功能，分别是进程、文件系统、内存管理和系统调用。

### 进程

#### 进程的实现

进程的组成要素：代码段、数据段和堆栈段。代码，直接写在指令中，其实就是一个函数。三个段在同一个段中。我没有看到数据段。堆栈，用C语言中的一个数组来表示。

执行哪个进程，是由 cs:ip 决定的。cs是代码段（？），ip 是指令计数器，即下一条要执行的指令。

每个进程都有一个进程表，进程表的第一个成员变量是寄存器数组。它是堆栈。第二个成员变量是什么？完全记不起来了。需要看书和代码。最多只能算是凭着记忆写操作系统。真正自己写操作系统，能独立设计出进程表的所有成员变量。

其他成员变量。

文件描述符。该进程打开的文件。文件描述符只有一个吗？据我所知，进程能够打开的文件不止一个。

全局描述符表。

全局描述符的选择子。不理解。已经知道选择子，就能找到全局描述符，为什么还需要设置一个全局描述符表呢？

进程优先级。进程调度所需。

进程ticks。与进程优先级一起使用来实现进程调度。进程ticks的初始值是进程优先级。进程每使用CPU一次，就将ticks减去1。当ticks为0时，重新初始化为进程优先级。是这样吗？

#### 第一个进程的启动

先把进程运行所需的堆栈准备好，然后从堆栈中取出需要的数据（段基值、段偏移量、通用寄存器所需要的值、指令计数器等），最后使用ret完成进程的启动。

“从堆栈”，怎么知道堆栈的地址呢？从TSS的ss0中获取堆栈地址。

TSS，是任务状态（？忘记了准确的专业术语）。它提供了一整套实现进程的条件，可是我要写的操作系统、Linux却没有完全使用TSS提供的条件，原因是开销太大。为什么说开销很大？书上写了一个复杂的过程，我没记住。我打算只使用ss0。

有三个级别，ring0、ring1、ring2。三个级别还是四个级别？

每个级别对应一个ss0。时钟中断，为切换进程提供了契机。

时钟中断发生，切换进程之前，当前进程的寄存器中的数据会被建立一个“快照”，存储到这个进程的堆栈中，而这个堆栈的地址，被存储到ss0中。存储寄存器中的数据到堆栈中，需要人工完成。存储堆栈地址到ss0中，是CPU自动执行的。

这块知识点，仍然含糊不清，想不起来。重点是，有个环节，是CPU自动完成的。不理解这点，非常影响理解进程切换的实现方法。

这块知识点，没有记住重点。堆栈地址，似乎没有存储到ss0中。获取堆栈地址，只需从进程表中获取。

那么，ss0，作用是什么？

#### 进程的切换

进程切换的基本实现方法，已经在上面写得差不多了。只需记住，进程切换的契机是时钟中断，切换进程，实在是跳转。

第一期，我只实现最基本的进程切换功能，完全不会加入那些复杂的调度算法。

#### 进程的调度

### 文件系统

和linux的文件系统不同，我要实现的文件系统非常简单。

这个系统的构成要素有，超级块、inode位图、sector位图、inode数组、根目录区、数据区。

超级块中包含：数据区的第一个扇区号、魔数（？）。其他的，全部忘记。

inode数组：每个元素是一个inode结构。inode的结构是什么？忘记了。

inode项，包含文件名、文件数据的第一个扇区号、文件一共有多少个扇区。

根目录区：根目录是“/"。根目录项的结构是什么？忘记了。

有多少个文件，就有多少个根目录项。一个文件，对应一个根目录项。根目录项会给出文件对应的inode在inode数组中的索引。

数据区：每个文件的数据都存储在这里。

### 内存管理

把内存分隔成一个又一个格子，每个格子1M。

并没有涉及多少内存管理的内容，而是，实现几个函数。

#### fork

复制父进程的内存空间到新的内存空间，内容一致，内存地址不同。

#### exec

#### exit

#### wait

